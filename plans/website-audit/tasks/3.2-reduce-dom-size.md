# Task 2.2: Reduce DOM Size

## üéØ Goal

Reduce DOM size from 6300+ nodes to under 1500 nodes per page by implementing virtualization and optimizing component rendering.

## üìç Context

**Current Issues**:
- Some pages: 6300+ DOM nodes (recommended: <1500)
- DOM depth: Up to 45 levels (recommended: <32)
- Worst pages:
  - `/linear-methods/characteristic-polynomial`: 6315 nodes
  - `/linear-methods/determinant-calculation`: 6301 nodes
  - `/linear-methods/cramer-rule`: 5318 nodes

**Root Causes**:
1. Math content creates excessive nesting (MathJax/KaTeX)
2. No virtualization for long content
3. Unnecessary wrapper elements
4. Tables and code blocks not optimized
5. All content rendered at once

**Why This Matters**:
- Slow rendering on mobile devices
- High memory usage
- Poor scrolling performance
- Affects INP (Interaction to Next Paint)
- Battery drain on mobile

## PRD

```json
{
  "category": "performance",
  "description": "Reduce DOM size through virtualization, lazy loading, and component optimization",
  "steps": [
    "Implement virtualization for long content lists",
    "Lazy render math components below the fold",
    "Optimize content renderer to reduce wrapper elements",
    "Add intersection observer for below-fold content",
    "Flatten unnecessary DOM nesting",
    "Test DOM size on all page types",
    "Verify mobile scrolling performance"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] No page exceeds 1500 DOM nodes
- [ ] DOM depth < 32 levels on all pages
- [ ] Mobile scrolling remains 60fps
- [ ] All content still accessible
- [ ] No visual regression
- [ ] All tests pass

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck
pnpm test

# Check DOM size in browser console
document.querySelectorAll('*').length
```

## üìù Implementation

### Subtask 2.2.1: Create Virtualized Content Component

**File to create**: `apps/www/components/contents/virtualized-content.tsx`

```typescript
"use client";

import { useEffect, useRef, useState } from "react";
import { cn } from "@repo/design-system/lib/utils";

interface VirtualizedContentProps {
  children: React.ReactNode;
  className?: string;
  threshold?: number;
}

export function VirtualizedContent({
  children,
  className,
  threshold = 0.1,
}: VirtualizedContentProps) {
  const [isVisible, setIsVisible] = useState(false);
  const ref = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry?.isIntersecting) {
          setIsVisible(true);
          observer.disconnect();
        }
      },
      { threshold }
    );

    if (ref.current) {
      observer.observe(ref.current);
    }

    return () => observer.disconnect();
  }, [threshold]);

  return (
    <div
      ref={ref}
      className={cn(
        "min-h-[100px] transition-opacity duration-300",
        isVisible ? "opacity-100" : "opacity-0",
        className
      )}
    >
      {isVisible ? children : null}
    </div>
  );
}
```

### Subtask 2.2.2: Optimize Math Rendering

**File to modify**: `apps/www/components/math/math-display.tsx`

Add lazy loading for math content:

```typescript
"use client";

import { useEffect, useRef, useState } from "react";
import dynamic from "next/dynamic";

// Dynamically import heavy math libraries
const DynamicMath = dynamic(
  () => import("./math-renderer").then((mod) => mod.MathRenderer),
  {
    loading: () => (
      <div className="h-8 w-full animate-pulse rounded bg-muted" />
    ),
    ssr: false,
  }
);

interface MathDisplayProps {
  math: string;
  block?: boolean;
}

export function MathDisplay({ math, block = false }: MathDisplayProps) {
  const [shouldRender, setShouldRender] = useState(false);
  const ref = useRef<HTMLSpanElement>(null);

  useEffect(() => {
    // Render immediately if in viewport, otherwise use intersection observer
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry?.isIntersecting) {
          setShouldRender(true);
          observer.disconnect();
        }
      },
      { rootMargin: "200px" } // Start rendering 200px before visible
    );

    if (ref.current) {
      observer.observe(ref.current);
    }

    return () => observer.disconnect();
  }, []);

  return (
    <span ref={ref} className={block ? "block my-4" : "inline"}>
      {shouldRender ? (
        <DynamicMath math={math} block={block} />
      ) : (
        <span className="inline-block min-w-[2rem] animate-pulse rounded bg-muted" />
      )}
    </span>
  );
}
```

### Subtask 2.2.3: Optimize Content Renderer

**File to modify**: `apps/www/components/contents/content-renderer.tsx`

Reduce wrapper elements:

```typescript
// Before: Multiple nested divs
<div className="content-wrapper">
  <div className="content-inner">
    <div className="content-body">
      {content}
    </div>
  </div>
</div>

// After: Flatten structure
<article className="prose prose-lg max-w-none">
  {content}
</article>
```

### Subtask 2.2.4: Chunk Large Content

**File to create**: `apps/www/components/contents/content-chunker.tsx`

```typescript
"use client";

import { Children, isValidElement, useMemo } from "react";
import { VirtualizedContent } from "./virtualized-content";

interface ContentChunkerProps {
  children: React.ReactNode;
  chunkSize?: number;
}

export function ContentChunker({
  children,
  chunkSize = 5,
}: ContentChunkerProps) {
  const chunks = useMemo(() => {
    const childArray = Children.toArray(children);
    const result: React.ReactNode[][] = [];

    for (let i = 0; i < childArray.length; i += chunkSize) {
      result.push(childArray.slice(i, i + chunkSize));
    }

    return result;
  }, [children, chunkSize]);

  return (
    <>
      {/* First chunk always rendered */}
      <div>{chunks[0]}</div>

      {/* Remaining chunks virtualized */}
      {chunks.slice(1).map((chunk, index) => (
        <VirtualizedContent key={index} threshold={0.05}>
          <div>{chunk}</div>
        </VirtualizedContent>
      ))}
    </>
  );
}
```

### Subtask 2.2.5: Optimize Tables

**File to modify**: Table rendering components

Add virtualization for large tables:

```typescript
"use client";

import { useMemo } from "react";

interface OptimizedTableProps {
  data: Array<record<string, unknown>>;
  columns: string[];
  maxRows?: number;
}

export function OptimizedTable({
  data,
  columns,
  maxRows = 50,
}: OptimizedTableProps) {
  const displayData = useMemo(() => {
    if (data.length <= maxRows) return data;
    
    // Show first and last rows with indicator
    const first = data.slice(0, maxRows / 2);
    const last = data.slice(-maxRows / 2);
    const hidden = data.length - maxRows;
    
    return {
      first,
      last,
      hidden,
      total: data.length,
    };
  }, [data, maxRows]);

  if (Array.isArray(displayData)) {
    // Render full table
    return <FullTable data={displayData} columns={columns} />;
  }

  // Render truncated table with expand option
  return (
    <CollapsedTable
      first={displayData.first}
      last={displayData.last}
      hidden={displayData.hidden}
      total={displayData.total}
      columns={columns}
    />
  );
}
```

---

## üöÄ Next Steps

After this task:
- Next: Task 2.3 - Preload Critical Resources
- Dependencies: None

## üîó Related Tasks

- Task 2.1: Optimize TTFB (performance)
- Task 2.3: Preload Critical Resources (performance)

## ‚ö†Ô∏è Important Notes

### Testing DOM Size

```javascript
// In browser console
const count = document.querySelectorAll('*').length;
const depth = Math.max(...Array.from(document.querySelectorAll('*')).map(el => {
  let depth = 0;
  let node = el;
  while (node.parentElement) {
    depth++;
    node = node.parentElement;
  }
  return depth;
}));

console.log(`DOM nodes: ${count}, Max depth: ${depth}`);
```

### Mobile Performance

Test on real devices:
- iPhone 12 or newer
- Mid-range Android (Pixel 5, Samsung A52)
- Use Chrome DevTools Performance tab
- Look for long tasks (>50ms)

### Accessibility

Ensure virtualization doesn't break:
- Screen reader navigation
- Keyboard navigation
- Search (Ctrl+F)
- Print functionality

### Trade-offs

Virtualization means:
- Content below fold not immediately searchable
- Print may need special handling
- SEO still works (server-side rendering)

---

## Progress Update Template

After completing this task, update `plans/website-audit/progress.txt`:

```txt
[YYYY-MM-DD HH:mm] Task 2.2 completed - Reduce DOM Size

Key decisions:
- Implemented VirtualizedContent component with Intersection Observer
- Added lazy loading for math components
- Flattened content renderer structure
- Created ContentChunker for large articles
- Optimized large tables with row limits

Files created:
- apps/www/components/contents/virtualized-content.tsx
- apps/www/components/contents/content-chunker.tsx

Files modified:
- apps/www/components/math/math-display.tsx
- apps/www/components/contents/content-renderer.tsx

Performance improvements:
- DOM nodes: 6315 ‚Üí 1200 (81% reduction)
- DOM depth: 45 ‚Üí 28 levels
- Mobile scrolling: 60fps sustained
- Lighthouse Performance: +5 points

Blockers/notes:
- None
- Tested on iPhone 12 and Pixel 5
- Print functionality preserved
- Screen reader navigation works
```
