# Task 2.3: Create Content Search Endpoint

## üéØ Goal

Create `/v1/contents/search` endpoint for full-text search across all content.

## üìç Context

This is **Phase 2.3** of Build Public Content API phase.

Developers need more than just browsing pagination (list endpoint). They need to search content by:

- Keywords
- Phrases
- Tags
- Titles

This endpoint provides:

- Full-text search across all content
- Ranked results by relevance
- Filtering by type, locale
- Rate limiting

## üé¨ Success Criteria

- [ ] `/v1/contents/search` POST endpoint created
- [ ] Requires API key authentication
- [ ] Supports search by query, locale, type
- [ ] Returns ranked results with relevance scores
- [ ] Returns metadata + content snippets
- [ ] Rate limited per API key tier
- [ ] Returns proper HTTP codes (200, 401, 429)

## üìù Subtasks

### Subtask 2.3.1: Define Request/Response Schemas

Create TypeScript interfaces for search functionality.

**File to create**: `packages/backend/convex/routes/v1/contents/search/types.ts`

**Implementation**:

```typescript
export interface SearchContentsRequest {
  query: string; // Search query (keywords, phrases)
  locale?: "en" | "id";
  type?: "articles" | "subject" | "exercises";
  limit?: number; // Max results to return (default: 20, max: 100)
}

export interface SearchContentsResponse {
  results: SearchResult[];
  total: number;
  query: string;
  searchTime: number; // Time taken in milliseconds
}

export interface SearchResult {
  slug: string;
  url: string;
  locale: string;
  type: "articles" | "subject" | "exercises";
  title: string;
  description: string;
  snippet: string; // Highlighted matching text
  relevanceScore: number; // 0.0 to 1.0, higher = more relevant
  metadata: {
    tags: string[];
    category?: string;
    grade?: string;
    material?: string;
  };
}
```

**Search Strategy**:

1. Full-text search in title, description, tags
2. Keyword extraction and matching
3. Relevance scoring based on:
   - Title match (highest weight)
   - Description match (medium weight)
   - Tag match (medium-high weight)
   - Exact phrase match (bonus)

**Output**: Type-safe schemas

---

### Subtask 2.3.2: Implement Search Algorithm

Create relevance-based search function.

**File to create**: `packages/backend/convex/routes/v1/contents/search/utils.ts`

**Implementation**:

```typescript
import { getContents } from "@repo/contents/_lib/content";

export async function searchContents(params: SearchContentsRequest) {
  const { query, locale = "en", type, limit = 20 } = params;

  // 1. Extract keywords from query
  const keywords = extractKeywords(query);
  const lowercaseQuery = query.toLowerCase();

  // 2. Fetch all contents (metadata only)
  const allContents = await getContents({
    locale,
    basePath: "", // Fetch all
    includeMDX: false,
  });

  // 3. Calculate relevance scores for each item
  const results = allContents
    .filter((item) => {
      // Filter by type if specified
      if (type && detectContentType(item.slug) !== type) {
        return false;
      }
      return true;
    })
    .map((item) => {
      const title = item.metadata.title.toLowerCase();
      const description = (item.metadata.description || "").toLowerCase();
      const tags = (item.metadata.tags || []).map((t) => t.toLowerCase());

      let score = 0;

      // Title matching (highest weight: 0.5)
      if (title.includes(lowercaseQuery)) {
        score += 0.5;
      } else {
        // Partial keyword match in title
        for (const keyword of keywords) {
          if (title.includes(keyword)) {
            score += 0.25; // Partial match
          }
        }
      }

      // Exact phrase match in title (bonus: 0.3)
      if (title.includes(lowercaseQuery) && keywords.length > 1) {
        score += 0.3;
      }

      // Description matching (medium weight: 0.3)
      if (description.includes(lowercaseQuery)) {
        score += 0.3;
      }

      // Tag matching (medium-high weight: 0.35)
      for (const tag of tags) {
        if (tag.includes(lowercaseQuery) || keywords.includes(tag)) {
          score += 0.35;
          break; // Count once per item
        }
      }

      return {
        slug: item.slug,
        url: item.url,
        locale: item.locale,
        type: detectContentType(item.slug),
        title: item.metadata.title,
        description: item.metadata.description || "",
        snippet: generateSnippet(description, query),
        relevanceScore: Math.min(score, 1.0), // Cap at 1.0
        metadata: {
          tags: item.metadata.tags || [],
          category: extractCategory(item.slug),
          grade: extractGrade(item.slug),
          material: extractMaterial(item.slug),
        },
      };
    })
    .sort((a, b) => b.relevanceScore - a.relevanceScore) // Sort by relevance (descending)
    .slice(0, limit); // Limit results

  return results;
}

function extractKeywords(query: string): string[] {
  // Split by spaces, remove stop words, filter short words
  const stopWords = new Set([
    "the", "a", "an", "and", "or", "but", "in", "on", "at", "to",
    "of", "for", "with", "is", "as", "by", "this", "that",
  ]);

  return query
    .toLowerCase()
    .split(/\s+/)
    .filter((word) => word.length > 2)
    .filter((word) => !stopWords.has(word));
}

function generateSnippet(text: string, query: string): string {
  const lowercaseText = text.toLowerCase();
  const index = lowercaseText.indexOf(query.toLowerCase());

  if (index === -1) {
    return text.substring(0, 150) + (text.length > 150 ? "..." : "");
  }

  // Get context around match (50 chars before and after)
  const start = Math.max(0, index - 50);
  const end = Math.min(text.length, index + query.length + 50);

  let snippet = text.substring(start, end);

  // Highlight query in snippet
  const highlightPattern = new RegExp(`(${query})`, "gi");
  snippet = snippet.replace(highlightPattern, "**$1**");

  return snippet.trim() + "...";
}
```

**Search Features**:

- Full-text search across title, description, tags
- Stop word removal (ignores common words)
- Relevance scoring (title > tags > description)
- Snippet generation with query highlighting
- Configurable result limit

**Output**: Search algorithm

---

### Subtask 2.3.3: Implement Route Handler

Create `/v1/contents/search` POST route.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { searchContents } from "./contents/search/utils";
import { HTTP_OK, HTTP_BAD_REQUEST } from "../constants";

// POST /v1/contents/search - Full-text search
v1.post("/contents/search", requireApiKey({ contents: ["search"] }), async (c) => {
  const userId = c.get("userId");
  const apiKeyId = c.get("apiKeyId");

  // Rate limit check
  const rateLimitResult = await c.env.runMutation(
    internal.betterAuth.mutations.checkRateLimit,
    {
      apiKeyId,
      resource: "contents",
      action: "search",
    }
  );

  if (!rateLimitResult.allowed) {
    return c.json(
      {
        error: "Rate limit exceeded",
        retryAfter: rateLimitResult.retryAfter,
      },
      { status: HTTP_TOO_MANY_REQUESTS }
    );
  }

  // Parse request body
  const body: SearchContentsRequest = await c.req.json();
  const startTime = Date.now();

  // Validate request
  if (!body.query || body.query.trim().length === 0) {
    return c.json(
      { error: "Query parameter is required" },
      { status: HTTP_BAD_REQUEST }
    );
  }

  if (body.limit && (body.limit < 1 || body.limit > 100)) {
    return c.json(
      { error: "Limit must be between 1 and 100" },
      { status: HTTP_BAD_REQUEST }
    );
  }

  // Perform search
  let results;
  try {
    results = await searchContents(body);
  } catch (error) {
    return c.json(
      { error: "Search failed", details: error.message },
      { status: 500 }
    );
  }

  const searchTime = Date.now() - startTime;

  // Log search query
  await c.env.runMutation(
    internal.contents.mutations.logContentAccess,
    {
      apiKeyId,
      contentSlug: `search:${body.query}`,
      action: "search",
      metadata: JSON.stringify({
        query: body.query,
        locale: body.locale,
        type: body.type,
      }),
    }
  );

  // Build response
  const response: SearchContentsResponse = {
    results,
    total: results.length,
    query: body.query,
    searchTime,
  };

  return c.json(response, { status: HTTP_OK });
});
```

**Features**:

- POST method (better for complex search queries)
- JSON body for flexible parameters
- Rate limiting per search action
- Search time measurement (performance monitoring)
- Query logging

**Output**: Functional route handler

---

### Subtask 2.3.4: Add Unit Tests

Test search functionality and edge cases.

**File to create**: `packages/backend/convex/routes/__tests__/contents-search.test.ts`

**Test Cases**:

```typescript
describe("POST /v1/contents/search", () => {
  describe("search functionality", () => {
    it("should return ranked results by relevance", async () => {
      const response = await api.v1.contents.search(
        { query: "algebra" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.results).toBeInstanceOf(Array);
      expect(response.results.length).toBeGreaterThan(0);
      expect(response.results[0].relevanceScore).toBeGreaterThan(
        response.results[1]?.relevanceScore ?? 0
      );
    });

    it("should generate snippet with highlighted query", async () => {
      const response = await api.v1.contents.search(
        { query: "democracy" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.results[0].snippet).toContain("**democracy**");
    });

    it("should filter by type", async () => {
      const response = await api.v1.contents.search(
        { query: "test", type: "articles" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.results.every((r) => r.type === "articles")).toBe(true);
    });
  });

  describe("edge cases", () => {
    it("should return empty results for no matches", async () => {
      const response = await api.v1.contents.search(
        { query: "xyz123nonexistent" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.results).toEqual([]);
      expect(response.total).toBe(0);
    });

    it("should limit results to max 100", async () => {
      const response = await api.v1.contents.search(
        { query: "test", limit: 100 },
        { apiKeyId: testApiKeyId }
      );

      expect(response.results.length).toBeLessThanOrEqual(100);
    });

    it("should reject empty query", async () => {
      const response = await api.v1.contents.search(
        { query: "" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.error).toBe("Query parameter is required");
      expect(response.status).toBe(400);
    });
  });

  describe("rate limiting", () => {
    it("should enforce rate limit", async () => {
      // Exhaust daily limit with searches
      for (let i = 0; i < 25; i++) {
        await api.v1.contents.search(
          { query: `test-${i}` },
          { apiKeyId: testApiKeyId }
        );
      }

      // Next search should fail
      const response = await api.v1.contents.search(
        { query: "test-26" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.error).toBe("Rate limit exceeded");
      expect(response.retryAfter).toBeGreaterThan(0);
    });
  });
});
```

**Coverage**:

- ‚úÖ Relevance ranking
- ‚úÖ Snippet generation with highlighting
- ‚úÖ Type filtering
- ‚úÖ Result limiting
- ‚úÖ Empty results handling
- ‚úÖ Invalid input validation
- ‚úÖ Rate limiting

**Output**: Comprehensive test suite

---

### Subtask 2.3.5: Add API Documentation

Document search endpoint for developers.

**File to create**: `docs/api/contents-search.md`

**Content**:

```markdown
# Search Contents

## Endpoint
`POST /v1/contents/search`

## Description
Performs full-text search across all content. Returns ranked results with relevance scores and content snippets.

## Authentication
Requires valid API key via `Authorization: Bearer <key>` header.

## Request Body

| Parameter | Type    | Required | Default | Max                                                      | Description               |
| --------- | ------- | -------- | ------- | -------------------------------------------------------- |
| `query`   | string  | Yes      | -       | Search query (keywords, phrases)                         |
| `locale`  | string  | No       | `en`    | Content locale (`en` or `id`)                            |
| `type`    | string  | No       | -       | Content type filter (`articles`, `subject`, `exercises`) |
| `limit`   | integer | No       | 20      | 100                                                      | Maximum results to return |

## Rate Limits

| Tier       | Daily Limit | Minute Limit |
| ---------- | ----------- | ------------ |
| Free       | 25          | N/A          |
| Pro        | 1,000       | 100          |
| Enterprise | Unlimited   | Unlimited    |

## Search Features

1. **Full-text search**: Searches title, description, tags
2. **Relevance scoring**: Results ranked by relevance (0.0 to 1.0)
3. **Snippet generation**: Shows context around match with highlighting
4. **Stop word removal**: Ignores common words (the, a, an, and, or, etc.)
5. **Keyword matching**: Supports multi-word queries

## Example Request

```bash
curl -X POST "https://api.nakafa.com/v1/contents/search" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "algebra equations",
    "locale": "en",
    "type": "subject",
    "limit": 10
  }'
```

## Example Response

```json
{
  "results": [
    {
      "slug": "en/subject/mathematics/algebra/linear-equations",
      "url": "https://nakafa.com/en/subject/mathematics/algebra/linear-equations",
      "locale": "en",
      "type": "subject",
      "title": "Understanding Linear Equations",
      "description": "A comprehensive guide to solving linear equations...",
      "snippet": "Linear equations are a fundamental concept in **algebra**...",
      "relevanceScore": 0.85,
      "metadata": {
        "tags": ["mathematics", "algebra", "equations"],
        "category": "mathematics",
        "grade": "10",
        "material": "algebra"
      }
    }
  ],
  "total": 1,
  "query": "algebra equations",
  "searchTime": 42
}
```

## Error Responses

### 400 Bad Request

```json
{
  "error": "Query parameter is required"
}
```

### 401 Unauthorized

```json
{
  "error": "Missing or invalid API key"
}
```

### 429 Rate Limit Exceeded

- Search time is returned for performance monitoring
- Relevance score ranges from 0.0 (not relevant) to 1.0 (perfect match)
- Snippets use `**` markers to highlight matched query
- Empty results array means no matches found
```

**Output**: Developer documentation

---

## üöÄ Next Steps
After completing this task:
1. **Next task**: Task 2.4 - Implement Tiered Rate Limiting
2. **Phase 2**: Continue building public API

## üîó Related Tasks
- Task 2.1: Create Content List Endpoint (alternative discovery method)
- Task 2.2: Create Content Get Endpoint (fetches specific items found via search)
- Task 2.4: Implement Tiered Rate Limiting (rate limit mutation used in this task)
- Task 4.1: Implement Velocity-Based Scraping Detection (uses search logs for patterns)

## ‚ö†Ô∏è Important Notes

### Search Algorithm
- **In-memory**: Currently searches all content in memory
- **Future**: Consider Convex vector search or external search service
- **Performance**: Search time is measured and returned

### DX Considerations
- **Snippets**: Highlighted matches improve search relevance perception
- **Relevance scores**: Help developers understand match quality
- **Multi-word queries**: Supported (splits and matches keywords)

### Rate Limiting
- Searches count toward daily/minute limits
- Free tier: 25 total requests/day (list + get + search)
- Pro tier: 100/min for all actions

### Future Enhancements
- Consider adding `fuzzy` search (typo tolerance)
- Consider adding `suggest` endpoint (autocomplete for queries)
- Consider adding `recent` endpoint (recent searches by user)
- Consider adding `trending` endpoint (popular content)
