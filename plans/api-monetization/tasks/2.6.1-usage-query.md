# Task 2.6.1: Usage Query

## Goal

Create query to fetch API usage statistics using Better Auth's built-in rate limiting fields.

## Context

**Better Auth Already Provides**:
- ✅ Usage tracking (`requestCount`, `remaining`, `lastRequest`)
- ✅ Rate limiting configuration (`rateLimitMax`, `rateLimitTimeWindow`, `refillInterval`)
- ✅ Refill mechanism (automatic counter management)

**We Need**:
- Query to fetch detailed usage statistics
- Calculate percentage used and reset times
- Format for API response

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

## PRD

```json
{
  "category": "functional",
  "description": "Query to fetch API usage statistics from Better Auth",
  "steps": [
    "Create getUsage query with v.object() validators",
    "Use Better Auth's built-in usage fields",
    "Calculate percentage and reset times",
    "Add tests"
  ],
  "passes": false
}
```

## Success

- [ ] Query created
- [ ] Returns usage data from Better Auth
- [ ] Calculates percentage used
- [ ] Tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 2.6.1.1: Create Query

**File**: `packages/backend/convex/betterAuth/queries/getUsage.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { query } from "../../_generated/server";
import { getUsageStats, getRateLimitPercentage, isRateLimitNearLimit } from "../../lib/usageHelpers";

export interface UsageStatsResponse {
  apiKeyId: string; // Better Auth uses string IDs
  name: string;
  subscriptionTier: "free" | "pro" | "enterprise";
  requestCount: number;
  remaining: number;
  lastRequest: number | undefined;
  rateLimitMax: number | undefined;
  rateLimitEnabled: boolean;
  tierDescription: string;
  percentageUsed: number | null;
  nearLimit: boolean;
  resetInfo: {
    nextRefill?: number; // Unix timestamp
    nextRefillSeconds?: number; // Seconds until next refill
    refillInterval?: number; // Refill period in ms
  };
}

export const getUsage = query({
  args: v.object({
    apiKeyId: v.string(), // Better Auth uses string IDs, not Convex IDs
  }),
  returns: v.object({
    apiKeyId: v.string(),
    name: v.string(),
    subscriptionTier: v.union(v.literal("free"), v.literal("pro"), v.literal("enterprise")),
    requestCount: v.number(),
    remaining: v.number(),
    lastRequest: v.optional(v.number()),
    rateLimitMax: v.optional(v.number()),
    rateLimitEnabled: v.boolean(),
    tierDescription: v.string(),
    percentageUsed: v.optional(v.number()),
    nearLimit: v.boolean(),
    resetInfo: v.object({
      nextRefill: v.optional(v.number()),
      nextRefillSeconds: v.optional(v.number()),
      refillInterval: v.optional(v.number()),
    }),
  }),
  handler: async (ctx, args) => {
    const { apiKeyId } = args;

    // Get API key from Better Auth's apikey table
    const apiKey = await ctx.db
      .query("apikey")
      .withIndex("key") // Better Auth creates this index
      .eq("_id", apiKeyId)
      .unique();

    if (!apiKey) {
      throw new Error("API key not found");
    }

    // Get usage stats from Better Auth's built-in fields
    const usage = getUsageStats(apiKey);
    const percentageUsed = getRateLimitPercentage(usage);
    const nearLimit = isRateLimitNearLimit(usage);

    // Calculate reset time based on rate limiting configuration
    const now = Date.now();
    let resetInfo: UsageStatsResponse["resetInfo"] = {
      nextRefill: undefined,
      nextRefillSeconds: undefined,
      refillInterval: apiKey.refillInterval ?? undefined,
    };

    if (apiKey.refillInterval && apiKey.lastRequest) {
      // Next refill = lastRequest + refillInterval
      const nextRefill = apiKey.lastRequest + apiKey.refillInterval;
      const secondsUntilRefill = Math.max(0, Math.ceil((nextRefill - now) / 1000));

      resetInfo = {
        nextRefill: nextRefill,
        nextRefillSeconds: secondsUntilRefill,
        refillInterval: apiKey.refillInterval,
      };
    } else if (apiKey.rateLimitTimeWindow) {
      // Fallback: use time window
      // This is approximate since Better Auth manages refills internally
      const timeWindowMs = apiKey.rateLimitTimeWindow;
      resetInfo = {
        nextRefill: now + timeWindowMs,
        nextRefillSeconds: Math.ceil(timeWindowMs / 1000),
        refillInterval: timeWindowMs,
      };
    }

    return {
      apiKeyId: apiKey._id,
      name: apiKey.name ?? "Unnamed Key",
      subscriptionTier: usage.subscriptionTier,
      requestCount: apiKey.requestCount ?? 0,
      remaining: apiKey.remaining ?? 0,
      lastRequest: apiKey.lastRequest,
      rateLimitMax: apiKey.rateLimitMax,
      rateLimitEnabled: apiKey.rateLimitEnabled ?? true,
      tierDescription: usage.tierDescription,
      percentageUsed: percentageUsed ?? undefined,
      nearLimit,
      resetInfo,
    };
  },
});
```

**Note**: This queries Better Auth's `apikey` table directly using the built-in usage tracking fields.

**Output**: Query created

---

### Subtask 2.6.1.2: Add Tests

**File**: `packages/backend/convex/betterAuth/__tests__/getUsage.test.ts`

**Tests**:

```typescript
describe("getUsage", () => {
  let testUserId;
  let freeApiKeyId;
  let proApiKeyId;

  beforeAll(async () => {
    testUserId = await createTestUser();

    const freeResult = await createApiKey({
      userId: testUserId,
      name: "Free Key",
      subscriptionTier: "free",
    });

    const proResult = await createApiKey({
      userId: testUserId,
      name: "Pro Key",
      subscriptionTier: "pro",
    });

    freeApiKeyId = freeResult.apiKeyId;
    proApiKeyId = proResult.apiKeyId;
  });

  it("should return usage data for free tier key", async () => {
    const usage = await getUsage({ apiKeyId: freeApiKeyId });

    expect(usage).toBeDefined();
    expect(usage.apiKeyId).toBe(freeApiKeyId);
    expect(usage.subscriptionTier).toBe("free");
    expect(usage.requestCount).toBeGreaterThanOrEqual(0);
    expect(usage.remaining).toBeGreaterThanOrEqual(0);
    expect(usage.tierDescription).toBe("25 requests/day");
  });

  it("should return usage data for pro tier key", async () => {
    const usage = await getUsage({ apiKeyId: proApiKeyId });

    expect(usage.subscriptionTier).toBe("pro");
    expect(usage.tierDescription).toBe("100 requests/minute, 1000/day");
    expect(usage.rateLimitMax).toBe(100);
    expect(usage.refillInterval).toBe(60000); // 1 minute
  });

  it("should calculate percentage used", async () => {
    // Simulate usage
    await ctx.runMutation(internal.betterAuth.mutations.incrementUsage, {
      apiKeyId: freeApiKeyId,
      amount: 10,
    });

    const usage = await getUsage({ apiKeyId: freeApiKeyId });

    expect(usage.percentageUsed).toBeGreaterThanOrEqual(0);
    expect(usage.percentageUsed).toBeLessThanOrEqual(100);
  });

  it("should detect near limit (> 80%)", async () => {
    // Set high usage
    await ctx.runMutation(internal.betterAuth.mutations.incrementUsage, {
      apiKeyId: freeApiKeyId,
      amount: 15, // Total: 25 out of 25 = 100%
    });

    const usage = await getUsage({ apiKeyId: freeApiKeyId });

    expect(usage.nearLimit).toBe(true);
    expect(usage.remaining).toBe(0);
  });

  it("should calculate reset time for free tier", async () => {
    const usage = await getUsage({ apiKeyId: freeApiKeyId });

    // Free tier: daily reset (24 hours)
    expect(usage.resetInfo.refillInterval).toBe(86400000);
    expect(usage.resetInfo.nextRefillSeconds).toBeGreaterThan(0);
    expect(usage.resetInfo.nextRefill).toBeGreaterThan(Date.now());
  });

  it("should calculate reset time for pro tier", async () => {
    const usage = await getUsage({ apiKeyId: proApiKeyId });

    // Pro tier: minute refill
    expect(usage.resetInfo.refillInterval).toBe(60000); // 1 minute
    expect(usage.resetInfo.nextRefillSeconds).toBeLessThanOrEqual(60);
  });

  it("should return null percentage for unlimited", async () => {
    const result = await createApiKey({
      userId: testUserId,
      name: "Enterprise Key",
      subscriptionTier: "enterprise",
    });

    const usage = await getUsage({ apiKeyId: result.apiKeyId });

    expect(usage.subscriptionTier).toBe("enterprise");
    expect(usage.rateLimitEnabled).toBe(false);
    expect(usage.percentageUsed).toBeUndefined();
    expect(usage.nearLimit).toBe(false);
  });

  it("should throw error for non-existent key", async () => {
    await expect(getUsage({ apiKeyId: "invalid-key-id" })).rejects.toThrow(
      "API key not found"
    );
  });

  it("should show last request time", async () => {
    await ctx.runMutation(internal.betterAuth.mutations.incrementUsage, {
      apiKeyId: freeApiKeyId,
      amount: 1,
    });

    const usage = await getUsage({ apiKeyId: freeApiKeyId });

    expect(usage.lastRequest).toBeDefined();
    expect(usage.lastRequest).toBeGreaterThan(Date.now() - 10000); // Within last 10 seconds
  });
});
```

**Output**: Tests

---

## Next Steps

After: Task 2.6.2 - Usage Route

## Related

- Task 2.4.1: Rate Limit Config (uses getUsageStats)
- Task 2.5.1: Create Key (initializes Better Auth counters)
- Task 2.6.2: Usage Route (uses this query)

## Progress

```
[YYYY-MM-DD HH:mm] Task 2.6.1 completed

Key decisions:
- Query Better Auth's apikey table directly
- Use built-in fields: requestCount, remaining, lastRequest
- Calculate percentage and reset times from Better Auth's configuration
- No need for separate apiKeyUsage table

Files changed:
- packages/backend/convex/betterAuth/queries/getUsage.ts
- packages/backend/convex/betterAuth/__tests__/getUsage.test.ts

Blockers: None
```
