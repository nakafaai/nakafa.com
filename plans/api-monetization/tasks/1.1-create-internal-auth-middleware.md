# Task 1.1: Create Internal Auth Middleware

## üéØ Goal

Create reusable middleware function to validate internal API key authentication for `/contents/*` endpoints using constant-time comparison to prevent timing attacks.

## üìç Context

This is **Phase 1.1** of Secure Internal Content Endpoints phase.

Internal content endpoints (`/contents/[locale]/{articles|subject|exercises|quran}/[...slug]/route.ts`) currently have **no authentication**. Anyone can call these endpoints and scrape all content.

This task creates middleware that:

- Validates `Authorization: Bearer <internal-key>` header
- Uses constant-time comparison to prevent timing attacks
- Returns 401 Unauthorized for invalid/missing keys
- Can be applied to all content routes consistently

## PRD

```json
{
  "category": "security",
  "description": "Internal API key authentication middleware for content endpoints",
  "steps": [
    "Create requireInternalApiKey() function with timing-safe comparison",
    "Add error handling for missing/invalid/incorrect keys",
    "Return proper 401 responses",
    "Add unit tests for all authentication scenarios"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] `requireInternalApiKey()` middleware function created
- [ ] Validates Authorization header format
- [ ] Uses constant-time comparison (timing-safe)
- [ ] Returns appropriate 401 response on failure
- [ ] Unit tests pass
- [ ] Used by all `/contents/*` routes

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck  
pnpm test
```

## üìù Subtasks

### Subtask 1.1.1: Create Internal Auth Utility File

Create core authentication utility with timing-safe key comparison.

**File to create**: `apps/api/lib/internal-auth.ts`

**Implementation**:

```typescript
import { NextResponse } from "next/server";

const INTERNAL_API_KEY = process.env.INTERNAL_CONTENT_API_KEY;

if (!INTERNAL_API_KEY) {
  throw new Error(
    "INTERNAL_CONTENT_API_KEY not set in environment. " +
    "Set in Vercel and Convex environment variables."
  );
}

export interface InternalAuthResult {
  success: boolean;
  error?: NextResponse;
}

/**
 * Validates internal API key using constant-time comparison.
 * Protects against timing attacks by ensuring comparison time
 * is constant regardless of where mismatch occurs.
 *
 * @param req - Incoming HTTP request
 * @returns Auth result object
 */
export async function requireInternalApiKey(
  req: Request
): Promise<InternalAuthResult> {
  const authHeader = req.headers.get("Authorization");

  // Check for missing header
  if (!authHeader) {
    return {
      success: false,
      error: NextResponse.json(
        { error: "Missing Authorization header" },
        { status: 401 }
      ),
    };
  }

  // Check for correct format (Bearer <key>)
  if (!authHeader.startsWith("Bearer ")) {
    return {
      success: false,
      error: NextResponse.json(
        {
          error: "Invalid Authorization format",
          message: "Expected format: Authorization: Bearer <key>",
        },
        { status: 401 }
      ),
    };
  }

  const providedKey = authHeader.slice(7); // Remove "Bearer " prefix

  // Check if internal key is configured
  if (!INTERNAL_API_KEY) {
    return {
      success: false,
      error: NextResponse.json(
        { error: "Internal API key not configured" },
        { status: 500 }
      ),
    };
  }

  // Constant-time comparison to prevent timing attacks
  const isValid = timingSafeEqual(providedKey, INTERNAL_API_KEY);

  if (!isValid) {
    return {
      success: false,
      error: NextResponse.json(
        { error: "Invalid internal API key" },
        { status: 401 }
      ),
    };
  }

  return { success: true };
}

/**
 * Constant-time string comparison.
 * Always compares full strings regardless of where mismatch occurs.
 * Prevents attackers from guessing keys byte-by-byte.
 */
function timingSafeEqual(a: string, b: string): boolean {
  // If lengths differ, they're definitely not equal
  if (a.length !== b.length) {
    return false;
  }

  // XOR all bytes together
  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }

  // If result is 0, all bytes matched
  return result === 0;
}
```

**Security Features**:

- Timing attack resistance: Constant-time comparison prevents attackers from measuring response time to guess keys
- Missing key protection: 500 error if internal key not configured (fail-safe)
- Format validation: Strict Bearer token format enforcement
- Error messages: Generic enough not to leak information (don't reveal expected length/pattern)

**Output**: Reusable `requireInternalApiKey()` function

---

### Subtask 1.1.2: Create Unit Tests

Test all authentication scenarios to ensure security.

**File to create**: `apps/api/lib/__tests__/internal-auth.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { requireInternalApiKey } from "../internal-auth";

describe("requireInternalApiKey", () => {
  describe("valid authentication", () => {
    it("should succeed with correct key", async () => {
      const mockReq = new Request("https://api.nakafa.com/contents/en/articles", {
        headers: {
          Authorization: `Bearer ${process.env.INTERNAL_CONTENT_API_KEY}`,
        },
      });

      const result = await requireInternalApiKey(mockReq);
      expect(result.success).toBe(true);
      expect(result.error).toBeUndefined();
    });
  });

  describe("invalid authentication", () => {
    it("should reject missing Authorization header", async () => {
      const mockReq = new Request("https://api.nakafa.com/contents/en/articles");

      const result = await requireInternalApiKey(mockReq);
      expect(result.success).toBe(false);
      expect(result.error?.status).toBe(401);
    });

    it("should reject malformed Authorization header", async () => {
      const mockReq = new Request("https://api.nakafa.com/contents/en/articles", {
        headers: {
          Authorization: "InvalidFormat",
        },
      });

      const result = await requireInternalApiKey(mockReq);
      expect(result.success).toBe(false);
      expect(result.error?.status).toBe(401);
    });

    it("should reject wrong format (no Bearer prefix)", async () => {
      const mockReq = new Request("https://api.nakafa.com/contents/en/articles", {
        headers: {
          Authorization: process.env.INTERNAL_CONTENT_API_KEY,
        },
      });

      const result = await requireInternalApiKey(mockReq);
      expect(result.success).toBe(false);
      expect(result.error?.status).toBe(401);
    });
  });

  describe("edge cases", () => {
    it("should return 500 if internal key not configured", async () => {
      const originalKey = process.env.INTERNAL_CONTENT_API_KEY;
      delete process.env.INTERNAL_CONTENT_API_KEY;

      const mockReq = new Request("https://api.nakafa.com/contents/en/articles", {
        headers: {
          Authorization: "Bearer test",
        },
      });

      const result = await requireInternalApiKey(mockReq);
      expect(result.success).toBe(false);
      expect(result.error?.status).toBe(500);

      process.env.INTERNAL_CONTENT_API_KEY = originalKey;
    });

    it("should use constant-time comparison", async () => {
      const result1 = timingSafeEqual("test", "test");
      const result2 = timingSafeEqual("test", "fail");

      expect(result1).toBe(true);
      expect(result2).toBe(false);
    });
  });
});
```

**Coverage**:

- Valid key acceptance
- Missing header rejection
- Invalid key rejection
- Format validation
- Missing internal key (500 error)
- Timing attack resistance

**Output**: Comprehensive test suite

---

### Subtask 1.1.3: Add Usage Documentation

Document how to use `requireInternalApiKey()` in route handlers.

**File to create**: `apps/api/lib/internal-auth.usage.md`

**Content**:

```markdown
# Internal Auth Middleware Usage

## Purpose

Protect internal `/contents/*` endpoints from unauthorized access.

## Installation

Already created in `apps/api/lib/internal-auth.ts`.

## Usage in Route Handlers

### Basic Usage

```typescript
import { requireInternalApiKey } from "@/lib/internal-auth";
import { NextResponse } from "next/server";

export async function GET(req: Request, { params }) {
  const authResult = await requireInternalApiKey(req);

  if (authResult.error) {
    return authResult.error;
  }

  const { locale, slug } = await params;
  return NextResponse.json(data);
}
```

### Example: Articles Route

```typescript
import { requireInternalApiKey } from "@/lib/internal-auth";
import { getContents } from "@repo/contents/_lib/content";

export async function GET(req: Request, { params }) {
  const authResult = await requireInternalApiKey(req);

  if (authResult.error) {
    return authResult.error;
  }

  const { locale, slug } = await params;
  const content = await getContents({
    locale,
    basePath: `articles/${slug.join("/")}`
  });

  return NextResponse.json(content);
}
```

## Security Notes

1. **Timing Attack Resistance**: Uses constant-time comparison
2. **Fail-Safe**: Returns 500 if internal key not configured
3. **Generic Errors**: Don't reveal information about key structure
4. **Bearer Token Only**: Only accepts `Authorization: Bearer <key>` format

## Testing

Run tests with:

```bash
pnpm --filter api test internal-auth
```

**Output**: Developer documentation

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 1.2 - Apply Internal Auth to Content Routes

## üîó Related Tasks

- Task 0.1: Internal API Key Storage (provides key to validate)
- Task 1.2: Apply Internal Auth to Content Routes (uses this middleware)
- Task 1.3: Update Internal Fetcher to Use Auth (uses this middleware pattern)

## ‚ö†Ô∏è Important Notes

### Security

- **Never log** the internal key value
- **Never commit** the key to git
- **Use environment variables** only
- **Rotate quarterly** per security best practices

### DX Considerations

- **Clear error messages**: Users know what's wrong (but not why)
- **Consistent interface**: Same function across all routes
- **Type safe**: TypeScript interfaces for all data

### Progress Tracking

After completing this task, update `plans/api-monetization/progress.txt`:

[YYYY-MM-DD HH:mm] Task 1.1.1 completed

Key decisions:

- Use timingSafeEqual for constant-time comparison
- Return NextResponse objects for consistency with Next.js
- Check Bearer format before key validation

Files changed:

- apps/api/lib/internal-auth.ts (created)
- apps/api/lib/**tests**/internal-auth.test.ts (created)
- apps/api/lib/internal-auth.usage.md (created)

Blockers/notes:

- Next: Task 1.2 requires this file
- Ready to proceed
