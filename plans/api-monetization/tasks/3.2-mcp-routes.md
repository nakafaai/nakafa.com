# Task 3.2: MCP Routes

## Goal

Route MCP tools to v1 contents API.

## Context

MCP tools currently use:
See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

- Internal endpoints
- Need to route to public API

## PRD
```json
{
  "category": "functional",
  "description": "Route MCP tools to v1 public API",
  "steps": [
    "Create MCP tool routes to v1",
    "Add API key per tool invocation",
    "Apply user subscription limits",
    "Add tests"
  ],
  "passes": false
}
```

## Success

- [ ] MCP routes created
- [ ] Tools routed to v1 API
- [ ] API keys managed per tool call
- [ ] Tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 3.2.1: Create MCP Routes

**File**: `packages/mcp/server/index.ts`

**Implementation**:

```typescript
import { listContents, getContent, searchContents } from "@repo/backend/api";

export function mcpRoutes(server: any, apiKey: string) {
  server.tool(
    "list_contents",
    "List all available content with optional filters",
    async () => {
      const result = await listContents(
        { type: "articles", limit: 10 },
        { apiKey }
      );

      return {
        content: JSON.stringify(result.contents),
      };
    }
  );

  server.tool(
    "get_content",
    "Get specific content by slug",
    async (input: { slug: string }) => {
      const result = await getContent(
        { slug },
        { apiKey }
      );

      return {
        content: JSON.stringify(result.content),
      };
    }
  );

  server.tool(
    "search_contents",
    "Search content by query",
    async (input: { query: string }) => {
      const result = await searchContents(
        { query, limit: 20 },
        { apiKey }
      );

      return {
        content: JSON.stringify(result.results),
      };
    }
  );
}
```

**Output**: MCP routes

---

### Subtask 3.2.2: Add API Key Management

**File**: `packages/mcp/server/index.ts`

**Changes**:

```typescript
interface MCPContext {
  apiKey: string;
  userId: string;
}

export function createMCPContext(token: string): Promise<MCPContext> {
  const user = await validateUserToken(token);

  if (!user.valid) {
    throw new Error("Invalid user token");
  }

  const apiKeyId = await getUserDefaultApiKey(user.userId!);

  return {
    apiKey: await getApiKey(apiKeyId),
    userId: user.userId!,
  };
}
```

**Output**: API key management

---

### Subtask 3.2.3: Add Tests

**File**: `packages/mcp/server/__tests__/routes.test.ts`

**Tests**:

```typescript
describe("MCP Routes", () => {
  it("should route list_contents to v1 API", async () => {
    const result = await listContents(
      { type: "articles", limit: 10 },
      { apiKey: testApiKey }
    );

    expect(result.contents).toBeInstanceOf(Array);
  });

  it("should route get_content to v1 API", async () => {
    const result = await getContent(
      { slug: "en/articles/politics" },
      { apiKey: testApiKey }
    );

    expect(result.content).toBeDefined();
  });

  it("should route search_contents to v1 API", async () => {
    const result = await searchContents(
      { query: "algebra", limit: 20 },
      { apiKey: testApiKey }
    );

    expect(result.results).toBeInstanceOf(Array);
  });
});
```

**Output**: Tests

---

## Next Steps

After: Task 3.3 - Subscription Limits

## Related

- Task 3.1: MCP Auth (used by these routes)
- Task 3.3: Subscription Limits (applied to these routes)

## Progress

```
[YYYY-MM-DD HH:mm] Task 3.2 completed

Key decisions:
- Reuse existing v1 API endpoints
- Manage API keys per MCP session
- Use same auth/rate limiting as public API

Files changed:
- packages/mcp/server/index.ts
- packages/mcp/server/__tests__/routes.test.ts

Blockers: None
```
