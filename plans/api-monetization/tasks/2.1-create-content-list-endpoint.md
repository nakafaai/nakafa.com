# Task 2.1: Create Content List Endpoint

## üéØ Goal

Create `/v1/contents` endpoint for listing content with filters, pagination, and API key authentication.

## üìç Context

This is **Phase 2.1** of Build Public Content API phase.

Developers need a way to discover available content before fetching specific items. This endpoint provides:

- Content discovery by type (articles, subjects, exercises)
- Filtering by category, grade, material
- Pagination for large result sets
- Rate limiting per API key tier

This is the **first public API endpoint** developers will interact with.

## üé¨ Success Criteria

- [ ] `/v1/contents` endpoint created
- [ ] Requires API key authentication
- [ ] Supports query params: `locale`, `type`, `category`, `grade`, `material`, `page`, `limit`
- [ ] Returns metadata only (no full content)
- [ ] Rate limited per API key tier
- [ ] Pagination works correctly
- [ ] Returns proper HTTP codes (200, 401, 429)
- [ ] Usage logged to `contentAccessLog`

## üìù Subtasks

### Subtask 2.1.1: Define Request/Response Schemas

Create TypeScript interfaces for type safety.

**File to create**: `packages/backend/convex/routes/v1/contents/list/types.ts`

**Implementation**:

```typescript
// Request schema
export interface ListContentsQuery {
  locale?: "en" | "id";
  type?: "articles" | "subject" | "exercises";
  category?: string;
  grade?: string;
  material?: string;
  page?: number;
  limit?: number;
}

// Response schema
export interface ListContentsResponse {
  contents: ContentMetadata[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNext: boolean;
    hasPrevious: boolean;
  };
}

export interface ContentMetadata {
  slug: string;
  url: string;
  locale: string;
  type: "articles" | "subject" | "exercises";
  title: string;
  description: string;
  tags: string[];
  category?: string;
  grade?: string;
  material?: string;
  createdAt: number;
  updatedAt: number;
}
```

**Why Metadata Only?**

- Reduces API response size (faster)
- Prevents bulk scraping of full content
- Developers can discover content, then fetch specific items
- Fits "good DX" requirement (fast discovery)

**Output**: Type-safe request/response interfaces

---

### Subtask 2.1.2: Implement Route Handler

Create the `/v1/contents` GET route with auth and rate limiting.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { requireApiKey } from "../middleware/auth";
import type { ListContentsQuery } from "./contents/list/types";
import { getContents } from "@repo/contents/_lib/content";
import { HTTP_OK, HTTP_UNAUTHORIZED, HTTP_TOO_MANY_REQUESTS } from "../constants";

// GET /v1/contents - List contents with filters
v1.get("/contents", requireApiKey(), async (c) => {
  const userId = c.get("userId");
  const apiKeyId = c.get("apiKeyId");

  // Parse query parameters
  const query: ListContentsQuery = {
    locale: c.req.query("locale") as "en" | "id" | undefined,
    type: c.req.query("type") as "articles" | "subject" | "exercises" | undefined,
    category: c.req.query("category") as string | undefined,
    grade: c.req.query("grade") as string | undefined,
    material: c.req.query("material") as string | undefined,
    page: c.req.query("page") ? Number.parseInt(c.req.query("page")!) : 1,
    limit: c.req.query("limit") ? Number.parseInt(c.req.query("limit")!) : 20,
  };

  // Rate limit check
  const rateLimitResult = await c.env.runMutation(
    internal.betterAuth.mutations.checkRateLimit,
    {
      apiKeyId,
      resource: "contents",
      action: "list",
    }
  );

  if (!rateLimitResult.allowed) {
    return c.json(
      {
        error: "Rate limit exceeded",
        retryAfter: rateLimitResult.retryAfter,
      },
      { status: HTTP_TOO_MANY_REQUESTS }
    );
  }

  // Fetch content list
  let contentList;
  try {
    // Build slug from filters
    const basePath = buildContentSlug({
      locale: query.locale || "en",
      filters: {
        type: query.type,
        category: query.category,
        grade: query.grade,
        material: query.material,
      },
    });

    // Fetch contents
    const contents = await getContents({
      locale: query.locale || "en",
      basePath,
      includeMDX: false, // Only metadata
    });

    // Apply pagination
    const startIndex = (query.page - 1) * query.limit;
    const endIndex = startIndex + query.limit;
    contentList = contents.slice(startIndex, endIndex);
  } catch (error) {
    return c.json(
      { error: "Failed to fetch contents" },
      { status: 500 }
    );
  }

  // Build response with pagination metadata
  const response = {
    contents: contentList.map((item) => ({
      slug: item.slug,
      url: item.url,
      locale: item.locale,
      type: detectContentType(item.slug),
      title: item.metadata.title,
      description: item.metadata.description,
      tags: item.metadata.tags || [],
      category: extractCategory(item.slug),
      grade: extractGrade(item.slug),
      material: extractMaterial(item.slug),
      createdAt: item.metadata.date || Date.now(),
      updatedAt: item.metadata.updatedAt || Date.now(),
    })),
    pagination: {
      page: query.page,
      limit: query.limit,
      total: contents.length,
      totalPages: Math.ceil(contents.length / query.limit),
      hasNext: query.page < Math.ceil(contents.length / query.limit),
      hasPrevious: query.page > 1,
    },
  };

  // Log access
  await c.env.runMutation(
    internal.contents.mutations.logAccess,
    {
      apiKeyId,
      resource: "contents",
      action: "list",
      metadata: JSON.stringify(query),
    }
  );

  return c.json(response, { status: HTTP_OK });
});
```

**Helper Functions** (create in separate file if needed):

```typescript
function buildContentSlug(params: {
  locale: string;
  filters: { type?: string; category?: string; grade?: string; material?: string };
}): string {
  const { locale, filters } = params;
  const parts = [locale];

  if (filters.type) {
    parts.push(filters.type);
  }
  if (filters.category) {
    parts.push(filters.category);
  }
  if (filters.grade) {
    parts.push(filters.grade);
  }
  if (filters.material) {
    parts.push(filters.material);
  }

  return parts.join("/");
}

function detectContentType(slug: string): "articles" | "subject" | "exercises" {
  if (slug.startsWith("articles")) return "articles";
  if (slug.startsWith("subject")) return "subject";
  if (slug.startsWith("exercises")) return "exercises";
  return "subject"; // Default
}
```

**Output**: Functional route handler with auth, rate limiting, pagination

---

### Subtask 2.1.3: Add Content Access Logging

Track API key usage for analytics and rate limiting.

**File to create**: `packages/backend/convex/contents/mutations.ts` (add new mutation)

**Implementation**:

```typescript
import { v } from "convex/values";
import { mutation } from "../_generated/server";

export const logContentAccess = mutation({
  args: {
    apiKeyId: v.id("apikey"),
    contentSlug: v.string(),
    action: v.string(), // "list", "get", "search"
    metadata: v.optional(v.string()), // Query params, filters, etc.
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("contentAccessLog", {
      apiKeyId: args.apiKeyId,
      contentSlug: args.contentSlug,
      action: args.action,
      metadata: args.metadata,
      accessedAt: Date.now(),
      // requestSignature and ipAddress will be added from middleware context
    });

    // Decrement usage counters (handled in rate limit mutation)
    return { success: true };
  },
});
```

**Integration in Route**:

```typescript
await c.env.runMutation(internal.contents.mutations.logContentAccess, {
  apiKeyId,
  contentSlug: "list", // or specific slug
  action: "list",
  metadata: JSON.stringify(query),
});
```

**Output**: Usage tracking enabled

---

### Subtask 2.1.4: Add Rate Limit Check Mutation

Create mutation to check and enforce rate limits before processing request.

**File to create**: `packages/backend/convex/betterAuth/mutations.ts` (add new mutation)

**Implementation**:

```typescript
export const checkRateLimit = mutation({
  args: {
    apiKeyId: v.id("apikey"),
    resource: v.string(), // "contents", "search", etc.
    action: v.string(), // "list", "get", "search"
  },
  returns: v.object({
    allowed: v.boolean(),
    retryAfter: v.optional(v.number()),
    remaining: v.optional(v.number()),
  }),
  handler: async (ctx, args) => {
    const apiKey = await ctx.db.get("apikey", args.apiKeyId);

    if (!apiKey) {
      return { allowed: false, retryAfter: 0 };
    }

    // Get or create usage record
    let usage = await ctx.db
      .query("apiKeyUsage")
      .withIndex("apiKeyId")
      .eq("apiKeyId", args.apiKeyId)
      .unique();

    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    const oneMinuteMs = 60 * 1000;
    const tomorrow = now + oneDayMs;
    const nextMinute = now + oneMinuteMs;

    // Get tier limits
    const tier = apiKey.subscriptionTier || "free";
    const limits = TIER_LIMITS[tier];

    // Initialize or update usage
    if (!usage) {
      // First request for this API key
      usage = {
        apiKeyId: args.apiKeyId,
        requestsToday: 1,
        requestsThisMinute: 1,
        lastRequestTime: now,
        dailyResetTime: tomorrow,
        minuteResetTime: nextMinute,
      };
      await ctx.db.insert("apiKeyUsage", usage);
    } else {
      // Check resets
      const needsDailyReset = now > usage.dailyResetTime;
      const needsMinuteReset = now > usage.minuteResetTime;

      const requestsToday = needsDailyReset ? 1 : usage.requestsToday + 1;
      const requestsThisMinute = needsMinuteReset ? 1 : usage.requestsThisMinute + 1;

      // Check limits
      const dailyExceeded =
        limits.rateLimitDaily && requestsToday > limits.rateLimitDaily;
      const minuteExceeded =
        limits.rateLimitMinute && requestsThisMinute > limits.rateLimitMinute;

      if (dailyExceeded || minuteExceeded) {
        // Calculate retry after
        const retryAfter = dailyExceeded
          ? Math.max(0, usage.dailyResetTime - now)
          : Math.max(0, usage.minuteResetTime - now);

        return {
          allowed: false,
          retryAfter: Math.ceil(retryAfter / 1000), // Convert to seconds
          remaining: 0,
        };
      }

      // Update usage
      await ctx.db.patch("apiKeyUsage", usage._id, {
        requestsToday,
        requestsThisMinute,
        lastRequestTime: now,
        dailyResetTime: needsDailyReset ? tomorrow : usage.dailyResetTime,
        minuteResetTime: needsMinuteReset ? nextMinute : usage.minuteResetTime,
      });

      return {
        allowed: true,
        remaining:
          limits.rateLimitDaily && limits.rateLimitDaily
            ? limits.rateLimitDaily - requestsToday
            : null,
      };
    }
  },
});

const TIER_LIMITS = {
  free: {
    rateLimitDaily: 25,
    rateLimitMinute: null,
  },
  pro: {
    rateLimitDaily: 1000,
    rateLimitMinute: 100,
  },
  enterprise: {
    rateLimitDaily: null, // Unlimited
    rateLimitMinute: null, // Unlimited
  },
};
```

**Integration in Route**:

```typescript
const rateLimitResult = await c.env.runMutation(
  internal.betterAuth.mutations.checkRateLimit,
  {
    apiKeyId,
    resource: "contents",
    action: "list",
  }
);

if (!rateLimitResult.allowed) {
  return c.json(
    {
      error: "Rate limit exceeded",
      retryAfter: rateLimitResult.retryAfter,
    },
    { status: 429 }
  );
}
```

**Output**: Tiered rate limiting enforced

---

### Subtask 2.1.5: Add Unit Tests

Test all scenarios for the content list endpoint.

**File to create**: `packages/backend/convex/routes/__tests__/contents-list.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect, beforeAll } from "vitest";
import { api } from "../../_generated/api";

describe("GET /v1/contents", () => {
  let testUserId: Id<"users">;
  let testApiKeyId: Id<"apikey">;

  beforeAll(async () => {
    // Create test user and API key
    testUserId = await api.users.mutations.createTestUser({});
    testApiKeyId = await api.betterAuth.mutations.createApiKey({
      userId: testUserId,
      subscriptionTier: "free",
    });
  });

  describe("authentication", () => {
    it("should require API key", async () => {
      const response = await api.v1.contents.list({});

      expect(response).toBeDefined();
      // Should fail without auth (handled by requireApiKey middleware)
    });

    it("should accept valid API key", async () => {
      const response = await api.v1.contents.list({}, { apiKeyId: testApiKeyId });
      expect(response.contents).toBeInstanceOf(Array);
    });
  });

  describe("rate limiting", () => {
    it("should enforce free tier limit (25/day)", async () => {
      // Make 25 requests (should all succeed)
      for (let i = 0; i < 25; i++) {
        await api.v1.contents.list({}, { apiKeyId: testApiKeyId });
      }

      // 26th request should fail
      const response = await api.v1.contents.list({}, { apiKeyId: testApiKeyId });
      expect(response.error).toBe("Rate limit exceeded");
      expect(response.retryAfter).toBeGreaterThan(0);
    });

    it("should enforce pro tier limit (100/min)", async () => {
      // Create Pro API key
      const proKeyId = await api.betterAuth.mutations.createApiKey({
        userId: testUserId,
        subscriptionTier: "pro",
      });

      // Make 100 requests in 1 minute (should succeed)
      for (let i = 0; i < 100; i++) {
        await api.v1.contents.list({}, { apiKeyId: proKeyId });
      }

      // 101st request should fail
      const response = await api.v1.contents.list({}, { apiKeyId: proKeyId });
      expect(response.error).toBe("Rate limit exceeded");
    });
  });

  describe("filtering", () => {
    it("should filter by type", async () => {
      const response = await api.v1.contents.list(
        { type: "articles" },
        { apiKeyId: testApiKeyId }
      );
      expect(response.contents.every((c) => c.type === "articles")).toBe(true);
    });

    it("should filter by locale", async () => {
      const response = await api.v1.contents.list(
        { locale: "id" },
        { apiKeyId: testApiKeyId }
      );
      expect(response.contents.every((c) => c.locale === "id")).toBe(true);
    });
  });

  describe("pagination", () => {
    it("should paginate results", async () => {
      const page1 = await api.v1.contents.list(
        { page: 1, limit: 10 },
        { apiKeyId: testApiKeyId }
      );

      const page2 = await api.v1.contents.list(
        { page: 2, limit: 10 },
        { apiKeyId: testApiKeyId }
      );

      expect(page1.contents).not.toEqual(page2.contents);
      expect(page1.pagination.page).toBe(1);
      expect(page2.pagination.page).toBe(2);
      expect(page1.pagination.hasNext).toBe(true);
      expect(page1.pagination.hasPrevious).toBe(false);
      expect(page2.pagination.hasPrevious).toBe(true);
    });
  });
});
```

**Coverage**:

- ‚úÖ Authentication required
- ‚úÖ Rate limiting by tier
- ‚úÖ Filtering by type, locale, category
- ‚úÖ Pagination works correctly
- ‚úÖ Error responses (401, 429)
- ‚úÖ Metadata only (no full content)

**Output**: Comprehensive test suite

---

### Subtask 2.1.6: Add API Documentation

Document the `/v1/contents` endpoint for developers.

**File to create**: `docs/api/contents-list.md`

**Content**:

```markdown
# List Contents

## Endpoint
`GET /v1/contents`

## Description
Retrieves a paginated list of content items with optional filters. Returns **metadata only**, not full content.

## Authentication
Requires valid API key via `Authorization: Bearer <key>` header.

## Query Parameters

| Parameter  | Type    | Required | Default                                                         | Description |
| ---------- | ------- | -------- | --------------------------------------------------------------- |
| `locale`   | string  | No       | `en` or `id`. Content locale. Default: `en`                     |
| `type`     | string  | No       | Content type filter. Values: `articles`, `subject`, `exercises` |
| `category` | string  | No       | Category filter (e.g., `politics`, `mathematics`)               |
| `grade`    | string  | No       | Grade filter (e.g., `10`, `11`, `12`)                           |
| `material` | string  | No       | Material filter (e.g., `algebra`, `geometry`)                   |
| `page`     | integer | No       | Page number (1-indexed). Default: `1`                           |
| `limit`    | integer | No       | Items per page. Default: `20`, Max: `100`                       |

## Rate Limits

| Tier       | Daily Limit | Minute Limit |
| ---------- | ----------- | ------------ |
| Free       | 25          | N/A          |
| Pro        | 1,000       | 100          |
| Enterprise | Unlimited   | Unlimited    |

## Example Request

```bash
curl "https://api.nakafa.com/v1/contents?type=articles&locale=en&page=1&limit=20" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

## Example Response

```json
{
  "contents": [
    {
      "slug": "articles/politics/democracy",
      "url": "https://nakafa.com/en/articles/politics/democracy",
      "locale": "en",
      "type": "articles",
      "title": "Understanding Democracy",
      "description": "A comprehensive guide to democratic principles...",
      "tags": ["politics", "governance"],
      "category": "politics",
      "grade": null,
      "material": null,
      "createdAt": 1705228800000,
      "updatedAt": 1705228800000
    }
  ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 150,
    "totalPages": 8,
    "hasNext": true,
    "hasPrevious": false
  }
}
```

## Error Responses

### 401 Unauthorized

```json
{
  "error": "Missing or invalid API key"
}
```

### 429 Rate Limit Exceeded

```json
{
  "error": "Rate limit exceeded",
  "retryAfter": 3600
}
```

**Output**: Developer documentation

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 2.2 - Create Content Get Endpoint
2. **Phase 2**: Continue building public API

## üîó Related Tasks

- Task 2.2: Create Content Get Endpoint (fetches specific content by slug)
- Task 2.4: Implement Tiered Rate Limiting (rate limit mutation used in this task)
- Task 4.1: Implement Velocity-Based Scraping Detection (uses `contentAccessLog`)
- Task 4.2: Implement IP-Based Rate Limiting (uses `apiKeyUsage`)

## ‚ö†Ô∏è Important Notes

### DX Considerations

- **Fast discovery**: Metadata-only responses are small and fast
- **Intuitive pagination**: `page` parameter is 1-indexed (natural for humans)
- **Clear filtering**: Query params match content structure (type, category, grade, material)

### Rate Limiting

- **Free tier**: 25/day is for indie developers (as requested)
- **Pro tier**: 100/min prevents API abuse while allowing flexibility
- **Enterprise**: Unlimited but monitored via `contentAccessLog`

### Security

- All access logged for scraping detection
- Rate limits prevent bulk downloads
- API key validation happens before any content access

### Future Enhancements

- Consider adding `search` parameter for fuzzy search
- Consider adding `sort` parameter (date, popularity, alphabetical)
- Consider adding `fields` parameter (request only specific metadata fields)
