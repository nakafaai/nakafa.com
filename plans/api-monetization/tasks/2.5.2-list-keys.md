# Task 2.5.2: List Keys Query

## Goal

Create query to list user's API keys with usage statistics using Better Auth's built-in fields.

## Context

**Better Auth Already Provides**:
- ✅ API key storage (`apikey` table)
- ✅ Usage tracking (`requestCount`, `remaining`, `lastRequest`)
- ✅ Rate limiting configuration (`rateLimitMax`, `rateLimitEnabled`)
- ✅ Metadata field (for `subscriptionTier`)

**We Need**:
- Query to fetch API keys for a user
- Enrich with usage statistics from Better Auth's fields
- Calculate percentage used and time to reset

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

## PRD

```json
{
  "category": "functional",
  "description": "Query to list user API keys with Better Auth usage data",
  "steps": [
    "Create listApiKeys query with v.object() validators",
    "Use Better Auth's .withIndex() for efficient lookup",
    "Enrich with usage statistics from built-in fields",
    "Add tests"
  ],
  "passes": false
}
```

## Success

- [ ] Query created
- [ ] Usage data from Better Auth included
- [ ] Pagination works
- [ ] Tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 2.5.2.1: Create Query

**File**: `packages/backend/convex/betterAuth/queries/listApiKeys.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { query } from "../../_generated/server";
import { getUsageStats, getRateLimitPercentage, isRateLimitNearLimit } from "../../lib/usageHelpers";

export interface ListApiKeysResult {
  apiKeys: Array<{
    id: string; // Better Auth uses string IDs
    name: string;
    subscriptionTier: "free" | "pro" | "enterprise";
    permissions: string[];
    enabled: boolean;
    createdAt: number;
    lastRequest: number | undefined;
    requestCount: number;
    remaining: number;
    rateLimitMax: number | undefined;
    rateLimitEnabled: boolean;
    tierDescription: string;
    percentageUsed: number | null;
    nearLimit: boolean;
    lastFourChars: string; // Security: only show last 4 chars of key
  }>;
  total: number;
}

export const listApiKeys = query({
  args: v.object({
    userId: v.id("users"),
    limit: v.optional(v.number()),
    cursor: v.optional(v.string()),
  }),
  returns: v.object({
    apiKeys: v.array(
      v.object({
        id: v.string(),
        name: v.string(),
        subscriptionTier: v.union(v.literal("free"), v.literal("pro"), v.literal("enterprise")),
        permissions: v.array(v.string()),
        enabled: v.boolean(),
        createdAt: v.number(),
        lastRequest: v.optional(v.number()),
        requestCount: v.number(),
        remaining: v.number(),
        rateLimitMax: v.optional(v.number()),
        rateLimitEnabled: v.boolean(),
        tierDescription: v.string(),
        percentageUsed: v.optional(v.number()),
        nearLimit: v.boolean(),
        lastFourChars: v.string(),
      })
    ),
    total: v.number(),
    nextCursor: v.optional(v.string()),
  }),
  handler: async (ctx, args) => {
    const { userId, limit = 10 } = args;

    // Get the app user first
    const appUser = await ctx.db.get("users", userId);
    if (!appUser) {
      return { apiKeys: [], total: 0 };
    }

    // Get Better Auth user by authId
    const authUser = await ctx.runQuery(
      internal.betterAuth.queries.getUserByAuthId,
      { authId: appUser.authId }
    );

    if (!authUser) {
      return { apiKeys: [], total: 0 };
    }

    // Query Better Auth's apikey table (note: it uses string user IDs)
    const apiKeys = await ctx.db
      .query("apikey")
      .withIndex("userId")
      .eq("userId", authUser._id)
      .order("desc")
      .take(limit)
      .collect();

    // Enrich with usage statistics
    const enrichedKeys = apiKeys.map((key) => {
      const usage = getUsageStats(key);
      const percentageUsed = getRateLimitPercentage(usage);
      const nearLimit = isRateLimitNearLimit(usage);

      // Parse permissions from string
      const permissions = key.permissions
        ? key.permissions.split(",").map((p) => p.trim())
        : [];

      // Only show last 4 characters of key for security
      const lastFourChars = key.key.slice(-4);

      return {
        id: key._id, // Better Auth uses string IDs
        name: key.name ?? "Unnamed Key",
        subscriptionTier: usage.subscriptionTier,
        permissions,
        enabled: key.enabled ?? true,
        createdAt: key.createdAt,
        lastRequest: key.lastRequest,
        requestCount: key.requestCount ?? 0,
        remaining: key.remaining ?? 0,
        rateLimitMax: key.rateLimitMax,
        rateLimitEnabled: key.rateLimitEnabled ?? true,
        tierDescription: usage.tierDescription,
        percentageUsed,
        nearLimit,
        lastFourChars,
      };
    });

    return {
      apiKeys: enrichedKeys,
      total: apiKeys.length,
      nextCursor: apiKeys.length >= limit ? apiKeys[apiKeys.length - 1]._id : undefined,
    };
  },
});
```

**Output**: Query created

---

### Subtask 2.5.2.2: Add Tests

**File**: `packages/backend/convex/betterAuth/__tests__/listApiKeys.test.ts`

**Tests**:

```typescript
describe("listApiKeys", () => {
  let testUserId;
  let testApiKeyId1;
  let testApiKeyId2;

  beforeAll(async () => {
    testUserId = await createTestUser();

    // Create test API keys
    const result1 = await createApiKey({
      userId: testUserId,
      name: "Free Key",
      subscriptionTier: "free",
    });

    const result2 = await createApiKey({
      userId: testUserId,
      name: "Pro Key",
      subscriptionTier: "pro",
    });

    testApiKeyId1 = result1.apiKeyId;
    testApiKeyId2 = result2.apiKeyId;
  });

  it("should list user's API keys", async () => {
    const result = await listApiKeys({
      userId: testUserId,
    });

    expect(result.apiKeys).toBeInstanceOf(Array);
    expect(result.total).toBeGreaterThan(0);
    expect(result.apiKeys.length).toBe(2);
  });

  it("should include usage data from Better Auth", async () => {
    const result = await listApiKeys({
      userId: testUserId,
    });

    const firstKey = result.apiKeys[0];
    expect(firstKey.requestCount).toBeDefined();
    expect(firstKey.remaining).toBeDefined();
    expect(firstKey.rateLimitMax).toBeDefined();
  });

  it("should calculate percentage used", async () => {
    const result = await listApiKeys({
      userId: testUserId,
    });

    const freeKey = result.apiKeys.find((k) => k.subscriptionTier === "free");
    expect(freeKey?.percentageUsed).toBeGreaterThanOrEqual(0);
    expect(freeKey?.percentageUsed).toBeLessThanOrEqual(100);
  });

  it("should detect near limit (> 80%)", async () => {
    // Simulate high usage
    await ctx.runMutation(internal.betterAuth.mutations.incrementUsage, {
      apiKeyId: testApiKeyId1,
      amount: 20,
    });

    const result = await listApiKeys({
      userId: testUserId,
    });

    const freeKey = result.apiKeys.find((k) => k.id === testApiKeyId1);
    expect(freeKey?.nearLimit).toBe(true);
  });

  it("should show tier description", async () => {
    const result = await listApiKeys({
      userId: testUserId,
    });

    const freeKey = result.apiKeys.find((k) => k.subscriptionTier === "free");
    const proKey = result.apiKeys.find((k) => k.subscriptionTier === "pro");

    expect(freeKey?.tierDescription).toBe("25 requests/day");
    expect(proKey?.tierDescription).toBe("100 requests/minute, 1000/day");
  });

  it("should only show last 4 characters of key", async () => {
    const result = await listApiKeys({
      userId: testUserId,
    });

    const firstKey = result.apiKeys[0];
    expect(firstKey.lastFourChars).toHaveLength(4);
    expect(firstKey.lastFourChars).not.toContain("nak_pk_");
  });

  it("should parse permissions", async () => {
    const result = await listApiKeys({
      userId: testUserId,
    });

    const firstKey = result.apiKeys[0];
    expect(Array.isArray(firstKey.permissions)).toBe(true);
    expect(firstKey.permissions).toContain("contents");
  });

  it("should respect limit parameter", async () => {
    // Create more keys
    for (let i = 2; i < 6; i++) {
      await createApiKey({
        userId: testUserId,
        name: `Key ${i}`,
        subscriptionTier: "free",
      });
    }

    const result = await listApiKeys({
      userId: testUserId,
      limit: 3,
    });

    expect(result.apiKeys.length).toBe(3);
    expect(result.nextCursor).toBeDefined();
  });

  it("should return empty array for user with no keys", async () => {
    const newUser = await createTestUser();
    const result = await listApiKeys({
      userId: newUser._id,
    });

    expect(result.apiKeys).toEqual([]);
    expect(result.total).toBe(0);
  });
});
```

**Helper for tests** (if needed):

```typescript
// In a test helpers file
async function incrementUsage(apiKeyId: string, amount: number) {
  const apiKey = await ctx.db.get("apikey", apiKeyId);
  if (!apiKey) throw new Error("API key not found");

  await ctx.db.patch("apikey", apiKeyId, {
    requestCount: (apiKey.requestCount ?? 0) + amount,
    remaining: Math.max(0, (apiKey.remaining ?? 0) - amount),
    lastRequest: Date.now(),
  });
}
```

**Output**: Tests

---

## Next Steps

After: Task 2.5.3 - Delete Key Mutation

## Related

- Task 2.5.1: Create Key (used by this query)
- Task 2.5.3: Delete Key (complementary)
- Task 2.4.1: Rate Limit Config (uses getUsageStats)

## Progress

```
[YYYY-MM-DD HH:mm] Task 2.5.2 completed

Key decisions:
- Query Better Auth's apikey table directly
- Enrich with usage stats from built-in fields
- Calculate percentage used for UI display
- Only show last 4 chars of key for security
- Parse permissions from string field

Files changed:
- packages/backend/convex/betterAuth/queries/listApiKeys.ts
- packages/backend/convex/betterAuth/__tests__/listApiKeys.test.ts

Blockers: None
```
