# Task 2.1.3: Implement Content List Route Handler

## üéØ Goal

Create `/v1/contents` GET route handler with auth, rate limiting, pagination, and content fetching using Convex best practices.

## üìç Context

This is **Phase 2.1.3** of Build Public Content API phase.

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

Content list endpoint needs route handler that:

- Validates API key via middleware
- Checks rate limits before processing
- Filters content by type, category, grade, material
- Applies pagination to results
- Logs all access for analytics
- Returns proper HTTP codes (200, 401, 429)

## PRD

```json
{
  "category": "functional",
  "description": "Create GET /v1/contents route handler with auth, rate limiting, and pagination",
  "steps": [
    "Validate API key via requireApiKey middleware",
    "Check rate limit via checkRateLimit mutation",
    "Parse query parameters from request",
    "Build content slug using helper function",
    "Fetch content metadata from internal source",
    "Apply pagination logic",
    "Log access to contentAccessLog table",
    "Return proper HTTP response with metadata"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Route handler created with proper HTTP methods
- [ ] API key authentication integrated
- [ ] Rate limiting enforced before content fetch
- [ ] Pagination applied correctly
- [ ] Access logged to contentAccessLog
- [ ] Returns correct response format
- [ ] Unit tests pass

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck  
pnpm test
```

## üìù Subtasks

### Subtask 2.1.3.1: Create Route Handler with Auth

Create route handler that integrates auth, rate limiting, and content fetching.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { requireApiKey } from "../middleware/auth";
import { requireRateLimit } from "../middleware/rate-limit";
import { buildContentSlug, detectContentType } from "./contents/list/types";
import { calculatePagination } from "./contents/list/pagination";
import { HTTP_OK, HTTP_UNAUTHORIZED, HTTP_TOO_MANY_REQUESTS } from "../constants";

// GET /v1/contents - List contents with filters
v1.get("/contents", requireApiKey(), requireRateLimit("contents", "list"), async (c) => {
  const userId = c.get("userId");
  const apiKeyId = c.get("apiKeyId");

  const rateLimitRemaining = c.get("rateLimitRemaining");

  // Parse query parameters
  const locale = c.req.query("locale") as "en" | "id" | undefined;
  const type = c.req.query("type") as "articles" | "subject" | "exercises" | undefined;
  const category = c.req.query("category") as string | undefined;
  const grade = c.req.query("grade") as string | undefined;
  const material = c.req.query("material") as string | undefined;
  const page = c.req.query("page") ? Number.parseInt(c.req.query("page")!) : 1;
  const limit = c.req.query("limit") ? Number.parseInt(c.req.query("limit")!) : 20;

  // Validate page and limit
  if (page < 1) {
    return c.json(
      { error: "Page must be at least 1" },
      { status: 400 }
    );
  }

  if (limit < 1 || limit > 100) {
    return c.json(
      { error: "Limit must be between 1 and 100" },
      { status: 400 }
    );
  }

  // Build slug from filters
  const basePath = buildContentSlug({
    locale: locale || "en",
    filters: {
      type,
      category,
      grade,
      material,
    },
  });

  // Fetch content from internal source
  let contentList;
  try {
    const allContents = await c.env.runAction(
      internal.contents.actions.fetchContents,
      { locale: locale || "en", basePath, includeMDX: false }
    );

    // Apply pagination
    const startIndex = (page - 1) * limit;
    const endIndex = startIndex + limit;
    contentList = allContents.slice(startIndex, endIndex);
  } catch (error) {
    return c.json(
      { error: "Failed to fetch contents" },
      { status: 500 }
    );
  }

  // Map to metadata format
  const contents = contentList.map((item) => ({
    slug: item.slug,
    url: item.url,
    locale: item.locale,
    type: detectContentType(item.slug),
    title: item.metadata.title,
    description: item.metadata.description || "",
    tags: item.metadata.tags || [],
    category: extractCategory(item.slug),
    grade: extractGrade(item.slug),
    material: extractMaterial(item.slug),
    createdAt: item.metadata.date || Date.now(),
    updatedAt: item.metadata.updatedAt || Date.now(),
  }));

  const total = contentList.length;
  const pagination = calculatePagination(page, limit, total);

  // Build response
  const response = {
    contents,
    pagination,
  };

  // Log access
  await c.env.runMutation(
    internal.contents.mutations.logAccess,
    {
      apiKeyId,
      contentSlug: basePath,
      action: "list",
      metadata: JSON.stringify({ locale, type, category, grade, material, page, limit }),
    }
  );

  return c.json(response, { status: HTTP_OK });
});
```

**Integration Points**:

- `requireApiKey()` validates API key before any processing
- `requireRateLimit()` checks quota before expensive content fetch
- `buildContentSlug()` uses helper from Task 2.1.1
- `calculatePagination()` uses helper from Task 2.1.2

**Output**: Functional route handler

---

### Subtask 2.1.3.2: Add Unit Tests

Test all scenarios for content list endpoint.

**Test File**: `packages/backend/convex/routes/__tests__/contents-list.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect, beforeAll } from "vitest";
import { api } from "../../_generated/api";

describe("GET /v1/contents", () => {
  let testUserId: Id<"users">;
  let testApiKeyId: Id<"apikey">;

  beforeAll(async () => {
    testUserId = await api.users.mutations.createTestUser({});
    testApiKeyId = await api.betterAuth.mutations.createApiKey({
      userId: testUserId,
      subscriptionTier: "free",
    });
  });

  describe("authentication", () => {
    it("should require API key", async () => {
      const response = await api.v1.contents.list({});

      expect(response).toBeDefined();
    });

    it("should accept valid API key", async () => {
      const response = await api.v1.contents.list({}, { apiKeyId: testApiKeyId });

      expect(response.contents).toBeInstanceOf(Array);
    });
  });

  describe("rate limiting", () => {
    it("should enforce free tier limit (25/day)", async () => {
      for (let i = 0; i < 25; i++) {
        await api.v1.contents.list({}, { apiKeyId: testApiKeyId });
      }

      const response = await api.v1.contents.list({}, { apiKeyId: testApiKeyId });
      expect(response.error).toBe("Rate limit exceeded");
      expect(response.retryAfter).toBeGreaterThan(0);
    });

    it("should enforce pro tier limit (100/min)", async () => {
      const proKeyId = await api.betterAuth.mutations.createApiKey({
        userId: testUserId,
        subscriptionTier: "pro",
      });

      for (let i = 0; i < 100; i++) {
        await api.v1.contents.list({}, { apiKeyId: proKeyId });
      }

      const response = await api.v1.contents.list({}, { apiKeyId: proKeyId });
      expect(response.error).toBe("Rate limit exceeded");
    });
  });

  describe("filtering", () => {
    it("should filter by type", async () => {
      const response = await api.v1.contents.list(
        { type: "articles" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.contents.every((c) => c.type === "articles")).toBe(true);
    });

    it("should filter by locale", async () => {
      const response = await api.v1.contents.list(
        { locale: "id" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.contents.every((c) => c.locale === "id")).toBe(true);
    });
  });

  describe("pagination", () => {
    it("should paginate results", async () => {
      const page1 = await api.v1.contents.list(
        { page: 1, limit: 10 },
        { apiKeyId: testApiKeyId }
      );

      const page2 = await api.v1.contents.list(
        { page: 2, limit: 10 },
        { apiKeyId: testApiKeyId }
      );

      expect(page1.contents).not.toEqual(page2.contents);
      expect(page1.pagination.page).toBe(1);
      expect(page2.pagination.page).toBe(2);
      expect(page1.pagination.hasNext).toBe(true);
      expect(page1.pagination.hasPrevious).toBe(false);
      expect(page2.pagination.hasPrevious).toBe(true);
    });
  });
});
```

**Coverage**:

- Authentication required
- Rate limiting by tier
- Filtering by type, locale
- Pagination works correctly
- Error responses (401, 429)
- Metadata only (no full content)

**Output**: Comprehensive test suite

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 2.1.4 - Add API Documentation

## üîó Related Tasks

- Task 2.1.1: Create Content List Types and Helpers (used in this task)
- Task 2.1.2: Create Pagination Helper (used in this task)
- Task 2.2: Create Content Get Endpoint (uses similar pattern)
- Task 2.4: Implement Tiered Rate Limiting (used via requireRateLimit middleware)

## ‚ö†Ô∏è Important Notes

### Implementation Notes

- Single action for all database operations
- Uses internal actions (not external HTTP requests)
- Proper error handling with specific HTTP codes

### DX Considerations

- **Clear pagination**: Page-based navigation (natural for humans)
- **Intuitive filters**: Query params match content structure
- **Consistent errors**: Same error format across all endpoints

### Performance

- Metadata only (faster responses, smaller payloads)
- Pagination (fetch only what's needed)
- Indexed queries (if implemented in future)

### Security

- API key validated before any processing
- Rate limit checked before expensive operations
- All access logged for analytics

### Future Enhancements

- Consider adding cursor-based pagination for large datasets
- Consider adding field-level filtering (request only specific fields)
- Consider adding sort parameter (date, popularity, alphabetical)

## Progress Tracking

After completing this task, update `plans/api-monetization/progress.txt`:

```txt
[YYYY-MM-DD HH:mm] Task 2.1.3 completed

Key decisions:
- Use c.env.runAction for content fetching (single action)
- Keep pagination logic in route handler (simple and testable)
- Apply rate limit BEFORE expensive content fetch
- Map to metadata format in route (no post-processing)

Files changed:
- packages/backend/convex/routes/v1/index.ts
- packages/backend/convex/routes/__tests__/contents-list.test.ts

Blockers/notes:
- None. Ready for Task 2.1.4.
```
