# Task 4.3: Add Request Signature Verification

## üéØ Goal

Add HMAC request signature verification to prevent automated bulk requests and replay attacks.

## üìç Context

This is **Phase 4.3** of Anti-Scraping Layers phase.

Current authentication (`Authorization: Bearer <key>`) protects API keys but doesn't prevent:

1. **Automated scripts**: Bots can generate valid requests without manual intervention
2. **Replay attacks**: Captured requests can be replayed
3. **Tampering**: Attackers can modify request bodies in transit

Request signatures add cryptographic verification:

- Each request includes unique signature
- Signature based on API key + timestamp + request data
- Server validates signature before processing
- Prevents replay attacks (timestamps expire quickly)
- Requires attackers to know API key secret (they don't)

## üé¨ Success Criteria

- [ ] Per-API-key secret generated for signing
- [ ] `verifySignature()` mutation created
- [ ] Signature verification applied to `/v1/contents/*` endpoints
- [ ] Timestamp validation (must be within 5 minutes)
- [ ] Replay attack prevention
- [ ] Returns 401 for invalid signatures
- [ ] Unit tests for all scenarios

## üìù Subtasks

### Subtask 4.3.1: Extend API Key Schema for Signing

Add signing secret field to API key records.

**File to modify**: `packages/backend/convex/betterAuth/generatedSchema.ts` (or via migration)

**Schema Addition**:

```typescript
// Add to existing apikey table
apikey: defineTable({
  // ... existing fields (key, userId, tier, permissions, etc.)

  // NEW FIELD
  signingSecret: v.optional(v.string()), // HMAC secret for request signing
})
```

**Purpose**:

- Each API key has unique signing secret
- Secret never exposed (only used server-side)
- Shared with API key holder only

**Migration** (when schema changes):

```typescript
export default migration({
  version: "v3_api_signing",
  up: async (ctx) => {
    const allApiKeys = await ctx.db.query("apikey").collect();

    // Generate signing secret for existing API keys
    for (const apiKey of allApiKeys) {
      if (!apiKey.signingSecret) {
        const signingSecret = crypto.randomBytes(32).toString("base64url");

        await ctx.db.patch("apikey", apiKey._id, {
          signingSecret,
        });
      }
    }
  },
  down: async (ctx) => {
    // Rollback: Clear signing secrets
    const allApiKeys = await ctx.db.query("apikey").collect();

    for (const apiKey of allApiKeys) {
      if (apiKey.signingSecret) {
        await ctx.db.patch("apikey", apiKey._id, {
          signingSecret: undefined, // Clear the secret
        });
      }
    }
  },
});
```

**Migration Plan**:

1. Deploy schema update
2. Migration runs automatically
3. Secrets generated for all existing keys
4. New API keys auto-generate secret on creation

**Output**: Extended schema with signing support

---

### Subtask 4.3.2: Create Signature Verification Mutation

Add mutation to validate request signatures.

**File to create**: `packages/backend/convex/routes/middleware/signature-verification.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";
import type { Id } from "../_generated/dataModel";

/**
 * Validates HMAC-SHA256 request signature.
 * Prevents replay attacks and ensures request integrity.
 */
export const verifySignature = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
    method: v.string(), // GET, POST, etc.
    path: v.string(), // Request path (e.g., /v1/contents/...)
    timestamp: v.number(),
    signature: v.string(), // HMAC signature
    bodyHash: v.string(), // Hash of request body (for POST)
  },
  returns: v.object({
    valid: v.boolean(),
    error: v.optional(v.string()),
  }),
  handler: async (ctx, args) => {
    // 1. Get API key
    const apiKey = await ctx.db.get("apikey", args.apiKeyId);

    if (!apiKey || apiKey.enabled !== true || !apiKey.signingSecret) {
      return {
        valid: false,
        error: "Invalid or disabled API key",
      };
    }

    // 2. Reconstruct expected signature
    const expectedString = `${apiKey.signingSecret}:${args.method}:${args.path}:${args.timestamp}`;

    if (args.bodyHash) {
      expectedString += `:${args.bodyHash}`;
    }

    const expectedSignature = crypto
      .createHmac("sha256")
      .update(expectedString)
      .digest("base64url");

    // 3. Compare with provided signature
    const isValid = crypto.timingSafeEqual(expectedSignature, args.signature);

    if (!isValid) {
      return {
        valid: false,
        error: "Invalid signature",
      };
    }

    // 4. Check timestamp freshness (must be within 5 minutes)
    const now = Date.now();
    const timestampAgeMs = now - args.timestamp;
    const maxAgeMs = 5 * 60 * 1000; // 5 minutes

    if (timestampAgeMs > maxAgeMs) {
      return {
        valid: false,
        error: "Signature expired. Timestamp must be within 5 minutes",
      };
    }

    return { valid: true, error: undefined };
  },
});

// Constant-time comparison for security
function timingSafeEqual(a: string, b: string): boolean {
  if (a.length !== b.length) {
    return false;
  }

  let result = 0;
  for (let i = 0; i < a.length; i++) {
    result |= a.charCodeAt(i) ^ b.charCodeAt(i);
  }

  return result === 0;
}
```

**Features**:

- **HMAC-SHA256**: Cryptographically secure signature algorithm
- **Constant-time**: Prevents timing attacks on signature validation
- **Timestamp validation**: Prevents replay attacks (5-minute window)
- **Body hash**: Optional for POST requests (ensures body integrity)
- **Error messages**: Generic (don't leak implementation details)

**Output**: Signature verification mutation

---

### Subtask 4.3.3: Create Signature Middleware

Add middleware to apply signature verification.

**File to create**: `packages/backend/convex/routes/middleware/signature-verification.ts`

**Implementation**:

```typescript
import type { MiddlewareHandler } from "hono";
import { HTTP_UNAUTHORIZED, HTTP_BAD_REQUEST } from "../constants";

/**
 * Request signature verification middleware.
 * Validates X-Nakafa-Signature header before request processing.
 */
export const requireSignature = (
  requireBodyHash = false // Optional: Require body hash for POST requests
): MiddlewareHandler<{
  Bindings: ActionCtx;
  Variables: {
    userId: string;
    apiKeyId: string;
  };
}> => {
  return async (c, next) => {
    const apiKeyId = c.get("apiKeyId");

    if (!apiKeyId) {
      return c.json(
        { error: "API key ID not found in context" },
        { status: 500 }
      );
    }

    // Extract signature from headers
    const signature = c.req.header("X-Nakafa-Signature");
    const timestamp = c.req.header("X-Nakafa-Timestamp");
    const bodyHash = c.req.header("X-Nakafa-Body-Hash");

    if (!signature || !timestamp) {
      return c.json(
        { error: "Missing required headers", },
        { status: HTTP_BAD_REQUEST }
      );
    }

    // For POST requests, require body hash
    const method = c.req.method;
    const bodyHashRequired = requireBodyHash && method === "POST";

    if (bodyHashRequired && !bodyHash) {
      return c.json(
        { error: "Body hash required for POST requests" },
        { status: HTTP_BAD_REQUEST }
      );
    }

    // Call signature verification
    const result = await c.env.runMutation(
      internal.routes.middleware.signatureVerification.verifySignature,
      {
        apiKeyId,
        method: method.toLowerCase(), // Normalize to lowercase
        path: new URL(c.req.url).pathname,
        timestamp: Number.parseInt(timestamp),
        signature,
        bodyHash: bodyHashRequired ? bodyHash : undefined,
      }
    );

    if (!result.valid) {
      return c.json(
        {
          error: result.error || "Invalid signature",
        code: "INVALID_SIGNATURE",
        },
        { status: HTTP_UNAUTHORIZED }
      );
    }

    // Signature valid, proceed with request
    await next();
  };
};
```

**Headers Required**:

- `X-Nakafa-Signature`: HMAC-SHA256 signature
- `X-Nakafa-Timestamp`: Unix timestamp in seconds
- `X-Nakafa-Body-Hash`: SHA-256 hash of request body (for POST only)

**Features**:

- **Automatic validation**: Middleware checks signatures before handlers
- **Method-specific**: Body hash only required for POST
- **Clear errors**: Specific error messages for debugging
- **Integration**: Works with existing rate limiting

**Output**: Signature middleware

---

### Subtask 4.3.4: Generate Client Signature Helper

Create utility function for clients to generate signatures.

**File to create**: `packages/connection/lib/signature.ts`

**Implementation**:

```typescript
import { HTTP_UNAUTHORIZED } from "./types";

export interface SignatureHeaders {
  "X-Nakafa-Signature": string;
  "X-Nakafa-Timestamp": string; // Unix timestamp in seconds
  "X-Nakafa-Body-Hash"?: string; // For POST requests only
}

/**
 * Generates HMAC-SHA256 signature for API requests.
 * Prevents tampering and proves request authenticity.
 *
 * @param apiKeySigningSecret - The signing secret from your API key
 * @param method - HTTP method (GET, POST, etc.)
 * @param path - Request path (e.g., /v1/contents/en/subject/math)
 * @param body - Request body (for POST only, undefined for GET)
 * @param timestamp - Unix timestamp in seconds
 * @returns Headers with signature
 */
export function generateSignature({
  apiKeySigningSecret,
  method,
  path,
  body,
}: {
  apiKeySigningSecret: string;
  method: string;
  path: string;
  body?: string;
}): SignatureHeaders {
  const timestamp = Math.floor(Date.now() / 1000); // Current time in seconds

  // Build signature string
  let signatureString = `${apiKeySigningSecret}:${method}:${path}:${timestamp}`;

  if (body !== undefined) {
    // Include body hash for POST requests
    const bodyHash = crypto
      .createHash("sha256")
      .update(body)
      .digest("base64url");
    signatureString += `:${bodyHash}`;
  }

  // Generate HMAC-SHA256 signature
  const signature = crypto
    .createHmac("sha256", apiKeySigningSecret)
    .update(signatureString)
    .digest("base64url");

  // Build headers object
  const headers: SignatureHeaders = {
    "X-Nakafa-Signature": signature,
    "X-Nakafa-Timestamp": timestamp.toString(),
  };

  if (body !== undefined) {
    headers["X-Nakafa-Body-Hash"] = crypto
      .createHash("sha256")
      .update(body)
      .digest("base64url");
  }

  return headers;
}

/**
 * Client-side signature generation example
 *
 * @example
 * ```typescript
 * import { generateSignature } from "@repo/connection/lib/signature";
 *
 * const response = await fetch("https://api.nakafa.com/v1/contents", {
 *   headers: {
 *     ...generateSignature({
 *       apiKeySigningSecret: "your-signing-secret",
 *       method: "GET",
 *       path: "/v1/contents/en/subject/math",
 *     }),
 *   });
 * ```
 */
```

**Client-Side Usage**:

- Developers use this helper to sign requests
- Only need their API key's signing secret
- Headers included automatically in fetch calls

**Output**: Client signature utility

---

### Subtask 4.3.5: Apply Signature Verification to Endpoints

Apply signature middleware to all `/v1/contents/*` endpoints.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Changes Required**:

```typescript
import { requireSignature } from "../middleware/signature-verification";

// Apply signature verification to list endpoint
v1.get("/contents", requireApiKey(), requireSignature(), async (c) => {
  // Signature already validated in middleware
  // Proceed with list logic
});

// Apply to get single endpoint (GET)
v1.get("/contents/:slug", requireApiKey(), requireSignature(), async (c) => {
  // No body hash required for GET
});

// Apply to search endpoint (POST)
v1.post("/contents/search", requireApiKey(), requireSignature(requireBodyHash: true), async (c) => {
  // Body hash validated in middleware
});

// Apply to key management endpoints (POST)
v1.post("/api-keys", requireAuthWithSession(), requireSignature(requireBodyHash: true), async (c) => {
  // Body hash validated for key creation
});
```

**Endpoints to Protect**:

- `/v1/contents` (GET)
- `/v1/contents/:slug` (GET)
- `/v1/contents/search` (POST)
- `/v1/api-keys` (POST)

**Output**: All protected endpoints

---

### Subtask 4.3.6: Add Unit Tests

Test signature verification and client helper.

**File to create**: `packages/backend/convex/routes/__tests__/signature-verification.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect } from "vitest";
import { verifySignature } from "../../routes/middleware/signature-verification";
import { generateSignature } from "@repo/connection/lib/signature";
import { createApiKey } from "../../../apikeys/mutations";

describe("Signature Verification", () => {
  describe("verifySignature mutation", () => {
    it("should validate correct signature", async () => {
      const apiKey = await createApiKey({});

      const signature = generateSignature({
        apiKeySigningSecret: apiKey.signingSecret!,
        method: "GET",
        path: "/v1/contents/en/test",
        body: undefined,
        timestamp: Math.floor(Date.now() / 1000),
      });

      const result = await verifySignature({
        apiKeyId: apiKey._id,
        method: "GET",
        path: "/v1/contents/en/test",
        timestamp: Math.floor(Date.now() / 1000),
        signature,
      });

      expect(result.valid).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it("should reject invalid signature", async () => {
      const apiKey = await createApiKey({});

      const signature = "wrong-signature";

      const result = await verifySignature({
        apiKeyId: apiKey._id,
        method: "GET",
        path: "/v1/contents/en/test",
        timestamp: Math.floor(Date.now() / 1000),
        signature,
      });

      expect(result.valid).toBe(false);
      expect(result.error).toBe("Invalid signature");
    });

    it("should reject expired timestamp", async () => {
      const apiKey = await createApiKey({});

      const oldTimestamp = Math.floor((Date.now() - 6 * 60 * 1000) / 1000); // 6 minutes ago

      const signature = generateSignature({
        apiKeySigningSecret: apiKey.signingSecret!,
        method: "GET",
        path: "/v1/contents/en/test",
        timestamp: oldTimestamp,
      });

      const result = await verifySignature({
        apiKeyId: apiKey._id,
        method: "GET",
        path: "/v1/contents/en/test",
        timestamp: oldTimestamp,
        signature,
      });

      expect(result.valid).toBe(false);
      expect(result.error).toContain("Signature expired");
    });
  });

  describe("generateSignature helper", () => {
    it("should generate valid signature headers", () => {
      const headers = generateSignature({
        apiKeySigningSecret: "test-secret",
        method: "GET",
        path: "/v1/contents/en/test",
        timestamp: 1234567890,
      });

      expect(headers["X-Nakafa-Signature"]).toBeDefined();
      expect(headers["X-Nakafa-Timestamp"]).toBe("1234567890");
      expect(headers["X-Nakafa-Timestamp"].length).toBe(10); // Unix timestamp in seconds
      expect(headers["X-Nakafa-Signature"]).toMatch(/^[A-Za-z0-9+/+=/);
    });

    it("should include body hash for POST requests", () => {
      const body = JSON.stringify({ test: "data" });

      const headers = generateSignature({
        apiKeySigningSecret: "test-secret",
        method: "POST",
        path: "/v1/api-keys",
        body,
        timestamp: 1234567890,
      });

      expect(headers["X-Nakafa-Signature"]).toBeDefined();
      expect(headers["X-Nakafa-Body-Hash"]).toBeDefined();
      expect(headers["X-Nakafa-Body-Hash"]).toMatch(/^[A-Za-z0-9+/=+$/);
      });

    it("should not include body hash for GET requests", () => {
      const headers = generateSignature({
        apiKeySigningSecret: "test-secret",
        method: "GET",
        path: "/v1/contents",
        timestamp: 1234567890,
        body: undefined, // GET has no body
      });

      expect(headers["X-Nakafa-Body-Hash"]).toBeUndefined();
    });
  });
});
```

**Coverage**:

- ‚úÖ Valid signatures accepted
- ‚úÖ Invalid signatures rejected
- ‚úÖ Expired timestamps rejected
- ‚úÖ Body hash included for POST only
- ‚úÖ Client helper generates correct headers

**Output**: Comprehensive test suite

---

### Subtask 4.3.7: Add API Documentation

Document signature verification for developers.

**File to create**: `docs/api/signature-verification.md`

**Content**:

```markdown
# Request Signature Verification

## Overview
HMAC-SHA256 request signatures prevent automated bulk requests and replay attacks.

## Getting Your Signing Secret

Your signing secret is provided when you generate an API key. It's shown **once** in the response.

**Example**:
```json
{
  "apiKeyId": "abc123...",
  "apiKey": "nak_pk_A1b2c3...",
  "name": "Production App",
  "tier": "pro",
  "signingSecret": "xYz123...abc456...", // ‚ö†Ô∏è SAVE THIS SECURELY!
  "warning": "IMPORTANT: Save this signing secret now. You won't see it again."
}
```

## Required Headers

For all API requests, include these headers:

### GET Requests

```http
X-Nakafa-Signature: <HMAC-SHA256 signature>
X-Nakafa-Timestamp: <Unix timestamp in seconds>
```

### POST Requests

```http
X-Nakafa-Signature: <HMAC-SHA256 signature>
X-Nakafa-Timestamp: <Unix timestamp in seconds>
X-Nakafa-Body-Hash: <SHA-256 hash of request body>
```

## Client-Side Implementation

### Using Our Helper Library

```typescript
import { generateSignature } from "@repo/connection/lib/signature";

const response = await fetch("https://api.nakafa.com/v1/contents/en/subject/math", {
  headers: {
    ...generateSignature({
      apiKeySigningSecret: "your-signing-secret",
      method: "GET",
      path: "/v1/contents/en/subject/math",
      timestamp: Math.floor(Date.now() / 1000), // Current time
    }),
  },
});
```

### Manual Implementation (if not using helper)

```typescript
import { createHmac } from "crypto";

function generateSignatureManual(
  apiKeySigningSecret: string,
  method: string,
  path: string,
  body?: string
): { signature: string; timestamp: number } {
  const timestamp = Math.floor(Date.now() / 1000);
  let signatureString = `${apiKeySigningSecret}:${method}:${path}:${timestamp}`;

  if (body !== undefined) {
    const bodyHash = createHash("sha256").update(body).digest("base64url");
    signatureString += `:${bodyHash}`;
  }

  const signature = createHmac("sha256", apiKeySigningSecret)
    .update(signatureString)
    .digest("base64url");

  return { signature, timestamp };
}
```

## Error Responses

### 401 Unauthorized (Invalid Signature)

```json
{
  "error": "Invalid signature",
  "code": "INVALID_SIGNATURE"
}
```

### 401 Unauthorized (Expired Timestamp)

```json
{
  "error": "Signature expired. Timestamp must be within 5 minutes",
  "code": "SIGNATURE_EXPIRED"
}
```

### 400 Bad Request (Missing Headers)

```json
{
  "error": "Missing required headers"
}
```

## Security Benefits

1. **Replay Attack Prevention**: Timestamps expire after 5 minutes
2. **Request Integrity**: Body hash prevents tampering
3. **Proof of Originance**: Only API key holder can generate valid signatures
4. **Automated Bot Detection**: Scripts must implement signature logic
5. **Enhanced Rate Limiting**: Signatures add cost to automated requests

## Example: Full Flow

```typescript
// 1. Get API key and signing secret
const createResponse = await fetch("https://api.nakafa.com/v1/api-keys", {
  headers: { "Authorization": `Bearer ${userSessionToken}` },
});

const apiKeyId = createResponse.apiKeyId;
const signingSecret = createResponse.signingSecret;

// 2. Make API request with signature
const timestamp = Math.floor(Date.now() / 1000);

const response = await fetch("https://api.nakafa.com/v1/contents/en/subject/math", {
  headers: {
    "X-Nakafa-Signature": generateSignature({
      apiKeySigningSecret: signingSecret,
      method: "GET",
      path: "/v1/contents/en/subject/math",
      timestamp,
    }).X-Nakafa-Signature,
    "X-Nakafa-Timestamp": timestamp.toString(),
  },
});

// 3. API validates signature and returns content
```

## Best Practices

1. **Keep Secret Secure**:
   - Store in environment variables only
   - Never commit to git
   - Never log or display
   - Rotate if suspected compromise

2. **Timestamp Freshness**:
   - Always generate timestamp right before request
   - Server allows 5-minute window
   - Timestamps must be Unix time in seconds

3. **Body Hash**:
   - Required for all POST requests
   - Compute SHA-256 hash of entire request body
   - Include in signature string (after timestamp)

4. **Implementation Order**:

   ```typescript
   // CORRECT order:
   signatureString = `${secret}:${method}:${path}:${timestamp}:${bodyHash}`;
   
   // NOT:
   signatureString = `${secret}:${bodyHash}:${timestamp}:${method}:${path}`;
   ```

5. **Debugging**:
   - Use `X-Nakafa-Debug` header in development
   - Server can return details about what failed
   - Remove in production

6. **Language Support**:
   - Our helper library supports TypeScript
   - Manual implementation for other languages (Python, curl, etc.)

```

## FAQ

**Q: What happens if I lose my signing secret?**
A: Generate a new API key. Old keys continue to work, but can't sign requests. Revoked keys can't generate new signatures.

**Q: Can I omit the timestamp for testing?**
A: In development, you can use `X-Nakafa-Debug: skip-timestamp` header. Server will accept any timestamp during testing.

**Q: Do I need to include the body in the signature?**
A: Only for POST, PUT, PATCH, DELETE requests. GET and HEAD requests should omit body hash.

**Q: What timezone should I use for the timestamp?**
A: Use UTC (Coordinated Universal Time). Convert with: `Math.floor(Date.now() / 1000)`. This matches server-side expectations.
```

**Output**: Developer documentation

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 4.4: Add Content Watermarking
2. **Phase 4**: Continue building anti-scraping layers

## üîó Related Tasks

- Task 0.1: Internal API Key Storage (signing secrets added here)
- Task 0.2: Extend Better Auth Schema (schema updated)
- Task 4.1: Implement Velocity-Based Scraping Detection (signatures add another layer)
- Task 4.5: Implement Automatic API Key Revocation (applies to signature violations)

## ‚ö†Ô∏è Important Notes

### Security vs Complexity Trade-off

- **Replay protection** vs **Implementation complexity**: Signatures add complexity for clients
- **Recommendation**: Enable signature validation for Enterprise tier, optional for Pro tier
- **Free tier**: May have relaxed signature requirements (monitor usage patterns)

### Implementation Strategy

- **Phase 1**: Add schema migration (generate secrets for existing keys)
- **Phase 2**: Update API key generation to create signing secret
- **Phase 3**: Deploy signature middleware to critical endpoints
- **Phase 4**: Update API documentation with signature examples

### False Positive Prevention

- Power users might generate many signatures quickly
- Consider rate limiting by signature verification (costly for attackers)
- Monitor for signature failures (could indicate attempted exploits)

### Future Enhancements

- Consider adding request ID parameter (unique identifier for deduplication)
- Consider adding nonce parameter (one-time use, server validates)
- Consider supporting multiple signature algorithms (Ed25519, Ed448 for higher security)
- Consider adding API key scopes (different keys for signing vs authentication)
