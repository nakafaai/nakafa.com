# Task 2.4.2: Rate Limit Mutation (Fixed)

## Goal

Create checkRateLimit mutation that uses Better Auth's built-in rate limiting.

## Context

**Better Auth Already Provides**:
- ✅ Automatic rate limiting
- ✅ Counter management (`requestCount`, `remaining`)
- ✅ Refill mechanism

**We Need**:
- Wrapper mutation that checks Better Auth's counters
- Enforce tier-based limits
- Return remaining quota

## PRD

```json
{
  "category": "functional",
  "description": "Rate limit mutation using Better Auth",
  "steps": [
    "Create checkRateLimit mutation",
    "Query Better Auth's apikey table",
    "Check remaining quota",
    "Return usage statistics",
    "Add tests"
  ],
  "passes": false
}
```

## Success

- [ ] Mutation created
- [ ] Uses Better Auth's built-in fields
- [ ] Returns proper error when limit exceeded
- [ ] Tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 2.4.2.1: Create Mutation

**File**: `packages/backend/convex/betterAuth/mutations/checkRateLimit.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { internalMutation } from "../../_generated/server";

export interface RateLimitCheckResult {
  allowed: boolean;
  retryAfter?: number;
  remaining: number;
  requestCount: number;
  rateLimitMax: number | null;
}

export const checkRateLimit = internalMutation({
  args: v.object({
    apiKeyId: v.string(), // Better Auth uses string IDs
  }),
  returns: v.object({
    allowed: v.boolean(),
    retryAfter: v.optional(v.number()),
    remaining: v.number(),
    requestCount: v.number(),
    rateLimitMax: v.optional(v.number()),
  }),
  handler: async (ctx, args) => {
    const { apiKeyId } = args;

    // Get API key from Better Auth's apikey table
    const apiKey = await ctx.db
      .query("apikey")
      .withIndex("key")
      .eq("_id", apiKeyId)
      .unique();

    if (!apiKey) {
      return {
        allowed: false,
        retryAfter: 0,
        remaining: 0,
        requestCount: 0,
        rateLimitMax: 0,
      };
    }

    // Check if key is enabled
    if (apiKey.enabled === false) {
      return {
        allowed: false,
        retryAfter: 0,
        remaining: 0,
        requestCount: apiKey.requestCount ?? 0,
        rateLimitMax: apiKey.rateLimitMax,
      };
    }

    // Check if rate limiting is enabled
    if (apiKey.rateLimitEnabled === false) {
      // Enterprise tier: unlimited
      return {
        allowed: true,
        remaining: Infinity,
        requestCount: apiKey.requestCount ?? 0,
        rateLimitMax: null,
      };
    }

    const remaining = apiKey.remaining ?? 0;
    const requestCount = apiKey.requestCount ?? 0;
    const rateLimitMax = apiKey.rateLimitMax ?? 0;

    // Check if limit exceeded
    if (remaining <= 0) {
      // Calculate retry time based on refill interval
      let retryAfter = 0;
      if (apiKey.refillInterval && apiKey.lastRequest) {
        const nextRefill = apiKey.lastRequest + apiKey.refillInterval;
        retryAfter = Math.max(0, Math.ceil((nextRefill - Date.now()) / 1000));
      } else if (apiKey.rateLimitTimeWindow) {
        retryAfter = Math.ceil(apiKey.rateLimitTimeWindow / 1000);
      }

      return {
        allowed: false,
        retryAfter,
        remaining: 0,
        requestCount,
        rateLimitMax,
      };
    }

    // Rate limit OK, decrement counter
    const newRemaining = Math.max(0, remaining - 1);
    const newRequestCount = requestCount + 1;

    await ctx.db.patch("apikey", apiKeyId, {
      remaining: newRemaining,
      requestCount: newRequestCount,
      lastRequest: Date.now(),
    });

    return {
      allowed: true,
      remaining: newRemaining,
      requestCount: newRequestCount,
      rateLimitMax,
    };
  },
});
```

**Output**: Mutation created

---

### Subtask 2.4.2.2: Add Tests

**File**: `packages/backend/convex/betterAuth/__tests__/checkRateLimit.test.ts`

**Tests**:

```typescript
describe("checkRateLimit", () => {
  let freeApiKeyId;
  let proApiKeyId;
  let enterpriseApiKeyId;

  beforeAll(async () => {
    const userId = await createTestUser();

    const freeResult = await createApiKey({
      userId,
      name: "Free Key",
      subscriptionTier: "free",
    });

    const proResult = await createApiKey({
      userId,
      name: "Pro Key",
      subscriptionTier: "pro",
    });

    const enterpriseResult = await createApiKey({
      userId,
      name: "Enterprise Key",
      subscriptionTier: "enterprise",
    });

    freeApiKeyId = freeResult.apiKeyId;
    proApiKeyId = proResult.apiKeyId;
    enterpriseApiKeyId = enterpriseResult.apiKeyId;
  });

  it("should allow request when quota available", async () => {
    const result = await checkRateLimit({ apiKeyId: freeApiKeyId });

    expect(result.allowed).toBe(true);
    expect(result.remaining).toBeGreaterThan(0);
    expect(result.requestCount).toBe(1);
  });

  it("should decrement remaining counter", async () => {
    await checkRateLimit({ apiKeyId: freeApiKeyId });
    const result2 = await checkRateLimit({ apiKeyId: freeApiKeyId });

    expect(result2.requestCount).toBe(2);
    expect(result2.remaining).toBe(23); // Started with 25, used 2
  });

  it("should enforce free tier limit (25/day)", async () => {
    // Use up the quota
    for (let i = 0; i < 25; i++) {
      await checkRateLimit({ apiKeyId: freeApiKeyId });
    }

    const result = await checkRateLimit({ apiKeyId: freeApiKeyId });

    expect(result.allowed).toBe(false);
    expect(result.remaining).toBe(0);
    expect(result.retryAfter).toBeGreaterThan(0);
  });

  it("should allow unlimited for enterprise", async () => {
    for (let i = 0; i < 1000; i++) {
      await checkRateLimit({ apiKeyId: enterpriseApiKeyId });
    }

    const result = await checkRateLimit({ apiKeyId: enterpriseApiKeyId });

    expect(result.allowed).toBe(true);
    expect(result.remaining).toBe(Infinity);
  });

  it("should block disabled keys", async () => {
    // Disable the key
    await ctx.runMutation(internal.betterAuth.mutations.updateApiKey, {
      apiKeyId: freeApiKeyId,
      enabled: false,
    });

    const result = await checkRateLimit({ apiKeyId: freeApiKeyId });

    expect(result.allowed).toBe(false);
  });

  it("should return retry time when exceeded", async () => {
    // Use up quota
    for (let i = 0; i < 25; i++) {
      await checkRateLimit({ apiKeyId: freeApiKeyId });
    }

    const result = await checkRateLimit({ apiKeyId: freeApiKeyId });

    expect(result.retryAfter).toBeGreaterThan(0);
    expect(result.retryAfter).toBeLessThanOrEqual(86400); // 24 hours
  });
});
```

**Output**: Tests

---

## Next Steps

After: Task 2.4.3 - Rate Limit Middleware

## Related

- Task 2.4.1: Rate Limit Config (tier limits)
- Task 2.4.3: Middleware (uses this mutation)

## Progress

```
[YYYY-MM-DD HH:mm] Task 2.4.2 completed

Key decisions:
- Query Better Auth's apikey table directly
- Use built-in remaining and requestCount fields
- Decrement counters on each request
- Return retry time based on refillInterval

Files changed:
- packages/backend/convex/betterAuth/mutations/checkRateLimit.ts
- packages/backend/convex/betterAuth/__tests__/checkRateLimit.test.ts

Blockers: None
```

## Important Note

**This mutation must be called before each API request** that uses the API key to:
1. Check if quota available
2. Decrement the counter
3. Return error if exceeded

Better Auth handles the actual rate limiting - we just check the counters.
