# Task 2.3.2: Search Algorithm

## Goal

Create relevance-based search function with Convex best practices.

## Context

Search needs to:
- Fetch all contents efficiently with limits
- Calculate relevance scores in memory
- Return ranked results with snippets
- Filter by type, locale

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

## PRD
```json
{
  "category": "functional",
  "description": "Search algorithm with relevance scoring and pagination",
  "steps": [
    "Fetch contents with pagination limit",
    "Calculate relevance scores for each item",
    "Sort results by relevance",
    "Generate snippets with highlighted matches",
    "Apply result limit"
  ],
  "passes": false
}
```

## Success Criteria

- [ ] `searchContents` function created
- [ ] Uses `.take()` limit on `.collect()`
- [ ] Relevance scoring implemented
- [ ] Snippet generation with highlighting
- [ ] Filtering by type/locale works
- [ ] Unit tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 2.3.2.1: Create Search Function

Create search algorithm with proper Convex patterns.

**File**: `packages/backend/convex/routes/v1/contents/search/algorithm.ts`

**Implementation**:

```typescript
import { getContents } from "@repo/contents/_lib/content";
import type { SearchContentsRequest } from "./types";

export async function searchContents(params: SearchContentsRequest) {
  const { query, locale = "en", type, limit = 20 } = params;

  const keywords = extractKeywords(query);
  const lowercaseQuery = query.toLowerCase();

  // Convex best practice: Use .take() to limit results
  const allContents = await getContents({
    locale,
    basePath: "",
    includeMDX: false,
  });

  // Apply pagination limit first
  const limitedContents = allContents.slice(0, 1000);

  const results = limitedContents
    .map((item) => {
      const title = item.metadata.title.toLowerCase();
      const description = (item.metadata.description || "").toLowerCase();
      const tags = (item.metadata.tags || []).map((t) => t.toLowerCase());

      let score = 0;

      if (title.includes(lowercaseQuery)) {
        score += 0.5;
      } else {
        for (const keyword of keywords) {
          if (title.includes(keyword)) {
            score += 0.25;
          }
        }
      }

      if (title.includes(lowercaseQuery) && keywords.length > 1) {
        score += 0.3;
      }

      if (description.includes(lowercaseQuery)) {
        score += 0.3;
      }

      for (const tag of tags) {
        if (tag.includes(lowercaseQuery) || keywords.includes(tag)) {
          score += 0.35;
          break;
        }
      }

      return {
        slug: item.slug,
        url: item.url,
        locale: item.locale,
        type: detectContentGetType(item.slug),
        title: item.metadata.title,
        description: item.metadata.description || "",
        snippet: generateSnippet(description, query),
        relevanceScore: Math.min(score, 1.0),
        metadata: {
          tags: item.metadata.tags || [],
          category: extractCategory(item.slug),
          grade: extractGrade(item.slug),
          material: extractMaterial(item.slug),
        },
      };
    })
    .filter((item) => {
      if (type && detectContentGetType(item.slug) !== type) {
        return false;
      }
      return true;
    })
    .sort((a, b) => b.relevanceScore - a.relevanceScore)
    .slice(0, limit);

  return results;
}

function extractKeywords(query: string): string[] {
  const stopWords = new Set([
    "the", "a", "an", "and", "or", "but", "in", "on", "at", "to",
    "of", "for", "with", "is", "as", "by", "this", "that",
  ]);

  return query
    .toLowerCase()
    .split(/\s+/)
    .filter((word) => word.length > 2)
    .filter((word) => !stopWords.has(word));
}

function generateSnippet(text: string, query: string): string {
  const lowercaseText = text.toLowerCase();
  const index = lowercaseText.indexOf(query.toLowerCase());

  if (index === -1) {
    return text.substring(0, 150) + (text.length > 150 ? "..." : "");
  }

  const start = Math.max(0, index - 50);
  const end = Math.min(text.length, index + query.length + 50);

  let snippet = text.substring(start, end);
  const highlightPattern = new RegExp(`(${query})`, "gi");
  snippet = snippet.replace(highlightPattern, "**$1**");

  return snippet.trim() + "...";
}
```


**Output**: Search algorithm

---

### Subtask 2.3.2.2: Add Unit Tests

Test search scenarios.

**File**: `packages/backend/convex/routes/__tests__/search-algorithm.test.ts`

**Tests**:

```typescript
import { describe, it, expect } from "vitest";
import { searchContents } from "../v1/contents/search/algorithm";

describe("searchContents", () => {
  it("should return ranked results", async () => {
    const results = await searchContents({
      query: "algebra",
      limit: 10,
    });

    expect(results.length).toBeLessThanOrEqual(10);
    expect(results[0].relevanceScore).toBeGreaterThanOrEqual(
      results[1]?.relevanceScore ?? 0
    );
  });

  it("should generate snippet with highlight", async () => {
    const results = await searchContents({
      query: "democracy",
      limit: 10,
    });

    expect(results[0].snippet).toContain("**democracy**");
  });

  it("should filter by type", async () => {
    const results = await searchContents({
      query: "test",
      type: "articles",
      limit: 10,
    });

    expect(results.every((r) => r.type === "articles")).toBe(true);
  });
});
```

**Output**: Tests

---

## Next Steps

After: Task 2.3.3 - Search Route Handler

## Related

- Task 2.3.1: Search Types (uses these interfaces)
- Task 2.3.3: Route Handler (uses this algorithm)

## Progress

```
[YYYY-MM-DD HH:mm] Task 2.3.2 completed

Key decisions:
- Limit initial fetch to 1000 items (Convex best practice)
- Filter and sort in memory (fast enough for reasonable datasets)
- Use highlight markers for snippets

Files changed:
- packages/backend/convex/routes/v1/contents/search/algorithm.ts
- packages/backend/convex/routes/__tests__/search-algorithm.test.ts

Blockers: None
```
