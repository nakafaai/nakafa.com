# Task 2.4: Implement Tiered Rate Limiting

## ðŸŽ¯ Goal

Create comprehensive rate limiting system for API keys with tier-based limits, automatic resets, and enforcement.

## ðŸ“ Context

This is **Phase 2.4** of Build Public Content API phase.

Rate limiting is **critical for**:

1. **Preventing scraping**: Bulk downloads blocked by rate limits
2. **Fair usage**: Ensure all API key tiers get fair access
3. **Monetization**: Encourages upgrade to Pro/Enterprise for higher limits
4. **Scalability**: Efficient counters without expensive queries

We started implementing this in Task 2.1.4 but need to:

1. Create reusable rate limit mutation
2. Add automatic counter resets
3. Support all three tiers (Free, Pro, Enterprise)
4. Track both daily and minute limits
5. Provide clear error messages with retry-after timing

## ðŸŽ¬ Success Criteria

- [ ] `checkRateLimit()` mutation created
- [ ] `apiKeyUsage` table populated/updated correctly
- [ ] Automatic resets work (daily at midnight, minute on the minute)
- [ ] All three tiers supported (Free: 25/day, Pro: 100/min+1000/day, Enterprise: unlimited)
- [ ] Returns retry-after time in seconds
- [ ] Returns remaining quota count
- [ ] Unit tests for all scenarios

## ðŸ“ Subtasks

### Subtask 2.4.1: Create Rate Limit Check Mutation

Build mutation to check, enforce, and update rate limits.

**File to create**: `packages/backend/convex/betterAuth/mutations/rate-limit.ts` (or add to existing mutations.ts)

**Implementation**:

```typescript
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";
import type { Id } from "../_generated/dataModel";

const TIER_LIMITS = {
  free: {
    rateLimitDaily: 25,
    rateLimitMinute: null, // No minute limit for free tier
  },
  pro: {
    rateLimitDaily: 1000,
    rateLimitMinute: 100,
  },
  enterprise: {
    rateLimitDaily: null, // Unlimited
    rateLimitMinute: null, // Unlimited
  },
} as const;

export const checkRateLimit = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
    resource: v.string(), // "contents", "search", etc.
    action: v.string(), // "list", "get", "search"
  },
  returns: v.object({
    allowed: v.boolean(),
    retryAfter: v.optional(v.number()), // Seconds until reset
    remaining: v.optional(v.number()), // Requests remaining today
  }),
  handler: async (ctx, args) => {
    const apiKey = await ctx.db.get("apikey", args.apiKeyId);

    if (!apiKey || apiKey.enabled !== true) {
      return {
        allowed: false,
        retryAfter: 0,
      };
    }

    const tier = apiKey.subscriptionTier || "free";
    const limits = TIER_LIMITS[tier];
    const now = Date.now();
    const oneDayMs = 24 * 60 * 60 * 1000;
    const oneMinuteMs = 60 * 1000;
    const tomorrow = getMidnight(now);
    const nextMinute = getStartOfNextMinute(now);

    // Get or create usage record
    let usage = await ctx.db
      .query("apiKeyUsage")
      .withIndex("apiKeyId")
      .eq("apiKeyId", args.apiKeyId)
      .unique();

    if (!usage) {
      // First request - initialize counters
      usage = {
        apiKeyId: args.apiKeyId,
        requestsToday: 1,
        requestsThisMinute: 1,
        lastRequestTime: now,
        dailyResetTime: tomorrow,
        minuteResetTime: nextMinute,
      };
      await ctx.db.insert("apiKeyUsage", usage);

      return {
        allowed: true,
        remaining: limits.rateLimitDaily ? limits.rateLimitDaily - 1 : null,
      };
    }

    // Check and handle resets
    const needsDailyReset = now >= usage.dailyResetTime;
    const needsMinuteReset = now >= usage.minuteResetTime;

    const requestsToday = needsDailyReset ? 1 : usage.requestsToday + 1;
    const requestsThisMinute = needsMinuteReset ? 1 : usage.requestsThisMinute + 1;

    // Check limits
    let dailyExceeded = false;
    let minuteExceeded = false;

    if (limits.rateLimitDaily) {
      dailyExceeded = requestsToday > limits.rateLimitDaily;
    }

    if (limits.rateLimitMinute) {
      minuteExceeded = requestsThisMinute > limits.rateLimitMinute;
    }

    // Calculate retry after time
    let retryAfter: number | undefined;

    if (dailyExceeded) {
      retryAfter = Math.ceil((usage.dailyResetTime - now) / 1000);
    } else if (minuteExceeded) {
      retryAfter = Math.ceil((usage.minuteResetTime - now) / 1000);
    }

    if (dailyExceeded || minuteExceeded) {
      // Don't increment counters if limit exceeded
      return {
        allowed: false,
        retryAfter,
        remaining: 0,
      };
    }

    // Update usage counters
    await ctx.db.patch("apiKeyUsage", usage._id, {
      requestsToday,
      requestsThisMinute,
      lastRequestTime: now,
      dailyResetTime: needsDailyReset ? tomorrow : usage.dailyResetTime,
      minuteResetTime: needsMinuteReset ? nextMinute : usage.minuteResetTime,
    });

    return {
      allowed: true,
      remaining: limits.rateLimitDaily ? limits.rateLimitDaily - requestsToday : null,
    };
  },
});

function getMidnight(now: number): number {
  const date = new Date(now);
  date.setHours(23, 59, 59, 999); // End of day
  return date.getTime();
}

function getStartOfNextMinute(now: number): number {
  const date = new Date(now);
  date.setSeconds(0, 0);
  date.setMinutes(date.getMinutes() + 1);
  return date.getTime();
}
```

**Features**:

- **Tier-based limits**: Free, Pro, Enterprise
- **Auto-reset**: Daily at midnight, minute on the minute
- **Retry-after**: Tells user when they can retry
- **Remaining**: Shows how many requests left
- **Efficient**: Single database document per API key

**Output**: Rate limit check mutation

---

### Subtask 2.4.2: Add Integration Helper

Helper function to use rate limiting in routes.

**File to create**: `packages/backend/convex/routes/middleware/rate-limit.ts`

**Implementation**:

```typescript
import type { MiddlewareHandler } from "hono";
import { HTTP_TOO_MANY_REQUESTS } from "../constants";

/**
 * Rate limiting middleware for Hono routes.
 * Checks rate limits before request handler executes.
 *
 * @param resource - API resource (contents, search, etc.)
 * @param action - Action being performed (list, get, search)
 */
export const requireRateLimit = (
  resource: string,
  action: string
): MiddlewareHandler<{
  Bindings: ActionCtx;
  Variables: {
    userId: string;
    apiKeyId: Id<"apikey">;
  };
}> => {
  return async (c, next) => {
    const apiKeyId = c.get("apiKeyId");

    if (!apiKeyId) {
      return c.json(
        { error: "API key ID not found in context" },
        { status: 500 }
      );
    }

    // Check rate limit
    const rateLimitResult = await c.env.runMutation(
      internal.betterAuth.mutations.checkRateLimit,
      {
        apiKeyId,
        resource,
        action,
      }
    );

    if (!rateLimitResult.allowed) {
      return c.json(
        {
          error: "Rate limit exceeded",
          retryAfter: rateLimitResult.retryAfter,
          remaining: rateLimitResult.remaining,
        },
        {
          status: HTTP_TOO_MANY_REQUESTS,
          headers: {
            "Retry-After": rateLimitResult.retryAfter?.toString() ?? "0",
            "X-RateLimit-Remaining": rateLimitResult.remaining?.toString() ?? "0",
          },
        }
      );
    }

    // Rate limit OK, add remaining to context
    if (rateLimitResult.remaining !== undefined) {
      c.set("rateLimitRemaining", rateLimitResult.remaining);
    }

    await next();
  };
};
```

**Integration Example**:

```typescript
// In v1 index.ts
import { requireRateLimit } from "../middleware/rate-limit";

v1.get("/contents", requireApiKey(), requireRateLimit("contents", "list"), async (c) => {
  // Rate limit already checked
  // Proceed with logic
});
```

**Output**: Reusable middleware

---

### Subtask 2.4.3: Add Unit Tests

Test rate limiting across all tiers and scenarios.

**File to create**: `packages/backend/convex/betterAuth/__tests__/rate-limit.test.ts`

**Test Cases**:

```typescript
describe("checkRateLimit", () => {
  describe("free tier", () => {
    it("should allow 25 requests per day", async () => {
      const freeKeyId = await createApiKey("free");

      // Make 25 requests (should all succeed)
      for (let i = 0; i < 25; i++) {
        const result = await checkRateLimit({
          apiKeyId: freeKeyId,
          resource: "contents",
          action: "get",
        });
        expect(result.allowed).toBe(true);
      }

      // 26th should fail
      const result26 = await checkRateLimit({
        apiKeyId: freeKeyId,
        resource: "contents",
        action: "get",
      });
      expect(result26.allowed).toBe(false);
      expect(result26.retryAfter).toBeGreaterThan(0);
    });

    it("should not enforce minute limit", async () => {
      const freeKeyId = await createApiKey("free");

      // Make 150 requests in 1 minute (should all succeed for free tier)
      for (let i = 0; i < 150; i++) {
        await checkRateLimit({
          apiKeyId: freeKeyId,
          resource: "contents",
          action: "get",
        });
      }

      // All should be allowed
      // Free tier has no minute limit
    });
  });

  describe("pro tier", () => {
    it("should allow 100 requests per minute", async () => {
      const proKeyId = await createApiKey("pro");

      // Make 100 requests in 1 minute (should all succeed)
      for (let i = 0; i < 100; i++) {
        const result = await checkRateLimit({
          apiKeyId: proKeyId,
          resource: "contents",
          action: "get",
        });
        expect(result.allowed).toBe(true);
      }

      // 101st request should fail
      const result101 = await checkRateLimit({
        apiKeyId: proKeyId,
        resource: "contents",
        action: "get",
      });
      expect(result101.allowed).toBe(false);
      expect(result101.retryAfter).toBeGreaterThan(0);
      expect(result101.remaining).toBe(0);
    });

    it("should allow 1000 requests per day", async () => {
      const proKeyId = await createApiKey("pro");

      // Make 1000 requests (should all succeed)
      for (let i = 0; i < 1000; i++) {
        await checkRateLimit({
          apiKeyId: proKeyId,
          resource: "contents",
          action: "get",
        });
      }

      // 1001st should fail
      const result1001 = await checkRateLimit({
        apiKeyId: proKeyId,
        resource: "contents",
        action: "get",
      });
      expect(result1001.allowed).toBe(false);
    });
  });

  describe("enterprise tier", () => {
    it("should allow unlimited requests", async () => {
      const enterpriseKeyId = await createApiKey("enterprise");

      // Make 10000 requests (should all succeed)
      for (let i = 0; i < 10000; i++) {
        const result = await checkRateLimit({
          apiKeyId: enterpriseKeyId,
          resource: "contents",
          action: "get",
        });
        expect(result.allowed).toBe(true);
      }
    });
  });

  describe("automatic resets", () => {
    it("should reset daily counter at midnight", async () => {
      const freeKeyId = await createApiKey("free");

      // Make 25 requests at 23:59
      for (let i = 0; i < 25; i++) {
        await checkRateLimit({
          apiKeyId: freeKeyId,
          resource: "contents",
          action: "get",
        });
      }

      // Wait until 00:01 tomorrow
      await sleep(120000); // 2 minutes

      // Next request should reset counter
      const result = await checkRateLimit({
        apiKeyId: freeKeyId,
        resource: "contents",
        action: "get",
      });

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(24); // 25 - 1
    });

    it("should reset minute counter on the minute", async () => {
      const proKeyId = await createApiKey("pro");

      // Make 100 requests
      for (let i = 0; i < 100; i++) {
        await checkRateLimit({
          apiKeyId: proKeyId,
          resource: "contents",
          action: "get",
        });
      }

      // Wait until next minute
      await sleep(61000); // 61 seconds

      // Next request should reset minute counter
      const result = await checkRateLimit({
        apiKeyId: proKeyId,
        resource: "contents",
        action: "get",
      });

      expect(result.allowed).toBe(true);
      expect(result.remaining).toBe(999); // 1000 - 1
    });
  });
});
```

**Coverage**:

- âœ… Free tier: 25/day, no minute limit
- âœ… Pro tier: 100/min, 1000/day
- âœ… Enterprise tier: unlimited
- âœ… Automatic resets (daily, minute)
- âœ… Retry-after calculation
- âœ… Remaining quota tracking

**Output**: Comprehensive test suite

---

### Subtask 2.4.4: Add Documentation

Document rate limiting behavior and tier limits.

**File to create**: `docs/api/rate-limiting.md`

**Content**:

```markdown
# Rate Limiting

## Overview
All API requests are rate limited per API key tier to ensure fair usage and prevent abuse.

## Tiers and Limits

| Tier           | Daily Limit | Minute Limit | Monthly Price |
| -------------- | ----------- | ------------ | ------------- |
| **Free**       | 25          | N/A          | $0            |
| **Pro**        | 1,000       | 100          | $49           |
| **Enterprise** | Unlimited   | Unlimited    | Custom        |

## How Rate Limiting Works

### Daily Limits
- Daily limits reset at **midnight UTC**.
- Counter resets to 0 after reset.
- 24-hour window from first request or midnight (whichever comes first).

### Minute Limits
- Minute limits reset **on the minute**.
- Only applies to Pro tier (Free and Enterprise have no minute limit).
- 1-minute rolling window from first request.

## HTTP Headers

### Response Headers

On successful requests, the API includes these headers:

```

X-RateLimit-Remaining: 23
X-RateLimit-Daily-Limit: 25
X-RateLimit-Minute-Limit: 100

```

On rate limit errors:

```

Retry-After: 3600
X-RateLimit-Remaining: 0

```

### Example Responses

#### Request Within Limit
```http
HTTP/1.1 200 OK
X-RateLimit-Remaining: 23
X-RateLimit-Daily-Limit: 25

{ "contents": [...] }
```

#### Rate Limit Exceeded

```http
HTTP/1.1 429 Too Many Requests
Retry-After: 3600
X-RateLimit-Remaining: 0

{
  "error": "Rate limit exceeded",
  "retryAfter": 3600,
  "remaining": 0
}
```

## Best Practices for Developers

1. **Exponential Backoff**: Retry with increasing delays (1s, 2s, 4s, 8s, 16s)
2. **Check Headers**: Use `X-RateLimit-Remaining` to track quota
3. **Plan Ahead**: Request near `Retry-After` timestamp
4. **Upgrade Tier**: Upgrade for higher limits if needed

## Example: Handling Rate Limits

```typescript
async function fetchWithRetry(slug: string, apiKey: string) {
  const maxRetries = 5;
  let delay = 1000; // Start with 1 second

  for (let attempt = 0; attempt < maxRetries; attempt++) {
    const response = await fetch(`/v1/contents/${slug}`, {
      headers: {
        Authorization: `Bearer ${apiKey}`,
      },
    });

    if (response.status === 429) {
      const retryAfter = response.headers.get("Retry-After");

      if (retryAfter) {
        const waitMs = Number.parseInt(retryAfter) * 1000;
        await sleep(waitMs);
        continue; // Retry after wait
      }
    }

    if (response.ok) {
      return response.json();
    }

    // Rate limit with no retry-after, use backoff
    await sleep(delay);
    delay *= 2; // Exponential backoff
  }

  throw new Error("Max retries exceeded");
}
```

## Monitoring

All rate limit violations are logged and may result in:

- Warning alerts (repeated minor violations)
- API key revocation (severe violations)
- Account review (pattern detection)

## FAQ

**Q: What happens if I exceed the daily limit?**
A: You'll receive a 429 error with `retryAfter` timestamp. Requests made after reset will succeed.

**Q: Do unused requests roll over?**
A: No. Daily limits reset to full at midnight.

**Q: Can I request more than the minute limit?**
A: No. The 100/minute limit is enforced strictly.

**Q: How do I upgrade my tier?**
A: Contact support or use the API key management dashboard.

```

**Output**: Developer documentation

---

## ðŸš€ Next Steps
After completing this task:
1. **Next task**: Task 2.5 - Create API Key Management Endpoints
2. **Phase 2**: Continue building public API

## ðŸ”— Related Tasks
- Task 2.1: Create Content List Endpoint (uses this rate limiting)
- Task 2.2: Create Content Get Endpoint (uses this rate limiting)
- Task 2.3: Create Content Search Endpoint (uses this rate limiting)
- Task 4.2: Implement IP-Based Rate Limiting (additional layer on top of this)
- Task 4.3: Add Request Signature Verification (additional security layer)

## âš ï¸ Important Notes

### Rate Limit Strategy
- **Denormalized table**: `apiKeyUsage` provides O(1) lookups
- **Auto-reset**: No background jobs needed, resets happen automatically
- **Efficient**: Single DB query + patch per request

### DX Considerations
- **Clear headers**: `Retry-After`, `X-RateLimit-Remaining` for client-side tracking
- **Specific errors**: Different messages for daily vs minute limit exceeded
- **Good retry guidance**: Document exponential backoff pattern

### Enterprise Tier
- **Unlimited but monitored**: Still logged to `contentAccessLog`
- **Abuse detection**: Can still be revoked for scraping patterns
- **Fair usage**: Monitored via dashboard (Phase 5)

### Future Enhancements
- Consider adding `burst` allowance (allow short bursts beyond limits)
- Consider adding `quota reset` webhook (notify when quota resets)
- Consider adding `usage history` endpoint (last 7 days of usage)
