# Task 3.1: Add User Token Auth to MCP Transport Layer

## üéØ Goal

Add user authentication to MCP server transport layer so only authenticated users can access content.

## üìç Context

This is **Phase 3.1** of Secure MCP Server phase.

Currently, MCP tools (`get_contents`, `get_content`) call **unauthenticated** `/contents/*` endpoints. After Phase 1, these endpoints require internal API key, so MCP tools will break.

MCP should:

1. **Require user authentication** via Better Auth session token
2. **Get user's subscription tier** (Free, Pro, Enterprise)
3. **Pass user context** to tools
4. **Route to public `/v1/contents`** instead of internal `/contents/*`

## üé¨ Success Criteria

- [ ] MCP transport layer validates user session token
- [ ] User's subscription tier retrieved and stored in context
- [ ] Unauthenticated requests return 401
- [ ] User context passed to tool handlers
- [ ] Rate limits applied based on user's tier
- [ ] MCP uses public API instead of internal endpoints

## üìù Subtasks

### Subtask 3.1.1: Create MCP Auth Middleware

Create authentication middleware for MCP transport.

**File to create**: `apps/mcp/lib/auth-middleware.ts`

**Implementation**:

```typescript
import type { Middleware } from "mcp-handler";
import { api as convexApi } from "@repo/backend/convex/_generated/api";
import type { Id } from "@repo/backend/convex/_generated/dataModel";
import { HTTP_UNAUTHORIZED } from "@repo/connection/types";

export interface MCPAuthContext {
  userId: Id<"users">;
  subscriptionTier: "free" | "pro" | "enterprise";
  apiKeyId: Id<"apikey">; // For rate limiting
}

/**
 * MCP authentication middleware.
 * Validates user session token and loads user context.
 */
export const mcpAuth: Middleware<MCPAuthContext> = async (c, next) => {
  // 1. Extract user token from MCP transport headers
  const authHeader = c.req.header("Authorization");

  if (!authHeader) {
    return c.json(
      {
        jsonrpc: "2.0",
        id: c.req.id,
        error: {
          code: -32600,
          message: "Unauthorized: Missing Authorization header",
        },
      },
      { status: HTTP_UNAUTHORIZED }
    );
  }

  if (!authHeader.startsWith("Bearer ")) {
    return c.json(
      {
        jsonrpc: "2.0",
        id: c.req.id,
        error: {
          code: -32600,
          message: "Unauthorized: Invalid Authorization format. Use: Bearer <token>",
        },
      },
      { status: HTTP_UNAUTHORIZED }
    );
  }

  const token = authHeader.slice(7); // Remove "Bearer " prefix

  // 2. Validate user session token with Better Auth
  const authResult = await c.env.runMutation(
    convexApi.betterAuth.mutations.validateSession,
    { token }
  );

  if (!authResult.valid || !authResult.userId) {
    return c.json(
      {
        jsonrpc: "2.0",
        id: c.req.id,
        error: {
          code: -32600,
          message: "Unauthorized: Invalid or expired session token",
        },
      },
      { status: HTTP_UNAUTHORIZED }
    );
  }

  // 3. Load user's subscription tier and API key
  const user = await c.env.runQuery(
    convexApi.users.queries.getUserById,
    { userId: authResult.userId }
  );

  if (!user) {
    return c.json(
      {
        jsonrpc: "2.0",
        id: c.req.id,
        error: {
          code: -32602,
          message: "User not found",
        },
      },
      { status: 404 }
    );
  }

  // Get user's API key for rate limiting (or create if not exists)
  const apiKeyId = user.activeApiKeyId;
  let apiKeyIdToUse: Id<"apikey">;

  if (!apiKeyId) {
    // Generate new API key for MCP usage
    const newApiKey = await c.env.runMutation(
      internal.apikeys.mutations.createApiKey,
      {
        userId: user._id,
        tier: user.subscriptionTier || "free",
        rateLimitDaily: user.subscriptionTier === "free" ? 25 : user.subscriptionTier === "pro" ? 1000 : null,
        rateLimitMinute: user.subscriptionTier === "pro" ? 100 : null,
      }
    );

    apiKeyIdToUse = newApiKey._id;
  } else {
    apiKeyIdToUse = apiKeyId;
  }

  // 4. Store user context for tool handlers
  const subscriptionTier = user.subscriptionTier || "free";

  c.set("userId", authResult.userId);
  c.set("subscriptionTier", subscriptionTier);
  c.set("apiKeyId", apiKeyIdToUse);

  // 5. Pass control to next middleware
  await next();
};
```

**Features**:

- **Session validation**: Uses Better Auth to validate tokens
- **Tier detection**: Loads user's subscription from database
- **API key mapping**: Maps user to API key for rate limiting
- **Auto-provisioning**: Creates API key if user doesn't have one
- **Clean error responses**: MCP JSON-RPC 2.0 format

**Output**: MCP auth middleware

---

### Subtask 3.1.2: Integrate Auth into MCP Transport

Apply auth middleware to MCP transport handler.

**File to modify**: `apps/mcp/app/[transport]/route.ts`

**Implementation**:

```typescript
import { createMcpHandler } from "mcp-handler";
import { env } from "@/env";
import type { GetContentsParams } from "@/lib/schema";
import { tools } from "@/lib/tools";
import { buildContentSlug } from "@/lib/utils";
import { mcpAuth } from "@/lib/auth-middleware"; // NEW: Import auth middleware

const handler = createMcpHandler(
  (server) => {
    server.registerTool(
      "get_contents",
      {
        title: tools.getContents.name,
        description: tools.getContents.description,
        inputSchema: tools.getContents.parameters,
      },
      async ({ locale, filters }: GetContentsParams, { toolCallId }) => {
        // NEW: Get user context from middleware
        const userId = server.getUser("userId");
        const apiKeyId = server.getUser("apiKeyId");
        const tier = server.getUser("subscriptionTier");

        // NEW: Use user's API key for rate limiting
        const { data, error } = await api.contents.getContents({
          slug: buildContentSlug({ locale, filters }),
          apiKeyId, // NEW: Pass API key
        });

        if (error) {
          return {
            content: [
              {
                type: "text",
                text: `Error: ${error.message}`,
              },
            ],
          };
        }

        const contents = data?.map((item) => ({
          ...item.metadata,
          url: item.url,
          slug: item.slug,
        })) || [];

        if (contents.length === 0) {
          return {
            content: [
              {
                type: "text",
                text: "No contents found. Please try again with different parameters.",
              },
            ],
          };
        }

        return {
          content: [
            {
              type: "text",
              text: `Found ${contents.length} contents:\n\n${JSON.stringify(contents, null, 2)}`,
            },
          ],
        };
      }
    );

    server.registerTool(
      "get_content",
      {
        title: tools.getContent.name,
        description: tools.getContent.description,
        inputSchema: tools.getContent.parameters,
      },
      async ({ slug }: { slug }, { toolCallId }) => {
        // NEW: Get user context
        const userId = server.getUser("userId");
        const apiKeyId = server.getUser("apiKeyId");

        // NEW: Use user's API key for rate limiting
        const { data, error } = await api.contents.getContent({
          slug,
          apiKeyId, // NEW: Pass API key
        });

        if (error) {
          return {
            content: [
              {
                type: "text",
                text: `Error: ${error.message}. You can try to get the slug from the 'get_contents' tool.`,
              },
            ],
          };
        }

        if (!data) {
          return {
            content: [
              {
                type: "text",
                text: "Content not found. You can try to get the slug from the 'get_contents' tool.",
              },
            ],
          };
        }

        return {
          content: [
            {
              type: "text",
              text: `Found content:\n\n${data.raw}`,
            },
          ],
        };
      }
    );
  },
  {
    capabilities: {
      tools: {
        listChanged: true,
      },
    },
    {
      redisUrl: env.REDIS_URL,
      basePath: "",
      verboseLogs: true,
      maxDuration: 60,
    }
);

// NEW: Apply auth middleware to handler
export const GET = handler;
export const POST = handler;
export const DELETE = handler;
```

**Key Changes**:

- Import `mcpAuth` middleware
- Apply middleware to MCP handler
- Extract `userId`, `apiKeyId`, `subscriptionTier` from context
- Pass `apiKeyId` to API calls (for rate limiting)

**Output**: Authenticated MCP transport

---

### Subtask 3.1.3: Update packages/connection/fetcher for Public API

Support passing user's API key to public API calls.

**File to modify**: `packages/connection/lib/fetcher.ts`

**Implementation**:

```typescript
export async function fetcher<T>({
  url,
  endpoint,
  options,
  useInternalAuth,
  apiKey, // NEW: For public API calls with user's key
}: {
  url?: string;
  endpoint: string;
  options: RequestInit;
  useInternalAuth?: boolean;
  apiKey?: string | Id<"apikey">; // NEW
}): Promise<FetchResult<T | null>> {
  const baseUrl = url ?? (await getBaseUrl());

  const headers: HeadersInit = {
    ...options.headers,
  };

  // NEW: Add user's API key if provided
  if (useInternalAuth) {
    const internalApiKey = process.env.INTERNAL_CONTENT_API_KEY;
    if (!internalApiKey) {
      throw new Error("INTERNAL_CONTENT_API_KEY not configured");
    }
    headers["Authorization"] = `Bearer ${internalApiKey}`;
  } else if (apiKey) {
    headers["Authorization"] = `Bearer ${apiKey}`;
  }

  try {
    const response = await ky<T>(`${baseUrl}${endpoint}`, {
      ...options,
      headers, // Use merged headers with auth
    }).json();

    return { data: response, error: null };
  } catch (error) {
    // ... existing error handling
  }
}
```

**Changes**:

- **New parameter**: `apiKey` for passing user's API key
- **Existing preserved**: `useInternalAuth` still works for internal calls
- **Flexible**: Supports both internal and public API auth

**Output**: Enhanced fetcher

---

### Subtask 3.1.4: Create User API Key Query

Add query to get or create user's API key for MCP usage.

**File to create**: `packages/backend/convex/users/queries.ts` (or new file)

**Implementation**:

```typescript
import { query } from "../_generated/server";

export const getUserApiKey = query({
  args: {},
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();

    if (!identity?.subject || !identity.email) {
      return null;
    }

    const appUser = await ctx.db
      .query("users")
      .withIndex("email")
      .eq("email", identity.email)
      .unique();

    if (!appUser) {
      return null;
    }

    // Check if user has active API key
    const existingKey = await ctx.db
      .query("apikey")
      .withIndex("userId_enabled")
      .eq("userId", appUser._id)
      .eq("enabled", true)
      .first();

    return existingKey;
  },
});
```

**Purpose**:

- Returns user's active API key (for rate limiting)
- Used in MCP auth middleware
- Auto-provisions key if doesn't exist (Task 3.1.1)

**Output**: User API key query

---

### Subtask 3.1.5: Add Unit Tests

Test MCP authentication and authorization.

**File to create**: `apps/mcp/lib/__tests__/auth-middleware.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { mcpAuth } from "../auth-middleware";
import { HTTP_UNAUTHORIZED } from "@repo/connection/types";

describe("MCP Auth Middleware", () => {
  let mockC: any;
  let mockEnv: any;

  beforeEach(() => {
    mockC = {
      req: {
        header: vi.fn(),
      },
      json: vi.fn(),
      set: vi.fn(),
      env: {
        runMutation: vi.fn(),
        runQuery: vi.fn(),
      },
    };

    mockEnv = {
      apiKeys: {
        createApiKey: vi.fn().mockResolvedValue({
          _id: "test-key-id",
        }),
      },
    };

    vi.mock("@repo/backend/convex/_generated/api", () => ({
      betterAuth: {
        mutations: {
          validateSession: vi.fn(),
        },
      },
      apikeys: {
        createApiKey: mockEnv.apiKeys.createApiKey,
      },
    }));
  });

  describe("authentication", () => {
    it("should reject missing Authorization header", async () => {
      mockC.req.header.mockReturnValue(null);

      const result = await mcpAuth(mockC, vi.fn());

      expect(mockC.json).toHaveBeenCalledWith(
        expect.objectContaining({
          status: HTTP_UNAUTHORIZED,
          body: expect.objectContaining({
            error: expect.objectContaining({
              code: -32600,
              message: expect.stringContaining("Missing Authorization"),
            }),
          }),
        })
      );
    });

    it("should reject invalid Authorization format", async () => {
      mockC.req.header.mockReturnValue("Invalid");

      const result = await mcpAuth(mockC, vi.fn());

      expect(mockC.json).toHaveBeenCalledWith(
        expect.objectContaining({
          status: HTTP_UNAUTHORIZED,
        })
      );
    });

    it("should reject invalid session token", async () => {
      mockC.req.header.mockReturnValue("Bearer invalid-token");

      const result = await mcpAuth(mockC, vi.fn());

      expect(mockC.json).toHaveBeenCalledWith(
        expect.objectContaining({
          status: HTTP_UNAUTHORIZED,
        })
      );
    });
  });

  describe("user context loading", () => {
    it("should load user's subscription tier", async () => {
      mockC.req.header.mockReturnValue("Bearer valid-token");

      const result = await mcpAuth(mockC, vi.fn());

      expect(mockC.set).toHaveBeenCalledWith("subscriptionTier", expect.anything());
      expect(mockC.set).toHaveBeenCalledWith("apiKeyId", expect.anything());
    });

    it("should auto-provision API key if user doesn't have one", async () => {
      mockC.req.header.mockReturnValue("Bearer valid-token");

      const result = await mcpAuth(mockC, vi.fn());

      expect(mockEnv.apiKeys.createApiKey).toHaveBeenCalledWith(
        expect.objectContaining({
          tier: expect.anything(),
        })
      );
    });
  });

  describe("MCP transport integration", () => {
    it("should pass user context to tool handlers", async () => {
      // Test that tools can access user context
      const mockServer = {
        getUser: vi.fn(),
        registerTool: vi.fn(),
      };

      // Simulate auth middleware setting context
      const mockC = {
        req: { header: vi.fn().mockReturnValue("Bearer valid") },
        json: vi.fn(),
        set: vi.fn(),
        env: mockEnv,
      };

      await mcpAuth(mockC, vi.fn());

      // Verify context was set
      expect(mockC.set).toHaveBeenCalledWith("userId", expect.anything());
      expect(mockC.set).toHaveBeenCalledWith("subscriptionTier", expect.anything());
    });
  });
});
```

**Coverage**:

- ‚úÖ Missing/invalid auth header rejected
- ‚úÖ Invalid session token rejected
- ‚úÖ User subscription tier loaded
- ‚úÖ API key auto-provisioned if missing
- ‚úÖ Context passed to MCP server

**Output**: Comprehensive test suite

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 3.2 - Route MCP Tools to /v1/contents
2. **Phase 3**: Continue securing MCP server

## üîó Related Tasks

- Task 1.2: Apply Internal Auth to Content Routes (internal API key used by internal fetcher)
- Task 3.2: Route MCP Tools to /v1/contents (tools use public API now)
- Task 2.5: Create API Key Management Endpoints (users can manage keys here)
- Task 2.4: Implement Tiered Rate Limiting (applies to MCP requests)

## ‚ö†Ô∏è Important Notes

### Authentication Flow

```
User Login ‚Üí Better Auth Session ‚Üí MCP Transport Auth ‚Üí User Context ‚Üí Tool Handlers
```

1. **User logs in** to nakafa.com (Better Auth)
2. **User connects MCP client** with session token
3. **MCP transport validates** token with Better Auth
4. **User's subscription tier** retrieved from database
5. **User's API key** loaded (or created)
6. **Context passed** to tool handlers
7. **Tools use user's API key** to call `/v1/contents`

### Rate Limiting

- MCP requests **inherit user's tier** rate limits
- Free tier users: 25/day total (via MCP + other API usage)
- Pro tier users: 100/min, 1000/day total
- Enterprise: Unlimited but monitored

### Security

- MCP authentication required (no anonymous access)
- User can only access their own content (via tier)
- API key validation happens in public API layer
- All MCP requests logged via `contentAccessLog`

### DX Considerations

- **Seamless**: User logs in once, MCP uses existing session
- **Transparent**: Tools work same as before, just different auth
- **Good DX**: Clear error messages if token invalid/expired

### Future Enhancements

- Consider adding `rateLimitInfo` to MCP tool responses
- Consider adding `quotaRemaining` to tool responses
- Consider caching frequently accessed content per user
- Consider adding MCP-specific rate limits (per connection)
