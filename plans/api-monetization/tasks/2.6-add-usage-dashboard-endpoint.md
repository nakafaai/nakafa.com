# Task 2.6: Add Usage Dashboard Endpoint

## üéØ Goal

Create `/v1/me/usage` endpoint for developers to monitor their API quota and remaining requests.

## üìç Context

This is **Phase 2.6** of Build Public Content API phase.

Developers need visibility into their API usage to:

1. **Plan ahead**: See remaining quota before hitting limits
2. **Debug issues**: Check if requests are being counted correctly
3. **Upgrade decisions**: Decide when to upgrade tiers
4. **Cost management**: Estimate usage for budgeting

This endpoint provides:

- Current tier information
- Requests used today and this minute
- Daily/minute limits
- Remaining quota
- Reset timestamps

## üé¨ Success Criteria

- [ ] `/v1/me/usage` endpoint created
- [ ] Requires API key authentication
- [ ] Returns tier information
- [ ] Returns current usage metrics
- [ ] Returns remaining quota
- [ ] Returns reset timestamps
- [ ] Returns proper HTTP codes (200, 401)

## üìù Subtasks

### Subtask 2.6.1: Define Usage Response Schema

Create TypeScript interface for usage information.

**File to create**: `packages/backend/convex/routes/v1/me/usage/types.ts`

**Implementation**:

```typescript
export interface UsageResponse {
  tier: "free" | "pro" | "enterprise";
  limits: {
    daily: number | null; // null = unlimited
    minute: number | null; // null = unlimited
  };
  usage: {
    requestsToday: number;
    requestsThisMinute: number;
    lastRequestTime: number;
  };
  resets: {
    dailyResetAt: number; // ISO 8601 timestamp
    minuteResetAt: number; // ISO 8601 timestamp
  };
  remaining: {
    daily: number | null; // null = unlimited
    minute: number | null; // null = unlimited
  };
}
```

**Why Separate Objects?**

- **Clear structure**: Limits, usage, resets, remaining are distinct concerns
- **Extensible**: Easy to add new metrics (monthly, by-endpoint, etc.)
- **Type-safe**: Each object has specific types

**Output**: Type-safe interface

---

### Subtask 2.6.2: Implement Route Handler

Create `/v1/me/usage` GET route.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { requireApiKey } from "../middleware/auth";
import { HTTP_OK } from "../constants";

// GET /v1/me/usage - Get API usage and quota
v1.get("/me/usage", requireApiKey(), async (c) => {
  const userId = c.get("userId");
  const apiKeyId = c.get("apiKeyId");

  // Get API key details
  const apiKey = await c.env.runQuery(
    internal.betterAuth.queries.getApiKeyById,
    { keyId: apiKeyId }
  );

  if (!apiKey) {
    return c.json(
      { error: "API key not found" },
      { status: 404 }
    );
  }

  // Get usage data
  const usage = await c.env.runQuery(
    internal.apikeys.queries.getApiKeyUsage,
    { keyId: apiKeyId }
  );

  const tier = apiKey.subscriptionTier || "free";
  const limits = TIER_LIMITS[tier];

  // Calculate remaining
  let dailyRemaining: number | null;
  let minuteRemaining: number | null;

  if (limits.rateLimitDaily) {
    dailyRemaining = Math.max(0, limits.rateLimitDaily - (usage?.requestsToday || 0));
  }

  if (limits.rateLimitMinute) {
    minuteRemaining = Math.max(
      0,
      (limits.rateLimitMinute - (usage?.requestsThisMinute || 0))
    );
  }

  // Build response
  const response: UsageResponse = {
    tier,
    limits: {
      daily: limits.rateLimitDaily,
      minute: limits.rateLimitMinute,
    },
    usage: {
      requestsToday: usage?.requestsToday || 0,
      requestsThisMinute: usage?.requestsThisMinute || 0,
      lastRequestTime: usage?.lastRequestTime || 0,
    },
    resets: {
      dailyResetAt: new Date(usage?.dailyResetTime || Date.now()).toISOString(),
      minuteResetAt: new Date(usage?.minuteResetTime || Date.now()).toISOString(),
    },
    remaining: {
      daily: dailyRemaining,
      minute: minuteRemaining,
    },
  };

  return c.json(response, { status: HTTP_OK });
});

const TIER_LIMITS = {
  free: {
    rateLimitDaily: 25,
    rateLimitMinute: null,
  },
  pro: {
    rateLimitDaily: 1000,
    rateLimitMinute: 100,
  },
  enterprise: {
    rateLimitDaily: null, // Unlimited
    rateLimitMinute: null, // Unlimited
  },
} as const;
```

**Features**:

- **Real-time**: Current usage always accurate
- **Clear resets**: ISO 8601 timestamps for easy display
- **Remaining quota**: Easy to calculate time left
- **Tier limits**: Shows daily/minute limits clearly

**Output**: Functional route handler

---

### Subtask 2.6.3: Add Unit Tests

Test usage dashboard across all tiers.

**File to create**: `packages/backend/convex/routes/__tests__/me-usage.test.ts`

**Test Cases**:

```typescript
describe("GET /v1/me/usage", () => {
  describe("free tier", () => {
    it("should show 25 daily limit", async () => {
      const response = await api.v1.me.usage({ apiKeyId: freeKeyId });

      expect(response.tier).toBe("free");
      expect(response.limits.daily).toBe(25);
      expect(response.limits.minute).toBe(null);
    });

    it("should show remaining daily requests", async () => {
      // Make 10 requests
      for (let i = 0; i < 10; i++) {
        await api.v1.contents.list({}, { apiKeyId: freeKeyId });
      }

      const response = await api.v1.me.usage({ apiKeyId: freeKeyId });

      expect(response.usage.requestsToday).toBe(10);
      expect(response.remaining.daily).toBe(15);
    });
  });

  describe("pro tier", () => {
    it("should show 1000 daily and 100 minute limits", async () => {
      const response = await api.v1.me.usage({ apiKeyId: proKeyId });

      expect(response.tier).toBe("pro");
      expect(response.limits.daily).toBe(1000);
      expect(response.limits.minute).toBe(100);
    });

    it("should calculate remaining minute quota", async () => {
      // Make 50 requests in 1 minute
      for (let i = 0; i < 50; i++) {
        await api.v1.contents.list({}, { apiKeyId: proKeyId });
      }

      const response = await api.v1.me.usage({ apiKeyId: proKeyId });

      expect(response.usage.requestsThisMinute).toBe(50);
      expect(response.remaining.minute).toBe(50);
    });

    it("should show no minute remaining for enterprise", async () => {
      const response = await api.v1.me.usage({ apiKeyId: enterpriseKeyId });

      expect(response.tier).toBe("enterprise");
      expect(response.limits.minute).toBe(null);
      expect(response.remaining.minute).toBe(null);
    });
  });

  describe("enterprise tier", () => {
    it("should show unlimited limits", async () => {
      const response = await api.v1.me.usage({ apiKeyId: enterpriseKeyId });

      expect(response.tier).toBe("enterprise");
      expect(response.limits.daily).toBe(null);
      expect(response.limits.minute).toBe(null);
      expect(response.remaining.daily).toBe(null);
      expect(response.remaining.minute).toBe(null);
    });
  });

  describe("reset timestamps", () => {
    it("should show daily reset time", async () => {
      const response = await api.v1.me.usage({ apiKeyId: testApiKey });

      expect(response.resets.dailyResetAt).toBeDefined();
      const resetTime = new Date(response.resets.dailyResetAt);

      expect(resetTime.getHours()).toBe(0); // Midnight UTC
      expect(resetTime.getMinutes()).toBe(0);
      expect(resetTime.getSeconds()).toBe(0);
    });
  });
});
```

**Coverage**:

- ‚úÖ All tier limits displayed correctly
- ‚úÖ Usage metrics accurate
- ‚úÖ Remaining calculations correct
- ‚úÖ Reset timestamps valid ISO 8601
- ‚úÖ Enterprise shows unlimited

**Output**: Comprehensive test suite

---

### Subtask 2.6.4: Add API Documentation

Document usage dashboard for developers.

**File to create**: `docs/api/usage-dashboard.md`

**Content**:

```markdown
# Usage Dashboard

## Endpoint
`GET /v1/me/usage`

## Description
Retrieves your API usage metrics, rate limits, and remaining quota for your API key.

## Authentication
Requires valid API key via `Authorization: Bearer <key>` header.

## Response Structure

```json
{
  "tier": "pro",
  "limits": {
    "daily": 1000,
    "minute": 100
  },
  "usage": {
    "requestsToday": 45,
    "requestsThisMinute": 2,
    "lastRequestTime": 1705228800000
  },
  "resets": {
    "dailyResetAt": "2026-01-15T00:00:00.000Z",
    "minuteResetAt": "2026-01-14T10:15:00.000Z"
  },
  "remaining": {
    "daily": 955,
    "minute": 98
  }
}
```

## Fields

| Field | Type | Description |
| ----- | ---- | ----------- ||
| `tier`                     | string          | Current subscription tier (`free`, `pro`, `enterprise`) |
| `limits.daily`             | integer or null | Maximum requests per day (null = unlimited)             |
| `limits.minute`            | integer or null | Maximum requests per minute (null = unlimited)          |
| `usage.requestsToday`      | integer         | Requests made today (resets at midnight)                |
| `usage.requestsThisMinute` | integer         | Requests made this minute (resets on minute)            |
| `usage.lastRequestTime`    | integer         | Unix timestamp of last request                          |
| `resets.dailyResetAt`      | ISO 8601        | Time when daily counter resets (midnight UTC)           |
| `resets.minuteResetAt`     | ISO 8601        | Time when minute counter resets (next minute)           |
| `remaining.daily`          | integer or null | Requests remaining today (null = unlimited)             |
| `remaining.minute`         | integer or null | Requests remaining this minute (null = unlimited)       |

## Tiers and Limits

| Tier       | Daily Limit | Minute Limit |
| ---------- | ----------- | ------------ |
| Free       | 25          | N/A          |
| Pro        | 1,000       | 100          |
| Enterprise | Unlimited   | Unlimited    |

## Example Request

```bash
curl "https://api.nakafa.com/v1/me/usage" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

## Calculating Remaining Time

### Daily Remaining

```javascript
const now = Date.now();
const resetTime = new Date(response.resets.dailyResetAt).getTime();
const remainingMs = resetTime - now;
const remainingSeconds = Math.floor(remainingMs / 1000);
const remainingMinutes = Math.floor(remainingSeconds / 60);
const remainingHours = Math.floor(remainingMinutes / 60);

console.log(`Resets in ${remainingHours}h ${remainingMinutes % 60}m`);
```

### Minute Remaining

```javascript
const now = Date.now();
const resetTime = new Date(response.resets.minuteResetAt).getTime();
const remainingMs = resetTime - now;
const remainingSeconds = Math.floor(remainingMs / 1000);

console.log(`Resets in ${remainingSeconds}s`);
```

## Usage Patterns

### Monitoring Your Usage

1. **Check Before Busy Operations**:

   ```typescript
   const usage = await api.v1.me.usage();
   if (usage.remaining.daily < 10) {
     console.warn("Running low on daily quota");
   }
   ```

2. **Plan Heavy Operations**:

   ```typescript
   // If you need 500 requests, upgrade to Pro tier
   // Free tier: 25/day
   // Pro tier: 1,000/day (40x more)
   ```

3. **Implement Retry Logic**:

   ```typescript
   async function makeRequest(url: string) {
     const usage = await api.v1.me.usage();

     if (usage.remaining.daily === 0) {
       const resetTime = new Date(usage.resets.dailyResetAt).getTime();
       const now = Date.now();
       const waitMs = resetTime - now;

       if (waitMs > 0) {
         console.log(`Waiting ${waitMs}ms until reset`);
         await sleep(waitMs);
       }
     }

     return await fetch(url);
   }
   ```

4. **Handle Rate Limit Errors**:

   ```typescript
   const response = await fetch(url, {
     headers: { "Authorization": `Bearer ${apiKey}` }
   });

   if (response.status === 429) {
     const retryAfter = response.headers.get("Retry-After");

     if (retryAfter) {
       console.log(`Rate limited. Retry after ${retryAfter}s`);
       await sleep(Number.parseInt(retryAfter) * 1000);
       // Retry request
     }
   }
   ```

## Error Responses

### 401 Unauthorized

```json
{
  "error": "Missing or invalid API key"
}
```

### 404 Not Found

```json
{
  "error": "API key not found"
}
```

## Best Practices

1. **Poll Sparingly**: Check usage every 1-5 minutes, not every request
2. **Cache Results**: Usage response is small, cache for 30 seconds
3. **Handle Resets**: Plan operations around reset times
4. **Upgrade Wisely**: If consistently hitting limits, upgrade tier
5. **Monitor Last Request**: Helps debug issues if requests aren't counting

## FAQ

**Q: Does this endpoint count toward my rate limit?**
A: No. This is a read-only endpoint.

**Q: When do limits reset?**
A: Daily limits reset at midnight UTC. Minute limits reset on the minute (e.g., 00:00, 00:01, etc.)

**Q: Can I see historical usage?**
A: Not currently. This endpoint shows current day's usage only. Historical endpoint coming in future releases.

**Q: How accurate are the counters?**
A: Real-time. Every request updates counters immediately.

**Q: What happens if I upgrade tier?**
A: Limits and remaining quota update immediately. Historical usage is preserved.
`

```

**Output**: Developer documentation

---

## üöÄ Next Steps
After completing this task:
1. **Phase 2 Complete**: All public API endpoints built
2. **Next phase**: Task 3.1 - Add User Token Auth to MCP Transport Layer

## üîó Related Tasks
- Task 2.4: Implement Tiered Rate Limiting (uses `apiKeyUsage` table this reads)
- Task 2.5: Create API Key Management Endpoints (keys this monitors)
- Task 4.1: Implement Velocity-Based Scraping Detection (uses `contentAccessLog` data)

## ‚ö†Ô∏è Important Notes

### DX Considerations
- **Real-time**: Usage is always up-to-date
- **Clear structure**: Nested objects make response easy to navigate
- **ISO 8601**: Standard timestamp format for all languages
- **Remaining quota**: Easy to calculate time left

### Performance
- **Fast query**: Single `apiKeyUsage` lookup (O(log n))
- **No aggregation**: Counter already denormalized
- **Light response**: ~500 bytes typical size

### Monitoring
- Developers can poll this endpoint
- Dashboard UI can use this data (Phase 5)
- Rate limit violations logged in `contentAccessLog`

### Future Enhancements
- Consider adding `usage history` endpoint (last 30 days)
- Consider adding `usage by endpoint` breakdown
- Consider adding `top content accessed` (most popular content)
- Consider adding `usage charts` pre-calculated data
