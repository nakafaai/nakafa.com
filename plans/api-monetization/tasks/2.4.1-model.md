# Task 2.4.1: Rate Limit Model

## Goal

Create rate limit helper functions following Convex best practices.

## Context

Rate limiting needs:
- O(1) lookups per API key
- Automatic counter resets
- Tier-based limits
- Helper functions in model directory

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

## PRD
```json
{
  "category": "architecture",
  "description": "Rate limit helper functions with O(1) lookups",
  "steps": [
    "Create rate limit constants",
    "Create checkRateLimit helper function",
    "Create getTierLimits helper function",
    "Add unit tests"
  ],
  "passes": false
}
```

## Success

- [ ] `TIER_LIMITS` constants defined
- [ ] `checkRateLimit()` helper created
- [ ] `getTierLimits()` helper created
- [ ] Proper `v.object()` validators
- [ ] Tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 2.4.1.1: Create Tier Limits

**File**: `packages/backend/convex/model/rateLimit.ts`

**Implementation**:

```typescript
import { v } from "convex/values";

export const TIER_LIMITS = {
  free: {
    rateLimitDaily: 25,
    rateLimitMinute: null,
  },
  pro: {
    rateLimitDaily: 1000,
    rateLimitMinute: 100,
  },
  enterprise: {
    rateLimitDaily: null,
    rateLimitMinute: null,
  },
} as const;

export type SubscriptionTier = "free" | "pro" | "enterprise";
export type TierLimits = typeof TIER_LIMITS[keyof typeof TIER_LIMITS];

export function getTierLimits(tier: SubscriptionTier): TierLimits {
  return TIER_LIMITS[tier];
}
```

**Output**: Tier limits constants

---

### Subtask 2.4.1.2: Create Check Rate Limit Function

**File**: `packages/backend/convex/model/rateLimit.ts`


**Implementation**:

```typescript
import { v } from "convex/values";
import type { Id } from "../_generated/dataModel";

export interface RateLimitCheckResult {
  allowed: boolean;
  retryAfter?: number;
  remaining?: number;
}

export interface RateLimitCheckArgs {
  apiKeyId: Id<"apikey">;
  resource: string;
  action: string;
}

export function checkRateLimitHelper(ctx: any, args: RateLimitCheckArgs): RateLimitCheckResult {
  const { apiKeyId, resource, action } = args;

  const apiKey = await ctx.db.get("apikey", apiKeyId);

  if (!apiKey || apiKey.enabled !== true) {
    return { allowed: false, retryAfter: 0 };
  }

  const tier = apiKey.subscriptionTier || "free";
  const limits = getTierLimits(tier);
  const now = Date.now();

  const tomorrow = getMidnight(now);
  const nextMinute = getStartOfNextMinute(now);

  const usage = await ctx.db
    .query("apiKeyUsage")
    .withIndex("apiKeyId")
    .eq("apiKeyId", apiKeyId)
    .unique();

  if (!usage) {
    await ctx.db.insert("apiKeyUsage", {
      apiKeyId,
      requestsToday: 1,
      requestsThisMinute: 1,
      lastRequestTime: now,
      dailyResetTime: tomorrow,
      minuteResetTime: nextMinute,
    });

    return {
      allowed: true,
      remaining: limits.rateLimitDaily ? limits.rateLimitDaily - 1 : null,
    };
  }

  const needsDailyReset = now >= usage.dailyResetTime;
  const needsMinuteReset = now >= usage.minuteResetTime;

  const requestsToday = needsDailyReset ? 1 : usage.requestsToday + 1;
  const requestsThisMinute = needsMinuteReset ? 1 : usage.requestsThisMinute + 1;

  let dailyExceeded = false;
  let minuteExceeded = false;

  if (limits.rateLimitDaily) {
    dailyExceeded = requestsToday > limits.rateLimitDaily;
  }

  if (limits.rateLimitMinute) {
    minuteExceeded = requestsThisMinute > limits.rateLimitMinute;
  }

  let retryAfter: number | undefined;

  if (dailyExceeded) {
    retryAfter = Math.ceil((usage.dailyResetTime - now) / 1000);
  } else if (minuteExceeded) {
    retryAfter = Math.ceil((usage.minuteResetTime - now) / 1000);
  }

  if (dailyExceeded || minuteExceeded) {
    return {
      allowed: false,
      retryAfter,
      remaining: 0,
    };
  }

  await ctx.db.patch("apiKeyUsage", usage._id, {
    requestsToday,
    requestsThisMinute,
    lastRequestTime: now,
    dailyResetTime: needsDailyReset ? tomorrow : usage.dailyResetTime,
    minuteResetTime: needsMinuteReset ? nextMinute : usage.minuteResetTime,
  });

  return {
    allowed: true,
    remaining: limits.rateLimitDaily ? limits.rateLimitDaily - requestsToday : null,
  };
}

function getMidnight(now: number): number {
  const date = new Date(now);
  date.setHours(23, 59, 59, 999);
  return date.getTime();
}

function getStartOfNextMinute(now: number): number {
  const date = new Date(now);
  date.setSeconds(0, 0);
  date.setMinutes(date.getMinutes() + 1);
  return date.getTime();
}
```


**Output**: Rate limit helper

---

### Subtask 2.4.1.3: Add Tests

**File**: `packages/backend/convex/model/__tests__/rateLimit.test.ts`

**Tests**:

```typescript
import { describe, it, expect } from "vitest";
import { checkRateLimitHelper, getTierLimits } from "../rateLimit";

describe("checkRateLimitHelper", () => {
  it("should allow 25 requests for free tier", async () => {
    const result = await checkRateLimitHelper(ctx, {
      apiKeyId: freeKeyId,
      resource: "contents",
      action: "get",
    });

    expect(result.allowed).toBe(true);
    expect(result.remaining).toBe(24);
  });

  it("should enforce pro tier limit (100/min)", async () => {
    for (let i = 0; i < 100; i++) {
      await checkRateLimitHelper(ctx, {
        apiKeyId: proKeyId,
        resource: "contents",
        action: "get",
      });
    }

    const result = await checkRateLimitHelper(ctx, {
      apiKeyId: proKeyId,
      resource: "contents",
      action: "get",
    });

    expect(result.allowed).toBe(false);
    expect(result.retryAfter).toBeGreaterThan(0);
  });

  it("should allow unlimited for enterprise", async () => {
    for (let i = 0; i < 10000; i++) {
      await checkRateLimitHelper(ctx, {
        apiKeyId: enterpriseKeyId,
        resource: "contents",
        action: "get",
      });
    }

    const result = await checkRateLimitHelper(ctx, {
      apiKeyId: enterpriseKeyId,
      resource: "contents",
      action: "get",
    });

    expect(result.allowed).toBe(true);
  });
});
```

**Output**: Tests

---

## Next Steps

After: Task 2.4.2 - Rate Limit Mutation

## Related

- Task 2.4.2: Mutation (uses this helper)

## Progress

```
[YYYY-MM-DD HH:mm] Task 2.4.1 completed

Key decisions:
- Put helper in model/ directory (Convex best practice)
- O(1) lookup via .withIndex().unique()
- Separate constants from logic

Files changed:
- packages/backend/convex/model/rateLimit.ts
- packages/backend/convex/model/__tests__/rateLimit.test.ts

Blockers: None
```
