# Task 4.1: Implement Velocity-Based Scraping Detection

## üéØ Goal

Detect and block high-velocity access patterns that indicate automated scraping tools.

## üìç Context

This is **Phase 4.1** of Anti-Scraping Layers phase.

Scrapers and automated tools have distinct access patterns that humans don't:

1. **Sequential access**: 10+ requests in 10 seconds (too fast to read)
2. **Bulk access**: 50+ different content slugs in 1 hour (downloading everything)
3. **Pattern matching**: Accessing all categories, grades, materials systematically

This task creates automated detection that:

- Monitors request velocity
- Flags suspicious patterns
- Auto-revokes API keys on critical violations
- Creates security alerts in `scrapingAlerts` table

## üé¨ Success Criteria

- [ ] Velocity detection query/mutation created
- [ ] Sequential access pattern detected (10 req/10s)
- [ ] Bulk access pattern detected (50 unique/hour)
- [ ] Critical triggers auto-revoke API key
- [ ] Warnings logged to `scrapingAlerts` table
- [ ] Alert types defined (sequential, bulk, velocity, ip-rotation)
- [ ] Integration with `/v1/contents` endpoints

## üìù Subtasks

### Subtask 4.1.1: Define Alert Types and Constants

Create alert types and threshold constants.

**File to create**: `packages/backend/convex/routes/scraping/types.ts`

**Implementation**:

```typescript
export type ScrapingAlertType =
  | "sequential_access"
  | "bulk_access"
  | "velocity_exceeded"
  | "ip_rotation"
  | "api_key_sharing";

export interface ScrapingThresholds {
  sequentialAccessMaxRequests: number;
  sequentialAccessWindowMs: number;
  bulkAccessMaxUniqueSlugs: number;
  bulkAccessWindowMs: number;
  velocityMaxRequests: number;
  velocityWindowMs: number;
  ipRotationMaxIPs: number;
  ipRotationWindowMs: number;
}

export const ALERT_THRESHOLDS: ScrapingThresholds = {
  // Sequential access: 10 requests in 10 seconds (too fast for reading)
  sequentialAccessMaxRequests: 10,
  sequentialAccessWindowMs: 10000, // 10 seconds

  // Bulk access: 50 different content slugs in 1 hour (scraping all content)
  bulkAccessMaxUniqueSlugs: 50,
  bulkAccessWindowMs: 3600000, // 1 hour

  // Velocity exceeded: 100 requests in 60 seconds (DDoS/burst)
  velocityMaxRequests: 100,
  velocityWindowMs: 60000, // 60 seconds

  // IP rotation: 5 different IPs from same API key in 1 hour (key sharing)
  ipRotationMaxIPs: 5,
  ipRotationWindowMs: 3600000, // 1 hour
} as const;

export const ALERT_SEVERITY = {
  warning: "warning",
  critical: "critical",
} as const;
```

**Why These Thresholds?**

- **Sequential (10 req/10s)**: Humans can't read content that fast
- **Bulk (50 unique/hour)**: Indicates downloading all content systematically
- **Velocity (100 req/60s)**: DDoS or burst attacks
- **IP rotation (5 IPs/hour)**: Indicates API key being shared among multiple users

**Output**: Alert types and thresholds

---

### Subtask 4.1.2: Create Detection Query

Create Convex query to detect scraping patterns in access logs.

**File to create**: `packages/backend/convex/contents/queries/scraping-detection.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { query } from "../_generated/server";
import type { Id } from "../_generated/dataModel";
import { ALERT_THRESHOLDS } from "../routes/scraping/types";

/**
 * Detects scraping patterns by analyzing recent access logs.
 * Checks for sequential, bulk, velocity, and IP rotation patterns.
 */
export const detectScrapingPattern = query({
  args: {
    apiKeyId: v.id("apikey"),
    windowMs: v.number(), // Time window to check (e.g., 1 hour)
  },
  returns: v.object({
    isScraping: v.boolean(),
    alertType: v.union(
      v.literal("sequential_access"),
      v.literal("bulk_access"),
      v.literal("velocity_exceeded"),
      v.literal("ip_rotation"),
      v.literal("api_key_sharing")
    ),
    severity: v.union(v.literal("warning"), v.literal("critical")),
    details: v.string(),
  }),
  handler: async (ctx, args) => {
    const now = Date.now();
    const windowStart = now - args.windowMs;

    // 1. Get recent access logs for this API key
    const recentAccess = await ctx.db
      .query("contentAccessLog")
      .withIndex("apiKeyId_accessedAt")
      .gte("accessedAt", windowStart)
      .eq("apiKeyId", args.apiKeyId)
      .collect();

    // 2. Check sequential access pattern
    const isSequentialAccess = await checkSequentialAccess(recentAccess);

    // 3. Check bulk access pattern
    const isBulkAccess = await checkBulkAccess(recentAccess);

    // 4. Check velocity exceeded
    const isVelocityExceeded = await checkVelocityExceeded(recentAccess);

    // 5. Check IP rotation (key sharing)
    const isIPRotation = await checkIPRotation(recentAccess);

    // 6. Determine alert type and severity
    let alertType: ScrapingAlertType;
    let severity: "warning" | "critical";
    let details: string;

    if (isVelocityExceeded) {
      alertType = "velocity_exceeded";
      severity = ALERT_SEVERITY.critical;
      details = `${ALERT_THRESHOLDS.velocityMaxRequests} requests in ${ALERT_THRESHOLDS.velocityWindowMs / 1000} seconds`;
    } else if (isSequentialAccess || isBulkAccess || isIPRotation) {
      // Sequential, bulk, or IP rotation are critical
      if (isSequentialAccess) {
        alertType = "sequential_access";
        severity = ALERT_SEVERITY.critical;
        details = `${ALERT_THRESHOLDS.sequentialAccessMaxRequests} requests in ${ALERT_THRESHOLDS.sequentialAccessWindowMs / 1000} seconds`;
      } else if (isBulkAccess) {
        alertType = "bulk_access";
        severity = ALERT_SEVERITY.critical;
        details = `${ALERT_THRESHOLDS.bulkAccessMaxUniqueSlugs} unique content slugs in 1 hour`;
      } else if (isIPRotation) {
        alertType = "ip_rotation";
        severity = ALERT_SEVERITY.critical;
        details = `${ALERT_THRESHOLDS.ipRotationMaxIPs} different IPs in 1 hour (API key sharing detected)`;
      }
    } else {
      // No scraping detected
      return {
        isScraping: false,
      };
    }

    // 7. Log alert to scrapingAlerts table
    await ctx.db.insert("scrapingAlerts", {
      apiKeyId: args.apiKeyId,
      alertType,
      severity,
      details,
      createdAt: now,
      resolved: severity === ALERT_SEVERITY.critical ? false : undefined, // Critical alerts unresolved initially
    });

    // 8. Auto-revoke API key for critical alerts
    if (severity === ALERT_SEVERITY.critical) {
      await ctx.db.patch("apikey", args.apiKeyId, {
        enabled: false,
        lastRevokeReason: alertType,
        revokedAt: now,
      });

      // Send email alert (will be implemented in Task 5.2)
      // TODO: Send email via Resend
    }

    return {
      isScraping: true,
      alertType,
      severity,
      details,
    };
  },
});

/**
 * Check for sequential access pattern (too fast)
 */
async function checkSequentialAccess(
  recentAccess: Doc<"contentAccessLog">[]
): Promise<boolean> {
  if (recentAccess.length < ALERT_THRESHOLDS.sequentialAccessMaxRequests) {
    return false;
  }

  // Check if last N requests happened within time window
  const earliestAllowed = recentAccess[recentAccess.length - ALERT_THRESHOLDS.sequentialAccessMaxRequests]?.accessedAt;
  const latest = recentAccess[recentAccess.length - 1]?.accessedAt;
  const window = latest - earliestAllowed;

  return window <= ALERT_THRESHOLDS.sequentialAccessWindowMs;
}

/**
 * Check for bulk access pattern (many unique content in short time)
 */
async function checkBulkAccess(
  recentAccess: Doc<"contentAccessLog">[]
): Promise<boolean> {
  const uniqueSlugs = new Set(recentAccess.map((a) => a.contentSlug));

  // Check if unique content slugs exceed threshold
  const isBulk = uniqueSlugs.size >= ALERT_THRESHOLDS.bulkAccessMaxUniqueSlugs;

  if (isBulk) {
    // Verify they're within time window
    const earliest = recentAccess[0]?.accessedAt;
    const latest = recentAccess[recentAccess.length - 1]?.accessedAt;
    const window = latest - earliest;

    return window <= ALERT_THRESHOLDS.bulkAccessWindowMs;
  }

  return isBulk;
}

/**
 * Check for velocity exceeded (burst of requests)
 */
async function checkVelocityExceeded(
  recentAccess: Doc<"contentAccessLog">[]
): Promise<boolean> {
  if (recentAccess.length < ALERT_THRESHOLDS.velocityMaxRequests) {
    return false;
  }

  // Check if last N requests happened within time window
  const earliest = recentAccess[recentAccess.length - ALERT_THRESHOLDS.velocityMaxRequests]?.accessedAt;
  const latest = recentAccess[recentAccess.length - 1]?.accessedAt;
  const window = latest - earliest;

  return window <= ALERT_THRESHOLDS.velocityWindowMs;
}

/**
 * Check for IP rotation pattern (multiple IPs from same API key)
 */
async function checkIPRotation(
  recentAccess: Doc<"contentAccessLog">[]
): Promise<boolean> {
  const uniqueIPs = new Set(recentAccess.map((a) => a.ipAddress));

  // Check if unique IPs exceed threshold
  const isRotation = uniqueIPs.size >= ALERT_THRESHOLDS.ipRotationMaxIPs;

  if (isRotation) {
    // Verify they're within time window
    const earliest = recentAccess[0]?.accessedAt;
    const latest = recentAccess[recentAccess.length - 1]?.accessedAt;
    const window = latest - earliest;

    return window <= ALERT_THRESHOLDS.ipRotationWindowMs;
  }

  return isRotation;
}
```

**Detection Logic**:

- **Sequential**: Checks if requests happen too fast (within 10s)
- **Bulk**: Tracks unique content slugs accessed (detects systematic downloading)
- **Velocity**: Checks for burst attacks (100 req in 60s)
- **IP rotation**: Tracks unique IPs from same API key

**Auto-Revocation**:

- Critical alerts (`severity: "critical"`) trigger immediate API key revocation
- Email notification sent (Task 5.2)

**Output**: Scraping detection query

---

### Subtask 4.1.3: Create Detection Middleware

Apply scraping detection to `/v1/contents` endpoints.

**File to create**: `packages/backend/convex/routes/middleware/scraping-detection.ts`

**Implementation**:

```typescript
import type { MiddlewareHandler } from "hono";
import { detectScrapingPattern } from "../contents/queries/scraping-detection";
import { HTTP_TOO_MANY_REQUESTS } from "../constants";
import type { ActionCtx } from "../../_generated/server";

/**
 * Scraping detection middleware.
 * Checks for suspicious patterns and auto-revokes API keys.
 *
 * @param windowMs - Time window to analyze (default: 1 hour)
 */
export const requireScrapingDetection = (windowMs = 3600000): MiddlewareHandler<{
  Bindings: ActionCtx;
  Variables: {
    userId: string;
    apiKeyId: string;
  };
}> => {
  return async (c, next) => {
    const apiKeyId = c.get("apiKeyId");

    if (!apiKeyId) {
      return next(); // Skip check if no API key (shouldn't happen)
    }

    // Check for scraping patterns
    const result = await c.env.runQuery(
      detectScrapingPattern,
      {
        apiKeyId,
        windowMs,
      }
    );

    // If scraping detected, block request
    if (result.isScraping) {
      return c.json(
        {
          error: "Suspicious activity detected",
          alertType: result.alertType,
          details: result.details,
          severity: result.severity,
        },
        {
          status: HTTP_TOO_MANY_REQUESTS,
          headers: {
            "X-Scraping-Alert": result.alertType,
            "X-Scraping-Severity": result.severity,
          },
        }
      );
    }

    // Scraping not detected, allow request to proceed
    await next();
  };
};
```

**Integration Example**:

```typescript
// In v1/index.ts
import { requireScrapingDetection } from "../middleware/scraping-detection";

v1.get("/contents/:slug", requireApiKey(), requireScrapingDetection(), async (c) => {
  // Scraping detection happens automatically
  // Proceed with content logic
});
```

**Features**:

- **Automatic detection**: No manual monitoring needed
- **Auto-revocation**: Critical alerts disable API keys immediately
- **Detailed alerts**: Returns alert type, severity, and details
- **Configurable window**: Default 1 hour, can be adjusted

**Output**: Scraping detection middleware

---

### Subtask 4.1.4: Add Unit Tests

Test all scraping detection scenarios.

**File to create**: `packages/backend/convex/routes/__tests__/scraping-detection.test.ts`

**Test Cases**:

```typescript
describe("Scraping Detection", () => {
  describe("sequential access", () => {
    it("should detect 10 requests in 10 seconds", async () => {
      const result = await detectScrapingPattern(testApiKey, 10000, createSequentialLogs(10));

      expect(result.isScraping).toBe(true);
      expect(result.alertType).toBe("sequential_access");
      expect(result.severity).toBe("critical");
      expect(result.details).toContain("10 requests in 10 seconds");
    });

    it("should not detect 5 requests in 10 seconds", async () => {
      const result = await detectScrapingPattern(testApiKey, 10000, createSequentialLogs(5));

      expect(result.isScraping).toBe(false);
    });
  });

  describe("bulk access", () => {
    it("should detect 50 unique slugs in 1 hour", async () => {
      const result = await detectScrapingPattern(
        testApiKey,
        3600000,
        createBulkLogs(50, new Set(["slug-1", "slug-2", /* ... */ "slug-50"]))
      );

      expect(result.isScraping).toBe(true);
      expect(result.alertType).toBe("bulk_access");
      expect(result.severity).toBe("critical");
    });

    it("should not detect 10 unique slugs in 1 hour", async () => {
      const result = await detectScrapingPattern(
        testApiKey,
        3600000,
        createBulkLogs(10, new Set(["slug-1", /* ... */ "slug-10"]))
      );

      expect(result.isScraping).toBe(false);
    });
  });

  describe("velocity exceeded", () => {
    it("should detect 100 requests in 60 seconds", async () => {
      const result = await detectScrapingPattern(testApiKey, 60000, createVelocityLogs(100));

      expect(result.isScraping).toBe(true);
      expect(result.alertType).toBe("velocity_exceeded");
      expect(result.severity).toBe("critical");
    });

    it("should not detect 50 requests in 60 seconds", async () => {
      const result = await detectScrapingPattern(testApiKey, 60000, createVelocityLogs(50));

      expect(result.isScraping).toBe(false);
    });
  });

  describe("ip rotation", () => {
    it("should detect 5 IPs in 1 hour", async () => {
      const result = await detectScrapingPattern(
        testApiKey,
        3600000,
        createIPRotationLogs(5, ["1.2.3.4", /* ... */ "5.6.7.8"])
      );

      expect(result.isScraping).toBe(true);
      expect(result.alertType).toBe("ip_rotation");
      expect(result.details).toContain("5 different IPs");
    });

    it("should not detect 2 IPs in 1 hour", async () => {
      const result = await detectScrapingPattern(
        testApiKey,
        3600000,
        createIPRotationLogs(2, ["1.2.3.4", "5.6.7.8"])
      );

      expect(result.isScraping).toBe(false);
    });
  });

  describe("auto-revocation", () => {
    it("should revoke API key on critical alerts", async () => {
      const result = await detectScrapingPattern(
        testApiKey,
        3600000,
        createSequentialLogs(10) // Triggers critical alert
      );

      expect(result.isScraping).toBe(true);
      expect(result.severity).toBe("critical");

      // Verify API key was revoked
      const apiKey = await ctx.db.get("apikey", testApiKey);

      expect(apiKey?.enabled).toBe(false);
      expect(apiKey?.lastRevokeReason).toBe("sequential_access");
      expect(apiKey?.revokedAt).toBeDefined();
    });
  });
});
```

**Test Helper Functions**:

```typescript
function createSequentialLogs(count: number) {
  return Array.from({ length: count }, (_, i) => ({
    contentSlug: `test-slug-${i}`,
    accessedAt: Date.now() - (count - i) * 1000,
    ipAddress: `192.168.1.${i}`,
    userAgent: "test-bot",
  }));
}

function createBulkLogs(count: number, slugs: Set<string>) {
  const slugArray = Array.from(slugs);
  return Array.from({ length: count }, (_, i) => ({
    contentSlug: slugArray[i],
    accessedAt: Date.now() - (count - i - 1) * 60000,
    ipAddress: `192.168.2.${i % 3}`,
    userAgent: "scraper-v1",
  }));
}

function createVelocityLogs(count: number) {
  return Array.from({ length: count }, (_, i) => ({
    contentSlug: `test-slug-${i}`,
    accessedAt: Date.now() - (count - i - 1) * 500, // 100 requests in 50 seconds
    ipAddress: `192.168.3.1`,
    userAgent: "ddos-tool",
  }));
}

function createIPRotationLogs(count: number, ips: string[]) {
  return Array.from({ length: count }, (_, i) => ({
    contentSlug: `test-slug-${i}`,
    accessedAt: Date.now() - (count - i - 1) * 60000,
    ipAddress: ips[i % ips.length],
    userAgent: "shared-key-bot",
  }));
}
```

**Coverage**:

- ‚úÖ Sequential access detection
- ‚úÖ Bulk access detection
- ‚úÖ Velocity exceeded detection
- ‚úÖ IP rotation detection
- ‚úÖ Auto-revocation on critical alerts
- ‚úÖ False positive handling

**Output**: Comprehensive test suite

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 4.2 - Implement IP-Based Rate Limiting
2. **Phase 4**: Continue building anti-scraping layers

## üîó Related Tasks

- Task 0.2: Extend Better Auth Schema (creates `scrapingAlerts` table)
- Task 2.4: Implement Tiered Rate Limiting (uses same `contentAccessLog` data)
- Task 4.2: Implement IP-Based Rate Limiting (complements velocity detection)
- Task 4.5: Implement Automatic API Key Revocation (auto-revoke on critical alerts)
- Task 5.2: Set Up Automated Alerts via Resend (email notifications)

## ‚ö†Ô∏è Important Notes

### Detection Strategy

- **Multi-layered**: Single threshold can be evaded, multiple patterns harder
- **Configurable windows**: Default 1 hour, adjustable per environment
- **Auto-revocation**: Critical alerts trigger immediate key disable
- **Warning vs Critical**: Warnings logged but don't revoke

### Thresholds Rationale

- **Sequential (10 req/10s)**: Humans can't read that fast
- **Bulk (50 unique/hour)**: Normal usage = ~10-20 articles/hour
- **Velocity (100 req/60s)**: Prevents DDoS/burst attacks
- **IP rotation (5 IPs/hour)**: Detects API key sharing

### Integration

- Apply middleware to `/v1/contents/*` endpoints
- Apply middleware to `/v1/contents/search` endpoint
- Apply middleware to `/v1/contents/:slug` endpoint
- Add to MCP endpoints after Task 3.2

### False Positives

- Power users might trigger false alerts
- Review dashboard can resolve warnings
- Manual re-enablement of keys (if wrongly revoked)

### Future Enhancements

- Consider ML-based anomaly detection (more sophisticated)
- Consider adding reputation scoring (builds over time)
- Consider adding user verification (require email/phone for high-risk tiers)
- Consider adding CAPTCHA for suspicious patterns
