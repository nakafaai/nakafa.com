# Task 0.2: Extend Better Auth Schema

## üéØ Goal

Extend Better Auth schema to support API keys, rate limiting, and security tracking tables for API monetization.

## üìç Context

This is **Phase 0.2** of Foundation phase.

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

Phase 1-6 require new database tables:

- API key management (apikey table)
- Rate limiting tracking (apiKeyUsage table)
- Content access logging (contentAccessLog table)
- Scraping alerts (scrapingAlerts table)
- Security events (securityEvents table)
- Content leaks (contentLeaks table)

## PRD

```json
{
  "category": "architecture",
  "description": "Extend Better Auth schema for API monetization tables",
  "steps": [
    "Add apikey table with tier-based permissions",
    "Add apiKeyUsage table for rate limiting",
    "Add contentAccessLog table for access tracking",
    "Add scrapingAlerts table for security monitoring",
    "Add securityEvents table for audit trail",
    "Add contentLeaks table for leak tracking"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] All 6 new tables added to schema
- [ ] Proper indexes defined for performance
- [ ] Tables follow Convex best practices
- [ ] Schema migration runs successfully
- [ ] Tests verify schema structure

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck  
pnpm test
```

## üìù Subtasks

### Subtask 0.2.1: Add API Key Table

Add table for storing user API keys with tier-based limits.

**File to modify**: `packages/backend/convex/schema.ts`

**Schema Addition**:

```typescript
import { defineTable, v } from "convex/server";

apikey: defineTable({
  userId: v.id("users"),
  name: v.string(),
  key: v.string(), // The actual API key (starts with nak_pk_)
  signingSecret: v.optional(v.string()), // For request signature verification (Phase 4.3)
  subscriptionTier: v.union(
    v.literal("free"),
    v.literal("pro"),
    v.literal("enterprise")
  ),
  rateLimitDaily: v.optional(v.number()), // Null means unlimited
  rateLimitMinute: v.optional(v.number()), // Null means no minute limit
  permissions: v.array(v.string()), // e.g., ["contents", "search"]
  enabled: v.boolean(),
  lastRevokeReason: v.optional(v.string()), // Why was key revoked?
  revokedAt: v.optional(v.number()), // When was it revoked?
  createdAt: v.number(),
  lastUsedAt: v.optional(v.number()),
}).index("userId", ["userId"]).index("userId_enabled", ["userId", "enabled"]).index("key", ["key"]),
```

**Indexes Explained**:

- `userId`: Fast lookup of all keys for a user
- `userId_enabled`: Find enabled keys for user
- `key`: Validate key uniqueness

**Output**: API key table created

---

### Subtask 0.2.2: Add API Key Usage Table

Add denormalized counter table for rate limiting (O(1) lookups).

**File to modify**: `packages/backend/convex/schema.ts`

**Schema Addition**:

```typescript
apiKeyUsage: defineTable({
  apiKeyId: v.id("apikey"),
  userId: v.id("users"),
  subscriptionTier: v.union(
    v.literal("free"),
    v.literal("pro"),
    v.literal("enterprise")
  ),
  requestsToday: v.number(),
  requestsThisMinute: v.number(),
  lastRequestTime: v.number(),
  dailyResetTime: v.number(), // Unix timestamp for daily reset
  minuteResetTime: v.number(), // Unix timestamp for minute reset
}).index("apiKeyId", ["apiKeyId"]),
```

**Convex Pattern**:

- **Denormalized counter**: Single document per API key
- **O(1) lookup**: Fastest possible rate limit check
- **Auto-reset**: Fields track when to reset counters

**Output**: API key usage table created

---

### Subtask 0.2.3: Add Content Access Log Table

Add table for tracking all content access (for scraping detection and analytics).

**File to modify**: `packages/backend/convex/schema.ts`

**Schema Addition**:

```typescript
contentAccessLog: defineTable({
  apiKeyId: v.id("apikey"),
  userId: v.id("users"),
  contentSlug: v.string(),
  action: v.string(), // "list", "get", "search"
  metadata: v.optional(v.string()), // Query params, filters, etc.
  ipAddress: v.optional(v.string()), // From middleware (Task 4.2)
  requestSignature: v.optional(v.string()), // From middleware (Task 4.3)
  accessedAt: v.number(),
}).index("apiKeyId_accessedAt", ["apiKeyId", "accessedAt"]).index("userId_accessedAt", ["userId", "accessedAt"]).index("accessedAt", ["accessedAt"]),
```

**Indexes Explained**:

- `apiKeyId_accessedAt`: Get recent access for specific key
- `userId_accessedAt`: Get recent access for specific user
- `accessedAt`: Time-range queries for scraping detection

**Output**: Content access log table created

---

### Subtask 0.2.4: Add Scraping Alerts Table

Add table for logging scraping detection alerts.

**File to modify**: `packages/backend/convex/schema.ts`

**Schema Addition**:

```typescript
scrapingAlerts: defineTable({
  apiKeyId: v.id("apikey"),
  alertType: v.union(
    v.literal("sequential_access"),
    v.literal("bulk_access"),
    v.literal("velocity_exceeded"),
    v.literal("ip_rotation"),
    v.literal("api_key_sharing")
  ),
  severity: v.union(v.literal("warning"), v.literal("critical")),
  details: v.string(), // JSON string with alert details
  resolved: v.optional(v.boolean()), // For dashboard filtering
  createdAt: v.number(),
}).index("apiKeyId_createdAt", ["apiKeyId", "createdAt"]).index("severity", ["severity"]).index("resolved", ["resolved"]),
```

**Output**: Scraping alerts table created

---

### Subtask 0.2.5: Add Security Events Table

Add audit trail table for all security-related events.

**File to modify**: `packages/backend/convex/schema.ts`

**Schema Addition**:

```typescript
securityEvents: defineTable({
  type: v.string(), // "api_key_revoked", "api_key_unbanned", "scraping_alert", etc.
  severity: v.union(v.literal("critical"), v.literal("warning"), v.literal("info")),
  apiKeyId: v.optional(v.id("apikey")),
  userId: v.optional(v.id("users")),
  details: v.string(), // JSON string with event details
  createdAt: v.number(),
}).index("apiKeyId_createdAt", ["apiKeyId", "createdAt"]).index("type_createdAt", ["type", "createdAt"]),
```

**Output**: Security events table created

---

### Subtask 0.2.6: Add Content Leaks Table

Add table for tracking detected content leaks (from watermarked content).

**File to modify**: `packages/backend/convex/schema.ts`

**Schema Addition**:

```typescript
contentLeaks: defineTable({
  apiKeyId: v.id("apikey"),
  slug: v.string(),
  foundOn: v.string(), // Domain/URL where leak was found
  foundAt: v.number(),
  reportedBy: v.union(
    v.literal("automated"),
    v.literal("manual"),
    v.literal("user_report"),
    v.literal("investigation")
  ),
  resolved: v.optional(v.boolean()),
  createdAt: v.number(),
}).index("apiKeyId_resolved", ["apiKeyId", "resolved"]).index("foundAt", ["foundAt"]),
```

**Output**: Content leaks table created

---

### Subtask 0.2.7: Add Tests

Verify schema structure and migrations work correctly.

**Test File**: `packages/backend/convex/__tests__/schema.test.ts`

**Test Cases**:

```typescript
describe("API Monetization Schema", () => {
  describe("apikey table", () => {
    it("should store API keys with tier info", async () => {
      const userId = await createTestUser();
      const apiKeyId = await ctx.runMutation(
        api.betterAuth.mutations.createApiKey,
        { userId, tier: "free" }
      );
      
      const apiKey = await ctx.runQuery(
        api.apikeys.queries.getById,
        { id: apiKeyId }
      );
      
      expect(apiKey?.subscriptionTier).toBe("free");
      expect(apiKey?.rateLimitDaily).toBe(25);
    });

    it("should enforce unique keys", async () => {
      const duplicate = await ctx.runMutation(
        api.betterAuth.mutations.createApiKey,
        { userId: testUserId, key: "test-key" }
      );
      
      expect(duplicate).rejects.toThrow();
    });
  });

  describe("apiKeyUsage table", () => {
    it("should track daily and minute counters", async () => {
      const apiKeyId = await createTestApiKey();
      
      const usage = await ctx.runQuery(
        api.apikeys.queries.getUsage,
        { apiKeyId }
      );
      
      expect(usage?.requestsToday).toBe(0);
      expect(usage?.requestsThisMinute).toBe(0);
      expect(usage?.dailyResetTime).toBeGreaterThan(Date.now());
    });
  });

  describe("contentAccessLog table", () => {
    it("should log content access with metadata", async () => {
      const apiKeyId = await createTestApiKey();
      
      await ctx.runMutation(
        api.contents.mutations.logAccess,
        { apiKeyId, contentSlug: "test", action: "get" }
      );
      
      const logs = await ctx.runQuery(
        api.contents.queries.getAccessLogs,
        { apiKeyId, limit: 10 }
      );
      
      expect(logs.length).toBeGreaterThan(0);
      expect(logs[0].action).toBe("get");
    });
  });
});
```

**Coverage**:

- ‚úÖ API key table structure
- ‚úÖ Usage counter table structure
- ‚úÖ Access log table structure
- ‚úÖ All indexes defined correctly

**Output**: Schema tests passing

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 1.1 - Create Internal Auth Middleware

## üîó Related Tasks

- Task 1.1: Create Internal Auth Middleware (uses `apikey` table)
- Task 1.2: Apply Internal Auth to Content Routes (uses `apikey` table)
- Task 2.1: Create Content List Endpoint (uses `contentAccessLog` table)
- Task 2.4: Implement Tiered Rate Limiting (uses `apiKeyUsage` table)
- Task 4.1: Implement Velocity-Based Scraping Detection (uses `contentAccessLog` + `scrapingAlerts`)
- Task 4.5: Implement Automatic API Key Revocation (uses `securityEvents` table)

## ‚ö†Ô∏è Important Notes

### Schema Design

- **Denormalized counters**: `apiKeyUsage` is O(1) for rate limiting
- **Audit trail**: `securityEvents` tracks all security actions
- **Flexible metadata**: JSON fields for extensible logging
- **Indexes**: All frequently queried fields have indexes

### Data Migration

- **Existing data**: No migration needed (fresh tables)
- **Future changes**: Use Convex migrations for schema updates

### Progress Tracking

After completing this task, update `plans/api-monetization/progress.txt`:

```txt
[YYYY-MM-DD HH:mm] Task 0.2 completed

Key decisions:
- Use denormalized apiKeyUsage table for O(1) rate limit lookups
- Add all 6 tables in single schema file
- Include IP tracking in contentAccessLog for future IP-based rate limiting

Files changed:
- packages/backend/convex/schema.ts

Blockers/notes:
- None. Ready for Task 1.1.
```
