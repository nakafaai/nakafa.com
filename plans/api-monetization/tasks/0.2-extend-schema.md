# Task 0.2: Create App-Specific Security Tables

## üéØ Goal

Create app-specific security tables that complement Better Auth's built-in `apikey` table. Better Auth already provides API key management and rate limiting - we only need app-specific tracking tables.

## üìç Context

This is **Phase 0.2** of Foundation phase.

**Better Auth Already Provides** (DO NOT recreate):
- ‚úÖ `apikey` table - User API keys with built-in rate limiting
- ‚úÖ Rate limiting - `refillInterval`, `refillAmount`, `rateLimitMax`, `remaining`
- ‚úÖ Key permissions - `permissions` field
- ‚úÖ Key metadata - `metadata` JSON field (use for `subscriptionTier`)
- ‚úÖ Usage tracking - `requestCount`, `remaining`, `lastRequest`

**We Only Need** (app-specific tables):
- `contentAccessLog` - Track which content is accessed
- `scrapingAlerts` - Security alerts for scraping detection
- `securityEvents` - Audit trail for all security events
- `contentLeaks` - Track detected content leaks

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

## PRD

```json
{
  "category": "architecture",
  "description": "Create app-specific security tables (Better Auth handles API keys)",
  "steps": [
    "Create contentAccessLog table",
    "Create scrapingAlerts table",
    "Create securityEvents table",
    "Create contentLeaks table",
    "Add tests verifying schema structure"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] All 4 app-specific tables added (not 6 - Better Auth has 2 already)
- [ ] Proper indexes defined for performance
- [ ] Tables follow Convex best practices
- [ ] Schema migration runs successfully
- [ ] Tests verify schema structure

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck
pnpm test
```

## üìù Subtasks

### Subtask 0.2.1: Add Content Access Log Table

Add table for tracking all content access (for scraping detection and analytics).

**File to create**: `packages/backend/convex/contentAccessLog/schema.ts`

**Schema**:

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";

const tables = {
  contentAccessLog: defineTable({
    apiKeyId: v.string(), // Better Auth API key ID (string type in Better Auth)
    userId: v.id("users"),
    contentSlug: v.string(),
    action: v.union(
      v.literal("list"),
      v.literal("get"),
      v.literal("search")
    ),
    metadata: v.optional(v.string()), // Query params, filters, etc.
    ipAddress: v.optional(v.string()), // From middleware (Task 4.2)
    requestSignature: v.optional(v.string()), // From middleware (Task 4.3)
    accessedAt: v.number(),
  })
    .index("apiKeyId_accessedAt", ["apiKeyId", "accessedAt"])
    .index("userId_accessedAt", ["userId", "accessedAt"])
    .index("accessedAt", ["accessedAt"]),
};

export default tables;
```

**Indexes Explained**:

- `apiKeyId_accessedAt`: Get recent access for specific key
- `userId_accessedAt`: Get recent access for specific user
- `accessedAt`: Time-range queries for scraping detection

**Note**: `apiKeyId` is `v.string()` because Better Auth's `apikey` table uses string IDs, not Convex IDs.

**Output**: Content access log table created

---

### Subtask 0.2.2: Add Scraping Alerts Table

Add table for logging scraping detection alerts.

**File to create**: `packages/backend/convex/scrapingAlerts/schema.ts`

**Schema**:

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";

const tables = {
  scrapingAlerts: defineTable({
    apiKeyId: v.string(),
    alertType: v.union(
      v.literal("sequential_access"),
      v.literal("bulk_access"),
      v.literal("velocity_exceeded"),
      v.literal("ip_rotation"),
      v.literal("api_key_sharing")
    ),
    severity: v.union(v.literal("warning"), v.literal("critical")),
    details: v.string(), // JSON string with alert details
    resolved: v.optional(v.boolean()),
    createdAt: v.number(),
  })
    .index("apiKeyId_createdAt", ["apiKeyId", "createdAt"])
    .index("severity", ["severity"])
    .index("resolved", ["resolved"]),
};

export default tables;
```

**Output**: Scraping alerts table created

---

### Subtask 0.2.3: Add Security Events Table

Add audit trail table for all security-related events.

**File to create**: `packages/backend/convex/securityEvents/schema.ts`

**Schema**:

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";

const tables = {
  securityEvents: defineTable({
    type: v.string(), // "api_key_revoked", "api_key_unbanned", "scraping_alert", etc.
    severity: v.union(v.literal("critical"), v.literal("warning"), v.literal("info")),
    apiKeyId: v.optional(v.string()),
    userId: v.optional(v.id("users")),
    details: v.string(), // JSON string with event details
    createdAt: v.number(),
  })
    .index("apiKeyId_createdAt", ["apiKeyId", "createdAt"])
    .index("type_createdAt", ["type", "createdAt"]),
};

export default tables;
```

**Output**: Security events table created

---

### Subtask 0.2.4: Add Content Leaks Table

Add table for tracking detected content leaks (from watermarked content).

**File to create**: `packages/backend/convex/contentLeaks/schema.ts`

**Schema**:

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";

const tables = {
  contentLeaks: defineTable({
    apiKeyId: v.string(),
    slug: v.string(),
    foundOn: v.string(), // Domain/URL where leak was found
    foundAt: v.number(),
    reportedBy: v.union(
      v.literal("automated"),
      v.literal("manual"),
      v.literal("user_report"),
      v.literal("investigation")
    ),
    resolved: v.optional(v.boolean()),
    createdAt: v.number(),
  })
    .index("apiKeyId_resolved", ["apiKeyId", "resolved"])
    .index("foundAt", ["foundAt"]),
};

export default tables;
```

**Output**: Content leaks table created

---

### Subtask 0.2.5: Update Main Schema

Import and add all new tables to main schema.

**File to modify**: `packages/backend/convex/schema.ts`

**Changes**:

```typescript
import { defineSchema } from "convex/server";
import bookmarksSchema from "./bookmarks/schema";
import chatsSchema from "./chats/schema";
import classesSchema from "./classes/schema";
import commentsSchema from "./comments/schema";
import contentsSchema from "./contents/schema";
import contentAccessLogSchema from "./contentAccessLog/schema"; // NEW
import contentLeaksSchema from "./contentLeaks/schema"; // NEW
import customersSchema from "./customers/schema";
import exercisesSchema from "./exercises/schema";
import scrapingAlertsSchema from "./scrapingAlerts/schema"; // NEW
import securityEventsSchema from "./securityEvents/schema"; // NEW
import notificationsSchema from "./notifications/schema";
import schoolsSchema from "./schools/schema";
import subscriptionsSchema from "./subscriptions/schema";
import usersSchema from "./users/schema";

export default defineSchema(
  {
    ...usersSchema,
    ...chatsSchema,
    ...commentsSchema,
    ...customersSchema,
    ...subscriptionsSchema,
    ...schoolsSchema,
    ...classesSchema,
    ...notificationsSchema,
    ...bookmarksSchema,
    ...contentsSchema,
    ...exercisesSchema,
    ...contentAccessLogSchema, // NEW
    ...contentLeaksSchema, // NEW
    ...scrapingAlertsSchema, // NEW
    ...securityEventsSchema, // NEW
  },
  {
    schemaValidation: true,
  }
);
```

**Output**: Main schema updated with all tables

---

### Subtask 0.2.6: Add Tests

Verify schema structure and migrations work correctly.

**Test File**: `packages/backend/convex/__tests__/appSchema.test.ts`

**Test Cases**:

```typescript
describe("App-Specific Security Schema", () => {
  describe("contentAccessLog table", () => {
    it("should log content access with metadata", async () => {
      const userId = await createTestUser();
      const apiKeyId = await createTestApiKey(userId);

      await ctx.runMutation(internal.contentAccessLog.mutations.logAccess, {
        apiKeyId,
        userId,
        contentSlug: "test-article",
        action: "get",
      });

      const logs = await ctx.runQuery(
        internal.contentAccessLog.queries.getAccessLogs,
        { apiKeyId, limit: 10 }
      );

      expect(logs.length).toBeGreaterThan(0);
      expect(logs[0].action).toBe("get");
    });

    it("should index by apiKeyId_accessedAt", async () => {
      const userId = await createTestUser();
      const apiKeyId = await createTestApiKey(userId);

      await ctx.runMutation(internal.contentAccessLog.mutations.logAccess, {
        apiKeyId,
        userId,
        contentSlug: "test",
        action: "get",
      });

      const result = await ctx.db
        .query("contentAccessLog")
        .withIndex("apiKeyId_accessedAt")
        .eq("apiKeyId", apiKeyId)
        .order("desc")
        .first();

      expect(result).toBeDefined();
    });
  });

  describe("scrapingAlerts table", () => {
    it("should store scraping alerts", async () => {
      const userId = await createTestUser();
      const apiKeyId = await createTestApiKey(userId);

      await ctx.runMutation(internal.scrapingAlerts.mutations.createAlert, {
        apiKeyId,
        alertType: "sequential_access",
        severity: "warning",
        details: "{}",
      });

      const alerts = await ctx.runQuery(internal.scrapingAlerts.queries.listAlerts, {
        apiKeyId,
      });

      expect(alerts.length).toBeGreaterThan(0);
      expect(alerts[0].alertType).toBe("sequential_access");
    });
  });

  describe("securityEvents table", () => {
    it("should track security events", async () => {
      const userId = await createTestUser();
      const apiKeyId = await createTestApiKey(userId);

      await ctx.runMutation(internal.securityEvents.mutations.logEvent, {
        type: "api_key_created",
        severity: "info",
        apiKeyId,
        userId,
        details: "{}",
      });

      const events = await ctx.runQuery(internal.securityEvents.queries.listEvents, {
        apiKeyId,
      });

      expect(events.length).toBeGreaterThan(0);
    });
  });

  describe("contentLeaks table", () => {
    it("should track content leaks", async () => {
      const userId = await createTestUser();
      const apiKeyId = await createTestApiKey(userId);

      await ctx.runMutation(internal.contentLeaks.mutations.reportLeak, {
        apiKeyId,
        slug: "premium-article",
        foundOn: "https://pirate-site.com/content",
        foundAt: Date.now(),
        reportedBy: "automated",
      });

      const leaks = await ctx.runQuery(internal.contentLeaks.queries.listLeaks, {
        apiKeyId,
      });

      expect(leaks.length).toBeGreaterThan(0);
      expect(leaks[0].resolved).toBeFalsy();
    });
  });
});
```

**Coverage**:

- ‚úÖ Content access log table structure
- ‚úÖ Scraping alerts table structure
- ‚úÖ Security events table structure
- ‚úÖ Content leaks table structure
- ‚úÖ All indexes defined correctly

**Output**: Schema tests passing

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 1.1 - Create Internal Auth Middleware

## üîó Related Tasks

- Task 1.1: Create Internal Auth Middleware (uses internal key from Task 0.1)
- Task 2.1: Create Content List Endpoint (uses `contentAccessLog` table)
- Task 4.1: Implement Velocity-Based Scraping Detection (uses `contentAccessLog` + `scrapingAlerts`)
- Task 4.5: Implement Automatic API Key Revocation (uses `securityEvents` table)

## ‚ö†Ô∏è Important Notes

### Schema Design

- **Better Auth handles**: API keys, rate limiting, permissions, metadata
- **We track only**: App-specific security events and content access
- **Denormalized not needed**: Better Auth has built-in rate limit counters
- **Audit trail**: `securityEvents` tracks all security actions
- **Flexible metadata**: JSON fields for extensible logging
- **Indexes**: All frequently queried fields have indexes

### Better Auth Integration

**Key Fields Mapping**:

| What We Need | Better Auth Field | Notes |
|-------------|------------------|-------|
| API key ID | `id` (string) | Not Convex ID |
| API key value | `key` (string) | Already hashed/secure |
| Rate limit remaining | `remaining` (number) | Auto-managed |
| Rate limit max | `rateLimitMax` (number) | Per window |
| Rate limit window | `rateLimitTimeWindow` (number) | Milliseconds |
| Refill interval | `refillInterval` (number) | Reset period |
| Subscription tier | `metadata.subscriptionTier` | JSON field |
| Permissions | `permissions` (string) | Comma-separated |
| Enabled | `enabled` (boolean) | Can disable keys |

### Data Migration

- **Existing data**: No migration needed (fresh tables)
- **Future changes**: Use Convex migrations for schema updates

### Progress Tracking

After completing this task, update `plans/api-monetization/progress.txt`:

```txt
[YYYY-MM-DD HH:mm] Task 0.2 completed

Key decisions:
- Better Auth handles API keys and rate limiting (no need to recreate)
- Only create 4 app-specific tables (not 6)
- Use Better Auth's metadata field for subscriptionTier
- apiKeyId is string type (Better Auth uses string IDs, not Convex IDs)

Files changed:
- packages/backend/convex/contentAccessLog/schema.ts (created)
- packages/backend/convex/scrapingAlerts/schema.ts (created)
- packages/backend/convex/securityEvents/schema.ts (created)
- packages/backend/convex/contentLeaks/schema.ts (created)
- packages/backend/convex/schema.ts (updated)

Blockers/notes:
- None. Ready for Task 1.1.
```
