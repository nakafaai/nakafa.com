# Task 1.3: Update Internal Fetcher to Use Auth

## üéØ Goal

Update `packages/connection/lib/fetcher.ts` to automatically include internal API key authentication for internal content requests.

## üìç Context

This is **Phase 1.3** of Secure Internal Content Endpoints phase.

The `fetcher` utility is used by AI tools (`packages/ai/tools/content.ts`, etc.) to fetch content from `/contents/*` endpoints. Currently, it makes **unauthenticated requests**.

Since we've protected `/contents/*` endpoints with internal auth in Task 1.2, we need to:

1. Pass internal API key in `Authorization` header
2. Ensure all internal calls include this header
3. Keep public API calls unchanged (external callers use their own keys)

## PRD

```json
{
  "category": "integration",
  "description": "Update fetcher to include internal API key for all internal content requests",
  "steps": [
    "Add useInternalAuth parameter to fetcher function",
    "Add Authorization header when useInternalAuth=true",
    "Update all content API functions to pass useInternalAuth=true",
    "Update env.ts to include INTERNAL_CONTENT_API_KEY",
    "Add tests for internal auth functionality"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] `fetcher` supports `useInternalAuth` parameter
- [ ] Internal calls include `Authorization: Bearer ${INTERNAL_API_KEY}`
- [ ] Public calls remain unchanged
- [ ] AI tools continue to work seamlessly
- [ ] Type safety maintained

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck  
pnpm test
```

## üìù Subtasks

### Subtask 1.3.1: Add Internal Auth Parameter to Fetcher

Add optional parameter to control whether to use internal auth.

**File to modify**: `packages/connection/lib/fetcher.ts`

**Changes Required**:

```typescript
export async function fetcher<T>({
  url,
  endpoint,
  options,
  useInternalAuth,
}: {
  url?: string;
  endpoint: string;
  options: RequestInit;
  useInternalAuth?: boolean;
}): Promise<FetchResult<T | null>> {
  const baseUrl = url ?? (await getBaseUrl());

  const headers: HeadersInit = {
    ...options.headers,
  };

  if (useInternalAuth) {
    const internalApiKey = process.env.INTERNAL_CONTENT_API_KEY;
    if (!internalApiKey) {
      throw new Error("INTERNAL_CONTENT_API_KEY not configured");
    }
    headers["Authorization"] = `Bearer ${internalApiKey}`;
  }

  try {
    const response = await ky<T>(`${baseUrl}${endpoint}`, {
      ...options,
      headers,
    }).json();

    return { data: response, error: null };
  } catch (error) {
    return {
      data: null,
      error: error instanceof Error ? error : new Error(String(error)),
    };
  }
}
```

**Behavior Changes**:

- `useInternalAuth: false` (default): No Authorization header added
- `useInternalAuth: true`: Adds `Authorization: Bearer ${INTERNAL_API_KEY}`
- Backward compatible: Existing callers work unchanged

**Output**: Enhanced fetcher with internal auth support

---

### Subtask 1.3.2: Update Contents API Functions

Modify content fetching functions to use internal auth by default.

**File to modify**: `packages/connection/routes/contents.ts`

**Changes Required**:

For `getContents`:

```typescript
async function getContents({
  slug,
  withRaw = true,
  ...base
}: { slug: string; withRaw?: boolean } & RequestInit): Promise<
  FetchResult<Content[]>
> {
  const { data, error } = await fetcher<Content[]>({
    endpoint: `${PREFIX}/${cleanSlug(slug)}`,
    options: {
      method: "GET",
      ...base,
    },
    useInternalAuth: true,
  });

  return { data, error };
}
```

For `getContent`:

```typescript
async function getContent({
  slug,
  ...base
}: {
  slug: string;
} & RequestInit): Promise<FetchResult<Content | null>> {
  const cleanedSlug = cleanSlug(slug);
  const { data, error } = await fetcher<Content[]>({
    endpoint: `${PREFIX}/${cleanedSlug}`,
    options: {
      method: "GET",
      ...base,
    },
    useInternalAuth: true,
  });

  return { data: data?.[0] ?? null, error };
}
```

For `getSurah`:

```typescript
async function getSurah({
  surah,
  ...base
}: {
  surah: number;
} & RequestInit): Promise<FetchResult<Surah | null>> {
  const { data, error } = await fetcher<Surah>({
    endpoint: `${PREFIX}/quran/${surah}`,
    options: {
      method: "GET",
      ...base,
    },
    useInternalAuth: true,
  });

  return { data, error };
}
```

For `getExercises`:

```typescript
async function getExercises({
  slug,
  withRaw = true,
  ...base
}: {
  slug: string;
  withRaw?: boolean;
} & RequestInit): Promise<FetchResult<ExerciseWithoutDefaults[] | null>> {
  const cleanedSlug = cleanSlug(slug);
  const { data, error } = await fetcher<Exercise[]>({
    endpoint: `${PREFIX}/${cleanedSlug}`,
    options: {
      method: "GET",
      ...base,
    },
    useInternalAuth: true,
  });

  return { data, error };
}
```

**Why Internal Auth for All Calls?**

- All AI tools (`packages/ai/tools/`) call content endpoints
- These are internal systems, not external developers
- They should always use internal auth

**Output**: All content API calls use internal auth

---

### Subtask 1.3.3: Update Environment Variable Handling

Ensure `INTERNAL_CONTENT_API_KEY` is available in fetcher package.

**File to modify**: `packages/connection/env.ts` (if exists, otherwise create)

**Changes Required**:

```typescript
import { createEnv } from "@t3-oss/env-nextjs";
import * as z from "zod";

export const env = createEnv({
  server: {
    INTERNAL_CONTENT_API_KEY: z.string().min(1),
  },
  client: {},
  runtimeEnv: {
    INTERNAL_CONTENT_API_KEY: process.env.INTERNAL_CONTENT_API_KEY,
  },
});
```

**Usage in fetcher**:

```typescript
import { env } from "@repo/connection/env";

const internalApiKey = env.INTERNAL_CONTENT_API_KEY;
```

**Alternative** (if env file already exists):

- Just add field to existing schema

**Output**: Internal API key accessible in connection package

---

### Subtask 1.3.4: Test Internal Auth in AI Tools

Verify AI tools can fetch content with new authentication.

**Test File**: `packages/connection/lib/__tests__/fetcher-internal-auth.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { fetcher } from "../fetcher";

describe("fetcher with internal auth", () => {
  describe("internal authentication", () => {
    it("should include Authorization header when useInternalAuth=true", async () => {
      const mockKy = vi.fn().mockResolvedValue({});

      await fetcher({
        endpoint: "/contents/en/articles",
        options: { method: "GET" },
        useInternalAuth: true,
      });

      expect(mockKy).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.objectContaining({
            Authorization: expect.stringMatching(/^Bearer .+/),
          }),
        })
      );
    });

    it("should throw error if internal key not configured", async () => {
      const originalKey = process.env.INTERNAL_CONTENT_API_KEY;
      delete process.env.INTERNAL_CONTENT_API_KEY;

      await expect(fetcher({
        endpoint: "/contents/en/articles",
        options: { method: "GET" },
        useInternalAuth: true,
      })).rejects.toThrow("INTERNAL_CONTENT_API_KEY not configured");

      process.env.INTERNAL_CONTENT_API_KEY = originalKey;
    });
  });

  describe("default behavior", () => {
    it("should default to useInternalAuth=false", async () => {
      const mockKy = vi.fn().mockResolvedValue({});

      await fetcher({
        endpoint: "/contents/en/articles",
        options: { method: "GET" },
      });

      expect(mockKy).toHaveBeenCalledWith(
        expect.any(String),
        expect.objectContaining({
          headers: expect.not.objectContaining({
            Authorization: expect.anything(),
          }),
        })
      );
    });
  });
});
```

**Expected Results**:

- `useInternalAuth: true` adds Authorization header
- `useInternalAuth: false` omits Authorization header
- Default is `false` (backward compatible)
- Header format is `Bearer ${key}`

**Output**: Comprehensive test coverage

---

### Subtask 1.3.5: Integration Test with AI Tools

Test that AI tools (`packages/ai/tools/content.ts`) can fetch content end-to-end.

**Test Scenario**:

**1. Local API with Internal Auth**:

```bash
# 1. Ensure INTERNAL_CONTENT_API_KEY is set locally
echo "INTERNAL_CONTENT_API_KEY=test-key" > apps/api/.env.local

# 2. Start API app
pnpm --filter api dev

# 3. Test fetcher directly
pnpm --filter connection test

# 4. Test AI tool
# In packages/ai/tools/content.test.ts, run:
await api.contents.getContent({ slug: "en/subject/mathematics" });
```

**Expected Flow**:

```txt
AI Tool ‚Üí fetcher (useInternalAuth: true)
         ‚Üì
         Adds: Authorization: Bearer ${INTERNAL_API_KEY}
         ‚Üì
         ‚Üí /contents/en/subject/mathematics (protected route)
         ‚Üì
         Validates internal key via requireInternalApiKey()
         ‚Üì
         Returns content (200 OK)
```

**2. Verification**:

- No 401 errors
- Content returned successfully
- AI tools work as before

**Output**: Verified integration

---

## üöÄ Next Steps

After completing this task:

1. **Phase 1 Complete**: All internal content endpoints secured
2. **Next phase**: Task 2.1 - Create Content List Endpoint (Phase 2: Build Public Content API)

## üîó Related Tasks

- Task 0.1: Internal API Key Storage (provides key to use)
- Task 1.1: Create Internal Auth Middleware (validates the key)
- Task 1.2: Apply Internal Auth to Content Routes (protected endpoints now check for this key)
- Task 2.1: Create Content List Endpoint (public API for external developers)
- Packages/ai/tools/content.ts: Uses content endpoints (must work with this change)

## ‚ö†Ô∏è Important Notes

### No Breaking Changes

- AI tools work exactly as before (they just pass `useInternalAuth: true` now)
- No changes needed in `packages/ai/tools/` files
- Backward compatible with existing code

### Environment Variable Required

- `INTERNAL_CONTENT_API_KEY` must be set in:
  - Vercel environment variables (production)
  - `.env.local` for local development
  - Convex environment variables (if fetcher runs in Convex context)

### Monitoring After Deployment

Watch for these errors in logs:

- `INTERNAL_CONTENT_API_KEY not configured` (indicates missing env var)
- Unexpected 401 errors from `/contents/*` (indicates key mismatch)
- AI tool failures (indicates fetcher not adding auth correctly)

### Future Enhancement

Consider adding `useApiKey` parameter for public API support:

```typescript
// Future: Support both internal and public API keys
export async function fetcher<T>({
  url,
  endpoint,
  options,
  useInternalAuth,
  apiKey,
}: { ... }): Promise<FetchResult<T | null>> {
  if (useInternalAuth) {
    headers["Authorization"] = `Bearer ${process.env.INTERNAL_CONTENT_API_KEY}`;
  } else if (apiKey) {
    headers["Authorization"] = `Bearer ${apiKey}`;
  }
}
```

This will be used in Phase 2 (Public API).

## Progress Tracking

After completing this task, update `plans/api-monetization/progress.txt`:

```text
[YYYY-MM-DD HH:mm] Task 1.3 completed

Key decisions:
- All content API calls default to useInternalAuth=true
- Keep backward compatibility by defaulting to false
- Throw clear error if INTERNAL_CONTENT_API_KEY not configured

Files changed:
- packages/connection/lib/fetcher.ts
- packages/connection/routes/contents.ts
- packages/connection/env.ts (if created)
- packages/connection/lib/__tests__/fetcher-internal-auth.test.ts

Blockers/notes:
- None. Phase 1 complete, ready for Phase 2.
```
