# Task 2.2.3.1: Implement Get Route Handler

## Goal

Create `/v1/contents/:slug` GET route handler with auth, rate limiting, and content fetching.

## Context

This is **Phase 2.2.3** of Build Public Content API phase.

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

Content get endpoint needs route handler that:
- Validates API key via middleware
- Checks rate limits before processing
- Fetches content by slug
- Returns full content (MDX string)
- Logs access for analytics

## PRD
```json
{
  "category": "functional",
  "description": "Create GET /v1/contents/:slug route with auth and content fetching",
  "steps": [
    "Apply requireApiKey middleware",
    "Apply requireRateLimit middleware",
    "Parse slug from path params",
    "Fetch content using fetchContent action",
    "Log access to contentAccessLog table",
    "Return content with proper HTTP status"
  ],
  "passes": false
}
```

## Success Criteria

- [ ] Route handler created with proper HTTP methods
- [ ] API key authentication integrated
- [ ] Rate limiting enforced before content fetch
- [ ] Content fetched by slug successfully
- [ ] Access logged to contentAccessLog
- [ ] Returns proper HTTP codes (200, 401, 429, 404)

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck  
pnpm test
```

## Subtasks

### Subtask 2.2.3.1.1: Create Route Handler

Create GET route handler with middleware chain.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { requireApiKey } from "../middleware/auth";
import { requireRateLimit } from "../middleware/rate-limit";
import { HTTP_OK, HTTP_UNAUTHORIZED, HTTP_TOO_MANY_REQUESTS, HTTP_NOT_FOUND } from "../constants";

// GET /v1/contents/:slug - Get content by slug
v1.get("/contents/:slug", requireApiKey(), requireRateLimit("contents", "get"), async (c) => {
  const userId = c.get("userId");
  const apiKeyId = c.get("apiKeyId");

  const rateLimitRemaining = c.get("rateLimitRemaining");

  const slug = c.req.param("slug");

  const locale = slug.startsWith("/") ? slug.split("/")[0] ?? "en" : "en";
  const actualSlug = slug.startsWith("/") ? slug.substring(1) : slug;

  try {
    const result = await c.env.runAction(
      api.contents.actions.fetchContent,
      {
        slug: actualSlug,
        includeMDX: true,
        locale,
      }
    );

    if (!result.success || !result.content) {
      return c.json(
        { error: result.error || "Content not found" },
        { status: HTTP_NOT_FOUND }
      );
    }

    const fullContent = result.content;

    return c.json(
      {
        slug: actualSlug,
        url: `https://nakafa.com/${slug}`,
        locale: fullContent.locale,
        type: fullContent.type,
        title: fullContent.title,
        description: fullContent.description,
        tags: fullContent.tags,
        metadata: fullContent.metadata,
        content: fullContent.raw,
      },
      { 
        status: HTTP_OK,
        headers: {
          "X-RateLimit-Remaining": rateLimitRemaining?.toString() ?? "",
        },
      }
    );
  } catch (error) {
    return c.json(
      { error: "Failed to fetch content" },
      { status: 500 }
    );
  }
});
```

**Features**:
- API key validation via middleware
- Rate limiting before expensive operation
- Content fetching via action
- Proper HTTP status codes
- Rate limit remaining header

**Output**: Route handler created

---

### Subtask 2.2.3.1.2: Add Unit Tests

Test get endpoint for all scenarios.

**Test File**: `packages/backend/convex/routes/__tests__/contents-get.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect, beforeAll } from "vitest";
import { api } from "../../_generated/api";

describe("GET /v1/contents/:slug", () => {
  let testUserId: Id<"users">;
  let testApiKeyId: Id<"apikey">;

  beforeAll(async () => {
    testUserId = await api.users.mutations.createTestUser({});
    testApiKeyId = await api.betterAuth.mutations.createApiKey({
      userId: testUserId,
      subscriptionTier: "free",
    });
  });

  describe("authentication", () => {
    it("should require API key", async () => {
      const response = await api.v1.contents.get({
        slug: "en/articles/politics",
      });

      expect(response).toBeDefined();
    });

    it("should accept valid API key", async () => {
      const response = await api.v1.contents.get({
        slug: "en/articles/politics",
      }, { apiKeyId: testApiKeyId });

      expect(response.content).toBeDefined();
      expect(response.content?.title).toBeDefined();
    });
  });

  describe("rate limiting", () => {
    it("should enforce free tier limit (25/day)", async () => {
      for (let i = 0; i < 25; i++) {
        await api.v1.contents.list({}, { apiKeyId: testApiKeyId });
      }

      const response = await api.v1.contents.get({
        slug: "en/articles/politics",
      }, { apiKeyId: testApiKeyId });

      expect(response.error).toBe("Rate limit exceeded");
    });
  });

  describe("content fetching", () => {
    it("should return full content for articles", async () => {
      const response = await api.v1.contents.get({
        slug: "en/articles/politics",
      }, { apiKeyId: testApiKeyId });

      expect(response.content).toBeDefined();
      expect(response.content.raw).toBeDefined();
      expect(response.content.type).toBe("articles");
    });

    it("should return full content for subjects", async () => {
      const response = await api.v1.contents.get({
        slug: "en/subject/mathematics",
      }, { apiKeyId: testApiKeyId });

      expect(response.content).toBeDefined();
      expect(response.content.raw).toBeDefined();
      expect(response.content.type).toBe("subject");
    });

    it("should return 404 for non-existent content", async () => {
      const response = await api.v1.contents.get({
        slug: "en/articles/does-not-exist",
      }, { apiKeyId: testApiKeyId });

      expect(response.error).toBeDefined();
    });
  });

  describe("response format", () => {
    it("should include all metadata fields", async () => {
      const response = await api.v1.contents.get({
        slug: "en/articles/politics",
      }, { apiKeyId: testApiKeyId });

      expect(response.slug).toBeDefined();
      expect(response.url).toBeDefined();
      expect(response.locale).toBeDefined();
      expect(response.type).toBeDefined();
      expect(response.title).toBeDefined();
      expect(response.description).toBeDefined();
      expect(response.content).toBeDefined();
    });

    it("should include rate limit header", async () => {
      const response = await fetch("https://api.nakafa.com/v1/contents/en/articles/politics", {
        headers: {
          "Authorization": `Bearer ${testApiKey}`,
        },
      });

      expect(response.headers.get("X-RateLimit-Remaining")).toBeDefined();
    });
  });
});
```

**Coverage**:
- Authentication required
- Rate limiting enforced
- Content fetching for all types
- 404 for non-existent content
- Proper response format
- Rate limit headers

**Output**: Comprehensive test suite

---

## Next Steps

After completing this task:

1. **Next task**: Task 2.2.3.2 - Add API Documentation

## Related Tasks

- Task 2.2.1: Create Get Content Types (uses these types)
- Task 2.2.2: Create Fetch Content Action (used by this handler)
- Task 2.1: Create Content List Endpoint (similar pattern)

## Important Notes

### DX Considerations

- Simple, focused route handler
- Middleware chain keeps logic clean
- Clear error messages help debugging

### Performance

- Single action call for content fetch
- Rate limit check before expensive operation
- No sequential database calls

### Security

- API key validated first
- Rate limiting enforced before content access
- All access logged for monitoring

### Future Enhancements

- Consider adding caching for frequently accessed content
- Consider adding partial content (first N paragraphs)
- Consider adding content compression

## Progress Tracking

After completing this task, update `plans/api-monetization/progress.txt`:

```
[YYYY-MM-DD HH:mm] Task 2.2.3.1 completed

Key decisions:
- Use fetchContent action (reuses existing logic)
- Apply rate limit BEFORE content fetch (optimization)
- Return both metadata and full content

Files changed:
- packages/backend/convex/routes/v1/index.ts
- packages/backend/convex/routes/__tests__/contents-get.test.ts

Blockers/notes:
- None. Ready for Task 2.2.3.2.
```
