# Task 4.5.2: Revoke Mutation (Fixed)

## Goal

Create mutation to revoke API keys with reason tracking using Better Auth's fields.

## Context

**Better Auth Already Provides**:
- ✅ `apikey` table with `enabled` field
- ✅ Built-in key management

**We Need**:
- Mutation to disable keys (set `enabled: false`)
- Store revocation reason in `metadata`
- Log to security events
- Send email notification

## PRD

```json
{
  "category": "functional",
  "description": "Mutation to revoke API keys using Better Auth",
  "steps": [
    "Create revokeKey mutation with v.object() validators",
    "Set enabled: false in Better Auth's apikey table",
    "Store revocation reason in metadata",
    "Log to securityEvents table",
    "Add tests"
  ],
  "passes": false
}
```

## Success

- [ ] Mutation created
- [ ] Key disabled in Better Auth
- [ ] Reason stored in metadata
- [ ] Security event logged
- [ ] Tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 4.5.2.1: Create Mutation

**File**: `packages/backend/convex/betterAuth/mutations/revokeApiKey.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { internalMutation } from "../../_generated/server";

export const revokeApiKey = internalMutation({
  args: v.object({
    apiKeyId: v.string(), // Better Auth uses string IDs
    reason: v.string(), // e.g., "scraping_detected", "user_request", "admin_action"
    revokedBy: v.optional(v.id("users")), // User who revoked it
  }),
  returns: v.object({
    success: v.boolean(),
    error: v.optional(v.string()),
  }),
  handler: async (ctx, args) => {
    const { apiKeyId, reason, revokedBy } = args;

    // Get API key from Better Auth
    const apiKey = await ctx.db
      .query("apikey")
      .withIndex("key")
      .eq("_id", apiKeyId)
      .unique();

    if (!apiKey) {
      return { success: false, error: "API key not found" };
    }

    // Check if already revoked
    if (apiKey.enabled === false) {
      return { success: false, error: "API key already revoked" };
    }

    const now = Date.now();

    // Get current metadata
    const metadata = apiKey.metadata
      ? JSON.parse(apiKey.metadata as string)
      : {};

    // Update Better Auth's apikey table
    await ctx.db.patch("apikey", apiKeyId, {
      enabled: false,
      metadata: JSON.stringify({
        ...metadata,
        revokedAt: now,
        revokedBy: revokedBy?.toString() ?? null,
        revokeReason: reason,
      }),
    });

    // Log security event
    await ctx.runMutation(internal.securityEvents.mutations.logEvent, {
      type: "api_key_revoked",
      severity: reason.includes("scraping") ? "critical" : "warning",
      apiKeyId,
      userId: revokedBy,
      details: JSON.stringify({
        reason,
        previousEnabled: apiKey.enabled,
      }),
    });

    // Schedule email notification (if user-initiated)
    if (reason === "user_request" && apiKey.userId) {
      // Get app user from Better Auth userId
      const appUser = await ctx.db
        .query("users")
        .withIndex("authId")
        .eq("authId", apiKey.userId)
        .unique();

      if (appUser) {
        await ctx.scheduler.runAfter(
          0,
          internal.emails.mutations.sendApiKeyRevokedEmail,
          {
            userId: appUser._id,
            keyName: apiKey.name ?? "Unnamed Key",
            reason,
          }
        );
      }
    }

    return { success: true };
  },
});
```

**Output**: Mutation created

---

### Subtask 4.5.2.2: Add Tests

**File**: `packages/backend/convex/betterAuth/__tests__/revokeApiKey.test.ts`

**Tests**:

```typescript
describe("revokeApiKey", () => {
  let testUserId;
  let testApiKeyId;

  beforeAll(async () => {
    testUserId = await createTestUser();
    const result = await createApiKey({
      userId: testUserId,
      name: "Test Key",
      subscriptionTier: "free",
    });
    testApiKeyId = result.apiKeyId;
  });

  it("should revoke API key", async () => {
    const result = await revokeApiKey({
      apiKeyId: testApiKeyId,
      reason: "scraping_detected",
      revokedBy: testUserId,
    });

    expect(result.success).toBe(true);

    // Check key is disabled
    const apiKey = await ctx.db.get("apikey", testApiKeyId);
    expect(apiKey?.enabled).toBe(false);
  });

  it("should store revocation reason in metadata", async () => {
    await revokeApiKey({
      apiKeyId: testApiKeyId,
      reason: "abuse_detected",
    });

    const apiKey = await ctx.db.get("apikey", testApiKeyId);
    const metadata = JSON.parse(apiKey.metadata);
    expect(metadata.revokeReason).toBe("abuse_detected");
    expect(metadata.revokedAt).toBeDefined();
  });

  it("should not revoke already revoked key", async () => {
    // Revoke it once
    await revokeApiKey({
      apiKeyId: testApiKeyId,
      reason: "first_revoke",
    });

    // Try to revoke again
    const result = await revokeApiKey({
      apiKeyId: testApiKeyId,
      reason: "second_revoke",
    });

    expect(result.success).toBe(false);
    expect(result.error).toBe("API key already revoked");
  });

  it("should log security event", async () => {
    await revokeApiKey({
      apiKeyId: testApiKeyId,
      reason: "admin_action",
      revokedBy: testUserId,
    });

    const events = await ctx.runQuery(
      internal.securityEvents.queries.listEvents,
      { apiKeyId: testApiKeyId }
    );

    const revokeEvent = events.find((e) => e.type === "api_key_revoked");
    expect(revokeEvent).toBeDefined();

    const details = JSON.parse(revokeEvent.details);
    expect(details.reason).toBe("admin_action");
  });

  it("should mark severity as critical for scraping", async () => {
    await revokeApiKey({
      apiKeyId: testApiKeyId,
      reason: "scraping_detected",
    });

    const events = await ctx.runQuery(
      internal.securityEvents.queries.listEvents,
      { apiKeyId: testApiKeyId }
    );

    const revokeEvent = events.find((e) => e.type === "api_key_revoked");
    expect(revokeEvent.severity).toBe("critical");
  });

  it("should mark severity as warning for user request", async () => {
    await revokeApiKey({
      apiKeyId: testApiKeyId,
      reason: "user_request",
    });

    const events = await ctx.runQuery(
      internal.securityEvents.queries.listEvents,
      { apiKeyId: testApiKeyId }
    );

    const revokeEvent = events.find((e) => e.type === "api_key_revoked");
    expect(revokeEvent.severity).toBe("warning");
  });

  it("should throw error for non-existent key", async () => {
    const result = await revokeApiKey({
      apiKeyId: "non-existent-key",
      reason: "test",
    });

    expect(result.success).toBe(false);
    expect(result.error).toBe("API key not found");
  });
});
```

**Output**: Tests

---

## Next Steps

After: Task 4.5.3 - Unban Mutation

## Related

- Task 4.5.1: Revocation Helpers (complementary)
- Task 4.5.3: Unban (restore revoked keys)
- Task 2.5.1: Create API Key (creates keys that can be revoked)

## Progress

```
[YYYY-MM-DD HH:mm] Task 4.5.2 completed

Key decisions:
- Soft revoke (enabled: false instead of db.delete)
- Store revocation details in Better Auth's metadata field
- Log to securityEvents for audit trail
- Send email for user-initiated revocations

Files changed:
- packages/backend/convex/betterAuth/mutations/revokeApiKey.ts
- packages/backend/convex/betterAuth/__tests__/revokeApiKey.test.ts

Blockers: None
```

## Important Note

**Better Auth's apikey table has**:
- `enabled` field (boolean) - set to false to disable
- `metadata` field (string/JSON) - store revoke reason and timestamp
- `userId` field (string) - Better Auth user ID (not Convex ID)

**We do not have**:
- `revokedAt` field in apikey table (use metadata instead)
- `lastRevokeReason` field (use metadata instead)
