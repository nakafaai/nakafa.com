# Task 4.5: Implement Automatic API Key Revocation

## üéØ Goal

Create system for automatic API key revocation on critical security violations.

## üìç Context

This is **Phase 4.5** of Anti-Scraping Layers phase.

Critical security violations should result in immediate API key revocation:

1. **Scraping patterns detected** (velocity, bulk, sequential access)
2. **API key sharing** (multiple IPs from same key)
3. **Rate limit abuse** (repeated violations)
4. **Manual admin requests** (investigations, policy violations)

This system provides:

- Automatic revocation (no manual intervention needed)
- Clear reason tracking (why key was revoked)
- Email notifications (via Resend - Task 5.2)
- Dashboard alerts for manual review
- Unban appeal process (for false positives)

## üé¨ Success Criteria

- [ ] `revokeApiKey()` mutation created
- [ ] Auto-revocation triggers defined (alert types, severities)
- [ ] Critical violations cause immediate revocation
- [ ] Warning violations logged but don't revoke
- [ ] Email notification sent via Resend
- [ ] Revoke reason stored in API key record
- [ ] Unban request workflow documented
- [ ] Unit tests for all scenarios
- [ ] Integration with scraping detection alerts

## üìù Subtasks

### Subtask 4.5.1: Define Revocation Reasons

Create standard revocation reasons and severity mapping.

**File to create**: `packages/backend/convex/apikeys/types.ts` (add to existing)

**Implementation**:

```typescript
export type RevocationReason =
  | "automated_scraping" // Automatic detection (Task 4.1, 4.2, 4.3)
  | "api_key_sharing" // Multiple IPs detected (Task 4.2)
  | "rate_limit_abuse" // Repeated violations (Task 4.1)
  | "manual_admin" // Admin manually revoked
  | "user_requested" // User requested revocation
  | "investigation_pending" // Under review (can be unbanned)
  | "false_positive" // Revoked in error, can be restored";

export interface RevocationSeverity {
  reason: RevocationReason;
  severity: "critical" | "warning" | "info";
}

const REVOCATION_SEVERITY: Record<RevocationReason, RevocationSeverity> = {
  automated_scraping: {
    reason: "automated_scraping",
    severity: "critical",
  },
  api_key_sharing: {
    reason: "api_key_sharing",
    severity: "critical",
  },
  rate_limit_abuse: {
    reason: "rate_limit_abuse",
    severity: "critical",
  },
  manual_admin: {
    reason: "manual_admin",
    severity: "info",
  },
  user_requested: {
    reason: "user_requested",
    severity: "info",
  },
  investigation_pending: {
    reason: "investigation_pending",
    severity: "warning",
  },
  false_positive: {
    reason: "false_positive",
    severity: "info",
  },
};
```

**Severity Levels**:

- **critical**: Auto-revoke immediately
- **warning**: Log alert, continue monitoring
- **info**: Informational revocation

**Revocation Flow**:

```
Critical Alert ‚Üí Auto-revoke ‚Üí Send email ‚Üí User sees dashboard ‚Üí (Can request review?)
                                                            ‚Üì (False positive ‚Üí Admin restores key)
Warning Alert ‚Üí Log alert ‚Üí Continue monitoring ‚Üí (Multiple warnings ‚Üí Escalate to critical?)
```

**Output**: Revocation reasons and severity mapping

---

### Subtask 4.5.2: Create Revoke API Key Mutation

Create mutation for API key revocation with reason tracking.

**File to modify**: `packages/backend/convex/apikeys/mutations/revoke.ts` (or create new file)

**Implementation**:

```typescript
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";

export const revokeApiKey = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
    reason: v.string(),
  },
  handler: async (ctx, args) => {
    const apiKey = await ctx.db.get("apikey", args.apiKeyId);

    if (!apiKey) {
      throw new Error("API key not found");
    }

    const now = Date.now();

    // Revoke API key
    await ctx.db.patch("apikey", args.apiKeyId, {
      enabled: false,
      revokedAt: now,
      lastRevokeReason: args.reason,
    });

    // Log revocation to security events
    await ctx.db.insert("securityEvents", {
      type: "api_key_revoked",
      severity: "critical",
      apiKeyId: args.apiKeyId,
      userId: apiKey.userId,
      details: JSON.stringify({
        reason: args.reason,
        timestamp: now,
      }),
      createdAt: now,
    });

    // Send email notification (will be implemented in Task 5.2)
    // TODO: await ctx.env.runAction(
    //   internal.emails.mutations.sendApiKeyRevoked,
    //   {
    //     userId: apiKey.userId,
    //     apiKeyId: args.apiKeyId,
    //     reason: args.reason,
    //   }
    // );

    return { success: true, revokedAt: now };
  },
});
```

**Features**:

- **Disabled**: Sets `enabled: false`
- **Tracked**: Records `revokedAt` and `lastRevokeReason`
- **Logged**: Adds to `securityEvents` table
- **Email notification**: Placeholder (Task 5.2)

**Output**: Revoke mutation

---

### Subtask 4.5.3: Create Unban API Key Mutation

Create mutation to restore falsely revoked API keys.

**File to create**: `packages/backend/convex/apikeys/mutations/unban.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";

export const unbanApiKey = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
    adminNotes: v.string(), // Admin notes on investigation
  },
  handler: async (ctx, args) => {
    const apiKey = await ctx.db.get("apikey", args.apiKeyId);

    if (!apiKey) {
      throw new Error("API key not found");
    }

    // Verify it was actually revoked
    if (apiKey.enabled !== false || !apiKey.revokedAt) {
      throw new Error("API key is not revoked");
    }

    const now = Date.now();

    // Re-enable API key
    await ctx.db.patch("apikey", args.apiKeyId, {
      enabled: true,
      lastRevokeReason: null, // Clear the reason
      revokedAt: null, // Clear revocation timestamp
    });

    // Log unban to security events
    await ctx.db.insert("securityEvents", {
      type: "api_key_unbanned",
      severity: "info",
      apiKeyId: args.apiKeyId,
      userId: apiKey.userId,
      details: JSON.stringify({
        adminNotes: args.adminNotes,
        timestamp: now,
      }),
      createdAt: now,
    });

    return { success: true, restoredAt: now };
  },
});
```

**Features**:

- **Restores**: Re-enables API key
- **Admin notes**: Tracks investigation results
- **Security logging**: All events in `securityEvents` table
- **Email notification**: Placeholder (Task 5.2)
- **Verification**: Only revoked keys can be unbanned

**Output**: Unban mutation

---

### Subtask 4.5.4: Create Security Events Table

Create schema for logging all security-related events.

**File to create**: `packages/backend/convex/schema.ts` (or new security-events.ts)

**Implementation**:

```typescript
import { defineTable } from "convex/server";

export const securityEvents = defineTable({
  type: v.string(), // "api_key_revoked", "api_key_unbanned", "scraping_alert", etc.
  severity: v.union(v.literal("critical"), v.literal("warning"), v.literal("info")),
  apiKeyId: v.id("apikey"),
  userId: v.id("users").optional(),
  details: v.string(), // JSON string with event details
  createdAt: v.number(),
});
}).index("apiKeyId_createdAt", ["apiKeyId", "createdAt"]); // Query recent events per key
```

**Purpose**:

- **Audit trail**: Track all security events
- **Dashboard data**: Feed for monitoring UI
- **Trend analysis**: Detect patterns over time
- **Compliance**: Evidence for policy enforcement

**Output**: Security events table

---

### Subtask 4.5.5: Integrate Auto-Revocation

Connect scraping detection alerts to automatic revocation.

**File to modify**: `packages/backend/convex/routes/v1/contents/utils.ts` (or create new scraping-detection.ts)

**Changes Required**:

```typescript
import { REVOCATION_SEVERITY } from "../../apikeys/types";
import type { ScrapingAlertResult } from "../routes/scraping/types";

export async function handleScrapingAlert(
  alert: ScrapingAlertResult
): Promise<void> {
  const severity = REVOCATION_SEVERITY[alert.alertType]?.severity || "warning";

  if (severity === "critical") {
    // Auto-revoke API key
    await apikeys.revokeApiKey({
      apiKeyId: alert.apiKeyId,
      reason: alert.alertType, // Use alert type directly as reason
    });
  }

  // Log alert to security events
  // TODO: Implement securityEvents.insert
}
```

**Integration Points**:

1. **Scraping detection** (Task 4.1) returns alert with `alertType` and `severity`
2. **Severity mapping** (REVOCATION_SEVERITY) determines if critical
3. **Critical alerts** ‚Üí Auto-revoke via `handleScrapingAlert()`
4. **Warning alerts** ‚Üí Log only, continue monitoring

**Output**: Auto-revocation integration

---

### Subtask 4.5.6: Add Unit Tests

Test auto-revocation and unban scenarios.

**File to create**: `packages/backend/convex/apikeys/__tests__/auto-revocation.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect, beforeAll } from "vitest";
import { api } from "../../_generated/api";
import { REVOCATION_SEVERITY } from "../types";

describe("Automatic API Key Revocation", () => {
  let testUserId: Id<"users">;
  let testApiKeyId: Id<"apikey">;

  beforeAll(async () => {
    // Create test user and API keys
    testUserId = await api.users.mutations.createTestUser({});
    testApiKeyId = await api.apikeys.mutations.createApiKey({
      userId: testUserId,
      tier: "free",
    });
  });

  describe("revokeApiKey", () => {
    it("should revoke API key for scraping", async () => {
      const result = await api.apikeys.revokeApiKey({
        apiKeyId: testApiKeyId,
        reason: "automated_scraping",
      });

      expect(result.success).toBe(true);

      const apiKey = await api.apikeys.queries.getApiKeyById(testApiKeyId);

      expect(apiKey?.enabled).toBe(false);
      expect(apiKey?.lastRevokeReason).toBe("automated_scraping");
      expect(apiKey?.revokedAt).toBeDefined();
    });

    it("should log security event", async () => {
      // Revoke and check security events table
      const apiKey = await api.apikeys.queries.getApiKeyById(testApiKeyId);

      const events = await api.security.queries.getApiKeySecurityEvents(testApiKeyId);

      expect(events.length).toBeGreaterThan(0);
      expect(events.some((e) => e.type === "api_key_revoked")).toBe(true);
      expect(events[events.length - 1].severity).toBe("critical");
    });

    it("should send email notification", async () => {
      // TODO: Mock email sending and verify
      // const events = await api.security.queries.getApiKeySecurityEvents(testApiKeyId);
      // expect(events.some((e) => e.details.includes("email_sent"))).toBe(true);
    });
  });

  describe("unbanApiKey", () => {
    it("should restore falsely revoked API key", async () => {
      const result = await api.apikeys.unbanApiKey({
        apiKeyId: testApiKeyId,
        adminNotes: "Investigated, no scraping detected",
      });

      expect(result.success).toBe(true);

      const apiKey = await api.apikeys.queries.getApiKeyById(testApiKeyId);

      expect(apiKey?.enabled).toBe(true);
      expect(apiKey?.lastRevokeReason).toBeNull();
      expect(apiKey?.revokedAt).toBeNull();
    });

    it("should not restore active API key", async () => {
      const result = await api.apikeys.unbanApiKey({
        apiKeyId: testApiKeyId,
      adminNotes: "Key was already active",
      });

      expect(result.success).toBe(false);
      expect(result.error?.message).toContain("not revoked");
    });

    it("should log unban event", async () => {
      const apiKey = await api.apikeys.queries.getApiKeyById(testApiKeyId);

      const events = await api.security.queries.getApiKeySecurityEvents(testApiKeyId);

      expect(events.some((e) => e.type === "api_key_unbanned")).toBe(true);
      expect(events.some((e) => e.severity).toBe("info");
      });
  });

  describe("severity mapping", () => {
    it("should map alert types to correct severity", () => {
      expect(REVOCATION_SEVERITY.automated_scraping.severity).toBe("critical");
      expect(REVOCATION_SEVERITY.api_key_sharing.severity).toBe("critical");
      expect(REVOCATION_SEVERITY.rate_limit_abuse.severity).toBe("critical");
      expect(REVOCATION_SEVERITY.manual_admin.severity).toBe("info");
      expect(REVOCATION_SEVERITY.user_requested.severity).toBe("info");
    });
  });
});
```

**Coverage**:

- ‚úÖ API key revoked for scraping
- ‚úÖ Security events logged
- ‚úÖ Email notification sent (mocked in tests)
- ‚úÖ Falsely revoked keys can be restored
- ‚úÖ Active keys can't be unbanned
- ‚úÖ Severity mapping correct

**Output**: Comprehensive test suite

---

### Subtask 4.5.7: Add API Documentation

Document automatic revocation for developers and admins.

**File to create**: `docs/api/auto-revocation.md`

**Content**:

```markdown
# Automatic API Key Revocation

## Overview
System automatically revokes API keys that exhibit scraping or abusive behavior to protect your content.

## Revocation Triggers

### Critical Triggers (Auto-Revoke Immediately)

| Trigger Type         | Description                                            | Example                          |
| -------------------- | ------------------------------------------------------ | -------------------------------- |
| **Scraping**         | Velocity, bulk, or sequential access patterns detected | 100 requests/60s, 50 unique/hour |
| **API Key Sharing**  | Same API key used from 5+ different IPs in 1 hour      | Botnet, distributed scraping     |
| **Rate Limit Abuse** | Repeated 429 errors or pattern of violations           | Exceeded limit 10x in day        |

### Warning Triggers (Log Only)

| Trigger                   | Description                                    |
| ------------------------- | ---------------------------------------------- |
| **Multiple Warnings**     | 3+ warnings in 24 hours (escalate to critical) | Repeated minor violations |
| **Investigation Pending** | Alert type is `investigation_pending`          | Admin reviewing case      |

## What Happens When Revoked

1. **API Key Status**: Set to `enabled: false`
2. **Revocation Reason**: Stored in `lastRevokeReason` field
3. **Timestamp**: `revokedAt` set to current time
4. **Email Sent**: Notification sent via email
5. **Security Event**: Logged to `securityEvents` table

## Checking Status

### Get API Key Details
```bash
curl "https://api.nakafa.com/v1/me" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

**Response**:

```json
{
  "tier": "pro",
  "apiKeyId": "abc123...",
  "name": "Production App",
  "enabled": false,
  "lastRevokeReason": "automated_scraping",
  "revokedAt": "2026-01-14T12:00:00.000Z"
}
```

### Security Events API

Get all security events for an API key (coming in Task 5.1).

```bash
curl "https://api.nakafa.com/v1/security-events?apiKeyId=abc123" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

## Unbanning Process

If your API key was falsely revoked:

1. Contact support with investigation details
2. Provide any relevant context (your use case, legitimate traffic patterns)
3. Admin reviews case and may unban the key
4. You'll receive email notification when unbanned

## Best Practices

1. **Avoid Triggers**
   - Don't use same API key from multiple locations simultaneously
   - Implement proper rate limiting in your code
   - Don't automate content access without adding delays

2. **Monitor Usage**
   - Check `/v1/me/usage` regularly
   - Stay within your tier limits
   - Upgrade to higher tier if needed

3. **Contact Support Early**
   - If you suspect your API key was mistakenly revoked
   - Provide context and investigation details

4. **Use Different Keys for Different Purposes**
   - Production vs. Staging
   - Different environments
   - Different applications

## FAQ

**Q: What triggers auto-revocation?**
A: Scraping detection (velocity, bulk, sequential access), API key sharing, and repeated rate limit violations.

**Q: Can I get my key back if it was a mistake?**
A: Yes, contact support with investigation details. Admin can unban keys that were falsely revoked.

**Q: Will I lose my usage stats when unbanned?**
A: Usage stats may not be retained when key is revoked and restored. Contact support for data retention policy.

**Q: How do I know if I'm triggering scraping?**
A: Review your usage patterns:

- Free tier: 25 requests/day
- Pro tier: 1000/day, 100/min
- Enterprise: Unlimited but monitored

Stay within these limits to avoid automatic revocation.

**Output**: Developer documentation

---

## üöÄ Next Steps

After completing this task:

1. **Phase 4 Complete**: All anti-scraping layers active
2. **Next phase**: Task 5.1 - Create Security Dashboard UI (LATER)
3. **Next task**: Task 5.2 - Set Up Automated Alerts via Resend

## üîó Related Tasks

- Task 0.2: Extend Better Auth Schema (creates `securityEvents` table)
- Task 4.1: Implement Velocity-Based Scraping Detection (triggers revocation)
- Task 4.2: Implement IP-Based Rate Limiting (triggers revocation for IP rotation)
- Task 4.3: Add Request Signature Verification (adds evidence for decisions)
- Task 4.4: Add Content Watermarking (watermarks used as evidence)
- Task 5.2: Set Up Automated Alerts via Resend (emails on revocation)

## ‚ö†Ô∏è Important Notes

### Revocation vs Deletion

- **Revoked**: `enabled: false`, `revokedAt` set, reason stored
- **Deleted**: Key record removed from database entirely
- Falsely revoked keys can be restored (unban)
- Deleted keys can't be recovered

### Email Notifications

- Sent via Resend (Task 5.2)
- Includes revocation reason and timestamp
- Only sent for critical and some warnings
- User can opt-out of notification types

### False Positive Handling

- Investigation workflow for disputed revocations
- Admin dashboard can view unban requests
- All events logged in `securityEvents` table
- Admin notes capture investigation results

### Future Enhancements

- Consider adding **tier-based warnings** (warn users approaching limits)
- Consider adding **grace period** (temporary limit increase for legitimate burst)
- Consider adding **CAPTCHA** for suspicious request patterns
- Consider adding **webhooks** for revocation notifications to other systems

## ‚ö†Ô∏è Important Notes

### Security First Approach

- **Better safe than sorry**: Auto-revoke on detection, not after the fact
- **Clear communication**: Users understand why key was revoked
- **Evidence trail**: All events logged for review

### Implementation Priority

- **Phase 1-3**: Internal auth (MUST be done first)
- **Phase 4**: Anti-scraping layers (protects content)
- **Phase 5**: Monitoring (provides visibility and alerting)
- **Phase 6**: Testing (validates everything)

### DX Considerations

- **Clear status messages**: Users know exactly why their key was revoked
- **Actionable feedback**: Contact support link, unban request option
- **Documentation**: Comprehensive guides for avoiding triggers
