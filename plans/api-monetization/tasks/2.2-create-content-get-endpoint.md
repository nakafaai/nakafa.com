# Task 2.2: Create Content Get Endpoint

## üéØ Goal

Create `/v1/contents/:slug` endpoint for fetching single content by slug with full raw MDX content.

## üìç Context

This is **Phase 2.2** of Build Public Content API phase.

After developers discover content using the list endpoint (Task 2.1), they need a way to fetch the full content for a specific item.

This endpoint provides:

- Full raw MDX content (as string, not component)
- Complete metadata
- Rate limiting per API key tier
- Content watermarking for leak tracking
- Usage logging

## üé¨ Success Criteria

- [ ] `/v1/contents/:slug` endpoint created
- [ ] Requires API key authentication
- [ ] Returns full raw content (MDX string)
- [ ] Includes invisible watermark in response
- [ ] Rate limited per API key tier
- [ ] Usage logged to `contentAccessLog`
- [ ] Returns proper HTTP codes (200, 401, 404, 429)

## üìù Subtasks

### Subtask 2.2.1: Define Response Schema

Create TypeScript interface for single content response.

**File to create**: `packages/backend/convex/routes/v1/contents/get/types.ts`

**Implementation**:

```typescript
export interface GetContentResponse {
  slug: string;
  url: string;
  locale: string;
  type: "articles" | "subject" | "exercises" | "quran";
  metadata: {
    title: string;
    description?: string;
    tags?: string[];
    category?: string;
    grade?: string;
    material?: string;
    date?: number;
    updatedAt?: number;
    author?: string;
  };
  content: string; // Raw MDX as string
  watermark?: string; // Invisible watermark for leak tracking
}
```

**Key Design Decision**:

- `content` field is always a **string** (MDX text)
- Never returns MDX component or React element
- Consistent across API, MCP, and internal tools

**Output**: Type-safe response interface

---

### Subtask 2.2.2: Implement Route Handler

Create `/v1/contents/:slug` GET route with auth, rate limiting, and watermarking.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { requireApiKey } from "../middleware/auth";
import { getContent } from "@repo/contents/_lib/content";
import { HTTP_OK, HTTP_NOT_FOUND, HTTP_TOO_MANY_REQUESTS } from "../constants";

// GET /v1/contents/:slug - Get single content by slug
v1.get("/contents/:slug", requireApiKey({ contents: ["read"] }), async (c) => {
  const userId = c.get("userId");
  const apiKeyId = c.get("apiKeyId");
  const slug = c.req.param("slug");

  // Rate limit check
  const rateLimitResult = await c.env.runMutation(
    internal.betterAuth.mutations.checkRateLimit,
    {
      apiKeyId,
      resource: "contents",
      action: "get",
    }
  );

  if (!rateLimitResult.allowed) {
    return c.json(
      {
        error: "Rate limit exceeded",
        retryAfter: rateLimitResult.retryAfter,
      },
      { status: HTTP_TOO_MANY_REQUESTS }
    );
  }

  // Parse slug to extract locale and path
  const parsed = parseSlug(slug);
  if (!parsed) {
    return c.json(
      { error: "Invalid slug format" },
      { status: 400 }
    );
  }

  // Fetch content
  let contentData;
  try {
    contentData = await getContent(parsed.locale, parsed.path, {
      includeMDX: false,
    });
  } catch (error) {
    // Check if content not found
    if (error.message.includes("not found")) {
      return c.json(
        { error: "Content not found" },
        { status: HTTP_NOT_FOUND }
      );
    }

    return c.json(
      { error: "Failed to fetch content" },
      { status: 500 }
    );
  }

  // Generate watermark
  const watermark = generateWatermark(apiKeyId, slug);
  const watermarkedContent = watermark + "\n" + contentData.raw;

  // Build response
  const response: GetContentResponse = {
    slug,
    url: new URL(`/${slug}`, "https://nakafa.com").toString(),
    locale: parsed.locale,
    type: detectContentType(slug),
    metadata: {
      title: contentData.metadata.title,
      description: contentData.metadata.description,
      tags: contentData.metadata.tags,
      category: extractCategory(slug),
      grade: extractGrade(slug),
      material: extractMaterial(slug),
      date: contentData.metadata.date,
      updatedAt: contentData.metadata.updatedAt,
      author: contentData.metadata.author,
    },
    content: watermarkedContent,
    watermark,
  };

  // Log access
  await c.env.runMutation(
    internal.contents.mutations.logContentAccess,
    {
      apiKeyId,
      contentSlug: slug,
      action: "get",
      metadata: JSON.stringify({ locale: parsed.locale }),
    }
  );

  return c.json(response, { status: HTTP_OK });
});

function parseSlug(slug: string) {
  const parts = slug.split("/");
  if (parts.length < 2) {
    return null;
  }

  const locale = parts[0];
  const path = parts.slice(1).join("/");
  return { locale, path };
}

function generateWatermark(apiKeyId: Id<"apikey">, slug: string): string {
  const timestamp = Date.now();
  const hash = crypto
    .createHash("sha256")
    .update(`${apiKeyId}:${slug}:${timestamp}`)
    .digest("base64");

  return `<!-- NAK:API:${apiKeyId}:${hash}:${timestamp} -->`;
}
```

**Watermark Format**:

- Invisible HTML comment
- Contains API key ID (for attribution)
- Contains SHA-256 hash of key+slug+timestamp
- Used to trace leaked content back to source

**Output**: Functional route handler

---

### Subtask 2.2.3: Add Content Type Detection

Helper function to determine content type from slug.

**Implementation** (add to route file or separate utils):

```typescript
function detectContentType(slug: string): "articles" | "subject" | "exercises" | "quran" {
  if (slug.startsWith("articles") || slug.startsWith("en/articles") || slug.startsWith("id/articles")) {
    return "articles";
  }
  if (slug.startsWith("subject") || slug.startsWith("en/subject") || slug.startsWith("id/subject")) {
    return "subject";
  }
  if (slug.startsWith("exercises") || slug.startsWith("en/exercises") || slug.startsWith("id/exercises")) {
    return "exercises";
  }
  if (slug.startsWith("quran") || slug.startsWith("en/quran") || slug.startsWith("id/quran")) {
    return "quran";
  }
  return "subject"; // Default
}
```

**Output**: Content type detection

---

### Subtask 2.2.4: Add Unit Tests

Test all scenarios for content get endpoint.

**File to create**: `packages/backend/convex/routes/__tests__/contents-get.test.ts`

**Test Cases**:

```typescript
describe("GET /v1/contents/:slug", () => {
  describe("valid requests", () => {
    it("should return full content with valid API key", async () => {
      const response = await api.v1.contents.get(
        { slug: "en/subject/mathematics/algebra" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.content).toBeDefined();
      expect(response.content).toContain("<!-- NAK:API:");
      expect(response.metadata.title).toBe("Understanding Algebra");
      expect(response.type).toBe("subject");
    });

    it("should return content with correct locale", async () => {
      const response = await api.v1.contents.get(
        { slug: "id/subject/matematika/aljabar" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.locale).toBe("id");
      expect(response.content).toBeDefined();
    });
  });

  describe("error handling", () => {
    it("should return 404 for non-existent slug", async () => {
      const response = await api.v1.contents.get(
        { slug: "en/subject/nonexistent" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.error).toBe("Content not found");
      expect(response.status).toBe(404);
    });

    it("should return 400 for invalid slug format", async () => {
      const response = await api.v1.contents.get(
        { slug: "invalid-format" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.error).toBe("Invalid slug format");
      expect(response.status).toBe(400);
    });
  });

  describe("rate limiting", () => {
    it("should enforce rate limit", async () => {
      // Exhaust daily limit
      for (let i = 0; i < 25; i++) {
        await api.v1.contents.get(
          { slug: `en/articles/test-${i}` },
          { apiKeyId: testApiKeyId }
        );
      }

      // Next request should fail
      const response = await api.v1.contents.get(
        { slug: "en/articles/test-26" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.error).toBe("Rate limit exceeded");
      expect(response.retryAfter).toBeGreaterThan(0);
    });
  });

  describe("watermarking", () => {
    it("should include invisible watermark in response", async () => {
      const response = await api.v1.contents.get(
        { slug: "en/subject/mathematics/algebra" },
        { apiKeyId: testApiKeyId }
      );

      expect(response.watermark).toBeDefined();
      expect(response.content).toMatch(/<!-- NAK:API:.*-->/);
      expect(response.watermark).toContain(testApiKeyId);
    });
  });
});
```

**Coverage**:

- ‚úÖ Valid slug returns full content
- ‚úÖ Invalid slug returns 404
- ‚úÖ Invalid format returns 400
- ‚úÖ Rate limiting enforced
- ‚úÖ Watermark included in response
- ‚úÖ Metadata fields populated correctly

**Output**: Comprehensive test suite

---

### Subtask 2.2.5: Add API Documentation

Document the `/v1/contents/:slug` endpoint for developers.

**File to create**: `docs/api/contents-get.md`

**Content**:

```markdown
# Get Content by Slug

## Endpoint
`GET /v1/contents/:slug`

## Description
Retrieves full content (raw MDX) for a specific item by slug. Content includes invisible watermark for leak tracking.

## Authentication
Requires valid API key via `Authorization: Bearer <key>` header.

## Path Parameters

| Parameter | Type   | Required | Description                                      |
| --------- | ------ | -------- | ------------------------------------------------ |
| `slug`    | string | Yes      | Content slug in format: `{locale}/{type}/{path}` |

## Rate Limits

| Tier       | Daily Limit | Minute Limit |
| ---------- | ----------- | ------------ |
| Free       | 25          | N/A          |
| Pro        | 1,000       | 100          |
| Enterprise | Unlimited   | Unlimited    |

## Example Request

```bash
curl "https://api.nakafa.com/v1/contents/en/subject/mathematics/algebra" \
  -H "Authorization: Bearer YOUR_API_KEY"
```

## Example Response

```json
{
  "slug": "en/subject/mathematics/algebra",
  "url": "https://nakafa.com/en/subject/mathematics/algebra",
  "locale": "en",
  "type": "subject",
  "metadata": {
    "title": "Understanding Algebra",
    "description": "A comprehensive guide to algebraic concepts...",
    "tags": ["mathematics", "algebra"],
    "category": "mathematics",
    "grade": "10",
    "material": "algebra",
    "date": 1705228800000,
    "updatedAt": 1705228800000,
    "author": "Nakafa Team"
  },
  "content": "<!-- NAK:API:abc123:xyz789:1705228800000 -->\n\n# Understanding Algebra\n\nAlgebra is the study of...",
  "watermark": "<!-- NAK:API:abc123:xyz789:1705228800000 -->"
}
```

### Notes

1. **Content Format**: The `content` field is always a string containing raw MDX text. It's **not** a React component or serialized object.

2. **Watermark**: Invisible HTML comment at the start of content. Can be parsed to trace leaks.

3. **Metadata**: Includes all content metadata for display and filtering.

## Error Responses

### 401 Unauthorized

```json
{
  "error": "Missing or invalid API key"
}
```

### 404 Not Found

```json
{
  "error": "Content not found"
}
```

### 429 Rate Limit Exceeded

```json
{
  "error": "Rate limit exceeded",
  "retryAfter": 3600
}
```

**Output**: Developer documentation

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 2.3 - Create Content Search Endpoint
2. **Phase 2**: Continue building public API

## üîó Related Tasks

- Task 2.1: Create Content List Endpoint (for discovery, this is for fetching)
- Task 2.3: Create Content Search Endpoint (alternative to browsing)
- Task 2.4: Implement Tiered Rate Limiting (rate limit mutation used)
- Task 4.4: Add Content Watermarking (watermark function used)

## ‚ö†Ô∏è Important Notes

### Watermarking Strategy

- **Invisible**: Doesn't affect rendering (HTML comment)
- **Traceable**: Contains API key ID to identify source
- **Time-stamped**: Helps identify when content was accessed
- **Hashed**: Prevents tampering detection

### Content Format

- **Always string**: Raw MDX text, never components
- **Consistent**: Same format across API, MCP, internal tools
- **Developer-friendly**: Easy to parse, display, store

### Rate Limiting

- Same limits as list endpoint
- Free: 25/day total (list + get combined)
- Pro: 100/min, 1000/day total
- Enterprise: Unlimited but monitored

### Security

- Watermark enables leak attribution
- Rate limiting prevents bulk downloads
- API key validation before content access
- All requests logged to `contentAccessLog`

### Future Enhancements

- Consider adding `format` parameter (raw, markdown, html)
- Consider adding `version` parameter (get specific content version)
- Consider caching response for frequently accessed content
