# Task 2.5: Create API Key Management Endpoints

## üéØ Goal

Create endpoints for developers to self-service API keys (generate, list, revoke, update tier).

## üìç Context

This is **Phase 2.5** of Build Public Content API phase.

Developers need a way to:

1. **Generate API keys** for their account
2. **View their existing keys** (with usage and status)
3. **Revoke compromised keys**
4. **Update subscription tier** (Free ‚Üí Pro ‚Üí Enterprise)

This enables:

- Self-service without support tickets
- Quick key rotation
- Tier upgrades/downgrades
- API key lifecycle management

## üé¨ Success Criteria

- [ ] `POST /v1/api-keys` endpoint (generate new key)
- [ ] `GET /v1/api-keys` endpoint (list user's keys)
- [ ] `DELETE /v1/api-keys/:id` endpoint (revoke key)
- [ ] `PATCH /v1/api-keys/:id` endpoint (update tier)
- [ ] All require Better Auth session (not API key)
- [ ] Keys only shown once (on creation)
- [ ] Secure random key generation
- [ ] Proper error handling

## üìù Subtasks

### Subtask 2.5.1: Define Key Management Schemas

Create TypeScript interfaces for API key operations.

**File to create**: `packages/backend/convex/routes/v1/api-keys/types.ts`

**Implementation**:

```typescript
export interface CreateApiKeyRequest {
  name: string; // Friendly name (e.g., "Production", "Testing")
  tier: "free" | "pro" | "enterprise";
  permissions?: {
    contents?: string[]; // ["read", "list", "search"]
  };
}

export interface ApiKey {
  id: string; // Truncated key (first 8 chars + "...")
  name: string;
  tier: "free" | "pro" | "enterprise";
  permissions: {
    contents: string[];
  };
  createdAt: number;
  lastUsedAt: number | null;
  usageToday: number;
  usageThisMonth: number;
  enabled: boolean;
  revokedAt: number | null;
  revokeReason: string | null;
}

export interface CreateApiKeyResponse {
  apiKeyId: string;
  apiKey: string; // Full key shown ONLY once
  name: string;
  tier: string;
  permissions: any;
  createdAt: number;
  warning: string; // "Save this key now, you won't see it again"
}

export interface ListApiKeysResponse {
  keys: ApiKey[];
}

export interface RevokeApiKeyResponse {
  revoked: boolean;
  reason: string;
}

export interface UpdateTierRequest {
  tier: "free" | "pro" | "enterprise";
}
```

**Key Design Decisions**:

- **Show key once**: Only return full key on creation, truncated key on list
- **Self-service**: Users manage their own keys
- **Session auth**: Use Better Auth (not API key) for these endpoints

**Output**: Type-safe interfaces

---

### Subtask 2.5.2: Create Generate API Key Endpoint

Allow users to generate new API keys.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { requireAuthWithSession } from "../lib/authHelpers";
import { HTTP_OK, HTTP_CREATED } from "../constants";

// POST /v1/api-keys - Generate new API key
v1.post("/api-keys", requireAuthWithSession(), async (c) => {
  const user = c.get("appUser"); // From Better Auth session

  if (!user) {
    return c.json(
      { error: "User not found" },
      { status: 401 }
    );
  }

  const body: CreateApiKeyRequest = await c.req.json();

  // Validate request
  if (!body.name || body.name.trim().length === 0) {
    return c.json(
      { error: "Name is required" },
      { status: 400 }
    );
  }

  if (
!["free", "pro", "enterprise"].includes(body.tier)
) {
    return c.json(
      { error: "Invalid tier. Must be: free, pro, or enterprise" },
      { status: 400 }
    );
  }

  // Generate API key
  const apiKeyId = crypto.randomUUID();
  const fullApiKey = `nak_pk_${generateSecureRandom(64)}`;

  // Create API key record
  const now = Date.now();
  const limits = TIER_LIMITS[body.tier];

  const newKeyId = await c.env.runMutation(
    internal.apikeys.mutations.createApiKey,
    {
      userId: user._id,
      key: fullApiKey,
      name: body.name,
      tier: body.tier,
      permissions: body.permissions || { contents: ["read", "list", "search"] },
      rateLimitDaily: limits.rateLimitDaily,
      rateLimitMinute: limits.rateLimitMinute,
      enabled: true,
      createdAt: now,
    }
  );

  // Build response (show full key only once)
  const response: CreateApiKeyResponse = {
    apiKeyId: newKeyId,
    apiKey: fullApiKey, // ‚ö†Ô∏è Shown only on creation
    name: body.name,
    tier: body.tier,
    permissions: body.permissions || { contents: ["read", "list", "search"] },
    createdAt: now,
    warning:
      "IMPORTANT: Save this API key now. For security, it won't be shown again. " +
      "If you lose it, generate a new key.",
  };

  return c.json(response, { status: HTTP_CREATED });
});

function generateSecureRandom(length: number): string {
  const chars =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}
```

**Features**:

- **Secure generation**: 64-character cryptographically random string
- **Tier selection**: Free, Pro, Enterprise
- **Permissions**: Default full permissions, customizable
- **One-time display**: Warning that key won't be shown again
- **Usage tracking**: Initialize counters

**Output**: Generate key endpoint

---

### Subtask 2.5.3: Create List API Keys Endpoint

Allow users to view their existing API keys.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { HTTP_OK } from "../constants";

// GET /v1/api-keys - List user's API keys
v1.get("/api-keys", requireAuthWithSession(), async (c) => {
  const user = c.get("appUser");

  if (!user) {
    return c.json(
      { error: "User not found" },
      { status: 401 }
    );
  }

  // Fetch user's API keys
  const apiKeys = await c.env.runQuery(
    internal.apikeys.queries.getUserApiKeys,
    { userId: user._id }
  );

  // Build response with truncated keys
  const response: ListApiKeysResponse = {
    keys: apiKeys.map((key) => ({
      id: key._id,
      name: key.name,
      tier: key.subscriptionTier || "free",
      permissions: key.permissions,
      createdAt: key.createdAt,
      lastUsedAt: key.lastRequestTime,
      usageToday: key.requestsToday, // From apiKeyUsage table
      usageThisMonth: key.requestsThisMonth, // If tracking monthly
      enabled: key.enabled !== true ? false : true, // Invert boolean
      revokedAt: key.revokedAt,
      revokeReason: key.lastRevokeReason,
      apiKey: `${key.key.substring(0, 8)}...`, // Truncated
    })),
  };

  return c.json(response, { status: HTTP_OK });
});
```

**Features**:

- **Security**: Truncated keys (only show first 8 chars)
- **Full status**: Shows enabled/revoked status
- **Usage metrics**: Today's usage, last used timestamp
- **Session auth**: Requires logged-in user session

**Output**: List keys endpoint

---

### Subtask 2.5.4: Create Revoke API Key Endpoint

Allow users to revoke compromised or unused keys.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { HTTP_OK } from "../constants";

// DELETE /v1/api-keys/:id - Revoke API key
v1.delete("/api-keys/:id", requireAuthWithSession(), async (c) => {
  const user = c.get("appUser");
  const keyId = c.req.param("id");

  if (!user) {
    return c.json(
      { error: "User not found" },
      { status: 401 }
    );
  }

  // Validate key belongs to user
  const apiKey = await c.env.runQuery(
    internal.apikeys.queries.getApiKeyById,
    { keyId }
  );

  if (!apiKey || apiKey.userId !== user._id) {
    return c.json(
      { error: "API key not found or not owned by user" },
      { status: 404 }
    );
  }

  // Revoke key
  const now = Date.now();
  await c.env.runMutation(
    internal.apikeys.mutations.revokeApiKey,
    {
      keyId,
      revokedAt: now,
      reason: "user_revoked", // Distinguish from auto-revocation
    }
  );

  const response: RevokeApiKeyResponse = {
    revoked: true,
    reason:
      "API key revoked successfully. It can no longer be used. " +
      "Generate a new key if needed.",
  };

  return c.json(response, { status: HTTP_OK });
});
```

**Features**:

- **User-initiated**: Revoked by user (not automatic)
- **Ownership check**: Users can only revoke their own keys
- **Marked reason**: `user_revoked` to distinguish from auto-revocation
- **Disabled**: `enabled` set to `false`

**Output**: Revoke endpoint

---

### Subtask 2.5.5: Create Update Tier Endpoint

Allow users to upgrade/downgrade their API key tier.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Implementation**:

```typescript
import { HTTP_OK } from "../constants";

// PATCH /v1/api-keys/:id - Update API key tier
v1.patch("/api-keys/:id", requireAuthWithSession(), async (c) => {
  const user = c.get("appUser");
  const keyId = c.req.param("id");
  const body: UpdateTierRequest = await c.req.json();

  if (!user) {
    return c.json(
      { error: "User not found" },
      { status: 401 }
    );
  }

  // Validate tier
  if (!["free", "pro", "enterprise"].includes(body.tier)) {
    return c.json(
      { error: "Invalid tier" },
      { status: 400 }
    );
  }

  // Validate key belongs to user
  const apiKey = await c.env.runQuery(
    internal.apikeys.queries.getApiKeyById,
    { keyId }
  );

  if (!apiKey || apiKey.userId !== user._id) {
    return c.json(
      { error: "API key not found or not owned by user" },
      { status: 404 }
    );
  }

  // Update tier and limits
  const limits = TIER_LIMITS[body.tier];
  await c.env.runMutation(
    internal.apikeys.mutations.updateApiKeyTier,
    {
      keyId,
      tier: body.tier,
      rateLimitDaily: limits.rateLimitDaily,
      rateLimitMinute: limits.rateLimitMinute,
    }
  );

  return c.json(
    {
      message: "API key tier updated successfully",
      apiKeyId: keyId,
      tier: body.tier,
      newDailyLimit: limits.rateLimitDaily,
      newMinuteLimit: limits.rateLimitMinute,
    },
    { status: HTTP_OK }
  );
});
```

**Features**:

- **Tier upgrade/downgrade**: Free ‚Üî Pro ‚Üî Enterprise
- **Immediate effect**: Rate limits update instantly
- **Usage preserved**: Existing counters not reset
- **Audit trail**: Tier change logged

**Output**: Update tier endpoint

---

### Subtask 2.5.6: Add Unit Tests

Test all key management scenarios.

**File to create**: `packages/backend/convex/routes/__tests__/api-keys.test.ts`

**Test Cases**:

```typescript
describe("API Key Management", () => {
  describe("POST /v1/api-keys", () => {
    it("should generate secure random key", async () => {
      const response = await api.v1.apiKeys.create({
        name: "Test Key",
        tier: "free",
      });

      expect(response.apiKey).toMatch(/^nak_pk_[A-Za-z0-9]{64}$/);
      expect(response.apiKey.length).toBe(70); // nak_pk_ + 64 chars
      expect(response.warning).toContain("won't be shown again");
    });

    it("should validate name is required", async () => {
      const response = await api.v1.apiKeys.create({
        name: "",
        tier: "free",
      });

      expect(response.error).toBe("Name is required");
      expect(response.status).toBe(400);
    });

    it("should reject invalid tier", async () => {
      const response = await api.v1.apiKeys.create({
        name: "Test",
        tier: "invalid" as any,
      });

      expect(response.error).toContain("Invalid tier");
      expect(response.status).toBe(400);
    });
  });

  describe("GET /v1/api-keys", () => {
    it("should list user's keys with truncated API key", async () => {
      const response = await api.v1.apiKeys.list();

      expect(response.keys).toBeInstanceOf(Array);
      response.keys.forEach((key) => {
        expect(key.apiKey).toMatch(/^.{8}\.\.\.$/);
        expect(key.apiKey.length).toBe(11); // 8 chars + "..."
      });
    });

    it("should show correct usage metrics", async () => {
      const response = await api.v1.apiKeys.list();

      expect(response.keys[0].usageToday).toBeDefined();
      expect(response.keys[0].lastUsedAt).toBeDefined();
    });
  });

  describe("DELETE /v1/api-keys/:id", () => {
    it("should revoke user's own key", async () => {
      const response = await api.v1.apiKeys.revoke(testKeyId);

      expect(response.revoked).toBe(true);
      expect(response.reason).toContain("revoked successfully");
    });

    it("should reject revoking other user's key", async () => {
      const otherUserKey = await createApiKeyForUser("other");

      const response = await api.v1.apiKeys.revoke(otherUserKey);

      expect(response.error).toContain("not owned by user");
      expect(response.status).toBe(404);
    });
  });

  describe("PATCH /v1/api-keys/:id (update tier)", () => {
    it("should upgrade tier and update limits", async () => {
      const response = await api.v1.apiKeys.updateTier(testKeyId, {
        tier: "pro",
      });

      expect(response.tier).toBe("pro");
      expect(response.newDailyLimit).toBe(1000);
      expect(response.newMinuteLimit).toBe(100);
    });

    it("should preserve usage counters when upgrading", async () => {
      // Create key with usage
      await createTestUsage(testKeyId, 10);

      // Upgrade tier
      await api.v1.apiKeys.updateTier(testKeyId, { tier: "pro" });

      // Check usage preserved
      const keys = await api.v1.apiKeys.list();
      const upgradedKey = keys.find((k) => k.id === testKeyId);

      expect(upgradedKey?.usageToday).toBe(10);
    });
  });
});
```

**Coverage**:

- ‚úÖ Key generation with secure random
- ‚úÖ Truncated keys in list response
- ‚úÖ Revocation works
- ‚úÖ Tier updates work
- ‚úÖ Ownership validation
- ‚úÖ Error handling

**Output**: Comprehensive test suite

---

### Subtask 2.5.7: Add API Documentation

Document API key management for developers.

**File to create**: `docs/api/api-keys.md`

**Content**:

```markdown
# API Key Management

## Overview
Self-service API key management for generating, listing, revoking, and updating keys.

## Authentication
All API key management endpoints require **user session authentication** via Better Auth (not API key).

Use your existing login cookies or session tokens.

## Endpoints

### Generate API Key
`POST /v1/api-keys`

Creates a new API key for your account.

**Request Body**:
```json
{
  "name": "Production App",
  "tier": "pro",
  "permissions": {
    "contents": ["read", "list", "search"]
  }
}
```

**Parameters**:

| Parameter     | Type   | Required | Description                                       |
| ------------- | ------ | -------- | ------------------------------------------------- |
| `name`        | string | Yes      | Friendly name for the key                         |
| `tier`        | string | Yes      | Subscription tier: `free`, `pro`, or `enterprise` |
| `permissions` | object | No       | Optional permissions object                       |

**Permissions Object**:

| Resource   | Actions          | Description                               |
| ---------- | ---------------- | ----------------------------------------- |
| `contents` | Array of strings | Allowed actions: `read`, `list`, `search` |

**Response**:

```json
{
  "apiKeyId": "abc123...",
  "apiKey": "nak_pk_A1b2c3d4...",
  "name": "Production App",
  "tier": "pro",
  "permissions": {
    "contents": ["read", "list", "search"]
  },
  "createdAt": 1705228800000,
  "warning": "IMPORTANT: Save this API key now..."
}
```

‚ö†Ô∏è **Security Notice**: The `apiKey` is shown **only once**. Save it securely. If lost, generate a new key.

---

### List API Keys

`GET /v1/api-keys`

Returns all API keys for your account.

**Response**:

```json
{
  "keys": [
    {
      "id": "abc123",
      "name": "Production App",
      "tier": "pro",
      "permissions": {
        "contents": ["read", "list", "search"]
      },
      "apiKey": "nak_pk_A1...",
      "createdAt": 1705228800000,
      "lastUsedAt": 1705310000000,
      "usageToday": 45,
      "usageThisMonth": 1200,
      "enabled": true,
      "revokedAt": null,
      "revokeReason": null
    }
  ]
}
```

**Security Note**: `apiKey` is truncated to `nak_pk_A1...` for security.

---

### Revoke API Key

`DELETE /v1/api-keys/:id`

Revokes (disables) an API key.

**Response**:

```json
{
  "revoked": true,
  "reason": "API key revoked successfully. Generate a new key if needed."
}
```

**Path Parameter**:

| Parameter | Type   | Required | Description          |
| --------- | ------ | -------- | -------------------- |
| `id`      | string | Yes      | API key ID to revoke |

---

### Update API Key Tier

`PATCH /v1/api-keys/:id`

Updates the subscription tier for an API key.

**Request Body**:

```json
{
  "tier": "enterprise"
}
```

**Response**:

```json
{
  "message": "API key tier updated successfully",
  "apiKeyId": "abc123",
  "tier": "enterprise",
  "newDailyLimit": null,
  "newMinuteLimit": null
}
```

## Tiers and Limits

| Tier       | Daily Limit | Minute Limit | Price  |
| ---------- | ----------- | ------------ | ------ |
| Free       | 25          | N/A          | $0     |
| Pro        | 1,000       | 100          | $49    |
| Enterprise | Unlimited   | Unlimited    | Custom |

## Usage Metrics

When listing API keys, you'll see:

- `usageToday`: Requests made today (resets at midnight)
- `lastUsedAt`: Timestamp of last request
- `usageThisMonth`: Requests made this month (if tracked)
- `enabled`: Whether key is currently active

## Error Responses

### 400 Bad Request

```json
{
  "error": "Name is required"
}
```

### 401 Unauthorized

```json
{
  "error": "User not found"
}
```

### 404 Not Found

```json
{
  "error": "API key not found or not owned by user"
}
```

## Best Practices

1. **Store Securely**: Save API keys in environment variables, never commit to git
2. **Rotate Regularly**: Generate new keys every 3-6 months
3. **Revoke Compromised Keys**: Immediately revoke keys that may be exposed
4. **Use Appropriate Tier**: Free for testing, Pro/Enterprise for production
5. **Monitor Usage**: Check usage metrics regularly
6. **One-Time Display**: Save API key on creation, it won't be shown again

## Example: Generating and Using API Key

```typescript
// 1. Generate new key
const createResponse = await fetch("https://api.nakafa.com/v1/api-keys", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${USER_SESSION_TOKEN}`,
  },
  body: JSON.stringify({
    name: "My App",
    tier: "pro",
  }),
}).then((r) => r.json());

// 2. SAVE THE KEY! It won't be shown again.
const apiKey = createResponse.apiKey;
localStorage.setItem("NAKAFA_API_KEY", apiKey);

// 3. Use the key for requests
const content = await fetch("https://api.nakafa.com/v1/contents/en/subject/math", {
  headers: {
    "Authorization": `Bearer ${apiKey}`,
  },
}).then((r) => r.json());
```

```

**Output**: Developer documentation

---

## üöÄ Next Steps
After completing this task:
1. **Next task**: Task 2.6 - Add Usage Dashboard Endpoint
2. **Phase 2**: Continue building public API

## üîó Related Tasks
- Task 2.4: Implement Tiered Rate Limiting (limits applied to these keys)
- Task 2.1: Create Content List Endpoint (keys are used here)
- Task 4.5: Implement Automatic API Key Revocation (auto-revoke based on security violations)

## ‚ö†Ô∏è Important Notes

### Security Design
- **One-time display**: Keys only shown on creation for security
- **Truncated listing**: Lists show `nak_pk_A1b2c3...` format
- **Session auth**: User must be logged in to manage keys (not API key auth)

### Key Lifecycle
1. **Created**: In `enabled: true` state with initial counters
2. **Active**: Used for API requests, counters update
3. **Revoked**: `enabled: false`, `revokedAt` timestamp set
4. **Cannot be re-enabled**: Must generate new key (security best practice)

### Usage Tracking
- **Today's usage**: From `apiKeyUsage.requestsToday`
- **Last used**: From `apiKeyUsage.lastRequestTime`
- **Monthly tracking**: Can be added in future (currently not tracked)

### Future Enhancements
- Consider adding `usage history` endpoint (last 7 days of daily usage)
- Consider adding `usage by endpoint` (breakdown by API endpoint)
- Consider adding `download usage report` (CSV export)
- Consider adding `webhook notification` (on rate limit warning)
