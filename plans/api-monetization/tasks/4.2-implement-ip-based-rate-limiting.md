# Task 4.2: Implement IP-Based Rate Limiting

## üéØ Goal

Track and limit unique IP addresses per API key to prevent API key sharing and abuse.

## üìç Context

This is **Phase 4.2** of Anti-Scraping Layers phase.

Scrapers and abusers often:

1. **Share API keys** among multiple users/devices
2. **Distribute requests** across many IP addresses
3. **Rotate IPs** to evade detection
4. **Use botnets** to amplify scraping

This task creates IP tracking that:

- Logs IP addresses from each request
- Tracks unique IPs per API key over time windows
- Enforces tier-based IP limits
- Auto-blocks keys that rotate too many IPs

## üé¨ Success Criteria

- [ ] IP address extracted from requests and logged
- [ ] Unique IP counting works correctly
- [ ] Tier-based IP limits enforced (Free: 2 IPs/24h, Pro: 5 IPs/24h, Enterprise: unlimited)
- [ ] Auto-expire IP records after 24 hours
- [ ] Returns clear error message when limit exceeded
- [ ] Integration with `/v1/contents` endpoints

## üìù Subtasks

### Subtask 4.2.1: Extend Schema for IP Tracking

Add IP address tracking to content access logs.

**File to modify**: `packages/backend/convex/schema.ts` (or add via migration)

**Schema Addition**:

```typescript
// Update contentAccessLog table to include ipAddress field
// (Already exists, just ensuring it's populated)

// New table for IP tracking per API key
apiKeyIPs: defineTable({
  apiKeyId: v.id("apikey"),
  ipAddress: v.string(), // IPv4 or IPv6
  firstSeenAt: v.number(), // When this IP was first seen
  lastSeenAt: v.number(), // When this IP was last seen
  requestCount: v.number(), // Number of requests from this IP
}).index("apiKeyId_ipAddress", ["apiKeyId", "ipAddress"]).index("apiKeyId", ["apiKeyId"]);
```

**Purpose**:

- Track unique IPs per API key
- Detect IP rotation (key sharing pattern)
- Enforce tier-based IP limits
- Auto-expire old records (24 hours)

**Indexes**:

- `apiKeyId_ipAddress`: Fast lookup for existing IP records
- `apiKeyId`: List all IPs for a key

**Output**: Extended schema

---

### Subtask 4.2.2: Create IP Tracking Middleware

Log IP addresses and enforce limits.

**File to create**: `packages/backend/convex/routes/middleware/ip-tracking.ts`

**Implementation**:

```typescript
import type { MiddlewareHandler } from "hono";
import { HTTP_TOO_MANY_REQUESTS } from "../constants";
import type { ActionCtx } from "../../_generated/server";

const IP_LIMITS = {
  free: 2, // 2 IPs in 24 hours
  pro: 5, // 5 IPs in 24 hours
  enterprise: Number.MAX_SAFE_INTEGER, // Unlimited
} as const;

const IP_RECORD_EXPIRY_MS = 24 * 60 * 60 * 1000; // 24 hours

/**
 * IP tracking middleware.
 * Logs IP addresses and enforces tier-based limits.
 */
export const requireIPTracking = (): MiddlewareHandler<{
  Bindings: ActionCtx;
  Variables: {
    userId: string;
    apiKeyId: string;
  };
}> => {
  return async (c, next) => {
    const apiKeyId = c.get("apiKeyId");

    if (!apiKeyId) {
      return next(); // Skip if no API key
    }

    // Extract IP address from request
    const ipAddress = getIPAddress(c.req);

    if (!ipAddress) {
      return next(); // Can't track IP, allow request
    }

    // Get API key details (tier)
    const apiKey = await c.env.runQuery(
      internal.apikeys.queries.getApiKeyById,
      { keyId: apiKeyId }
    );

    if (!apiKey) {
      return next();
    }

    const tier = apiKey.subscriptionTier || "free";
    const maxIPs = IP_LIMITS[tier] ?? Number.MAX_SAFE_INTEGER;

    // Check if this IP has been seen before for this API key
    const existingRecord = await c.env.runQuery(
      internal.apikeys.queries.getApiKeyIP,
      {
        apiKeyId,
        ipAddress,
      }
    );

    const now = Date.now();

    if (existingRecord) {
      // Update last seen time and increment count
      await c.env.runMutation(
        internal.apikeys.mutations.updateAPIKeyIP,
        {
          apiKeyIPId: existingRecord._id,
          lastSeenAt: now,
          requestCount: existingRecord.requestCount + 1,
        }
      );
    } else {
      // Create new record
      await c.env.runMutation(
        internal.apikeys.mutations.createAPIKeyIP,
        {
          apiKeyId,
          ipAddress,
          firstSeenAt: now,
          lastSeenAt: now,
          requestCount: 1,
        }
      );
    }

    // Check IP count for this API key
    const allIPRecords = await c.env.runQuery(
      internal.apikeys.queries.getAPIKeyIPs,
      { apiKeyId }
    );

    // Count unique IPs (excluding old records > 24 hours)
    const activeIPs = allIPRecords.filter(
      (record) => now - record.lastSeenAt <= IP_RECORD_EXPIRY_MS
    );

    if (activeIPs.length > maxIPs) {
      return c.json(
        {
          error: "Too many unique IP addresses",
          message: `Your tier allows ${maxIPs} unique IPs in 24 hours`,
          currentIPs: activeIPs.length,
          retryAfter: calculateOldestIPReset(activeIPs),
        },
        {
          status: HTTP_TOO_MANY_REQUESTS,
          headers: {
            "Retry-After": calculateOldestIPReset(activeIPs),
            "X-IP-Limit": maxIPs.toString(),
            "X-IP-Count": activeIPs.length.toString(),
          },
        }
      );
    }

    // Clean up expired IP records
    await cleanupExpiredIPRecords(c.env, apiKeyId);

    // IP limit OK, proceed with request
    await next();
  };
};

/**
 * Extract IP address from request headers.
 * Checks X-Forwarded-For first (behind proxy/load balancer)
 * Falls back to CF-Connecting-IP if available
 */
function getIPAddress(req: Request): string | null {
  // Check for forwarded IP (behind proxy/load balancer)
  const forwardedFor = req.headers.get("X-Forwarded-For");
  if (forwardedFor) {
    return forwardedFor.split(",")[0].trim();
  }

  // Check for connecting IP (Cloudflare)
  const connectingIP = req.headers.get("CF-Connecting-IP");
  if (connectingIP) {
    return connectingIP;
  }

  return null; // Can't determine IP
}

function calculateOldestIPReset(records: any[]): number {
  // Find when the oldest active IP record will expire
  const oldestActive = records
    .filter((r) => {
      const age = Date.now() - r.lastSeenAt;
      return age <= IP_RECORD_EXPIRY_MS;
    })
    .sort((a, b) => a.lastSeenAt - b.lastSeenAt);

  if (oldestActive.length === 0) {
    return 0;
  }

  return Math.ceil((oldestActive[0].lastSeenAt - Date.now()) / 1000); // Seconds until reset
}

/**
 * Clean up IP records older than 24 hours.
 */
async function cleanupExpiredIPRecords(
  env: ActionCtx,
  apiKeyId: string
) {
  const cutoff = Date.now() - IP_RECORD_EXPIRY_MS;

  const expiredRecords = await env.runQuery(
    internal.apikeys.queries.getExpiredAPIKeyIPs,
    { apiKeyId, cutoff }
  );

  for (const record of expiredRecords) {
    await env.runMutation(
      internal.apikeys.mutations.deleteAPIKeyIP,
      { apiKeyIPId: record._id }
    );
  }
}
```

**Features**:

- **Proxy support**: Handles `X-Forwarded-For` header
- **Cloudflare support**: Handles `CF-Connecting-IP` header
- **Auto-cleanup**: Removes IP records older than 24 hours
- **Tier-based limits**: Free (2 IPs), Pro (5 IPs), Enterprise (unlimited)
- **Retry calculation**: Tells user when oldest IP will expire

**Output**: IP tracking middleware

---

### Subtask 4.2.3: Add API Key IP Mutations

Create Convex mutations for IP tracking operations.

**File to create**: `packages/backend/convex/apikeys/mutations/ip-tracking.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { mutation, internalMutation } from "../_generated/server";
import type { Id } from "../_generated/dataModel";

/**
 * Create or update IP record for an API key.
 */
export const createAPIKeyIP = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
    ipAddress: v.string(),
    firstSeenAt: v.number(),
    lastSeenAt: v.number(),
    requestCount: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("apiKeyIPs", {
      apiKeyId: args.apiKeyId,
      ipAddress: args.ipAddress,
      firstSeenAt: args.firstSeenAt,
      lastSeenAt: args.lastSeenAt,
      requestCount: args.requestCount,
    });

    return { success: true };
  },
});

/**
 * Update IP record when seen again.
 */
export const updateAPIKeyIP = internalMutation({
  args: {
    apiKeyIPId: v.id("apiKeyIPs"),
    lastSeenAt: v.number(),
    requestCount: v.number(),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch("apiKeyIPs", args.apiKeyIPId, {
      lastSeenAt: args.lastSeenAt,
      requestCount: args.requestCount + 1,
    });

    return { success: true };
  },
});

/**
 * Get API key IP record by API key ID and IP.
 */
export const getApiKeyIP = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
    ipAddress: v.string(),
  },
  handler: async (ctx, args) => {
    const record = await ctx.db
      .query("apiKeyIPs")
      .withIndex("apiKeyId_ipAddress")
      .eq("apiKeyId", args.apiKeyId)
      .eq("ipAddress", args.ipAddress)
      .unique();

    return record;
  },
});

/**
 * Get all IP records for an API key.
 */
export const getAPIKeyIPs = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
  },
  handler: async (ctx, args) => {
    const records = await ctx.db
      .query("apiKeyIPs")
      .withIndex("apiKeyId")
      .eq("apiKeyId", args.apiKeyId)
      .collect();

    return records;
  },
});

/**
 * Get expired IP records (older than 24 hours).
 */
export const getExpiredAPIKeyIPs = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
    cutoff: v.number(),
  },
  handler: async (ctx, args) => {
    const cutoff = Date.now() - cutoff;
    const records = await ctx.db
      .query("apiKeyIPs")
      .withIndex("apiKeyId")
      .eq("apiKeyId", args.apiKeyId)
      .collect();

    return records.filter((r) => r.lastSeenAt < cutoff);
  },
});

/**
 * Delete IP record.
 */
export const deleteAPIKeyIP = internalMutation({
  args: {
    apiKeyIPId: v.id("apiKeyIPs"),
  },
  handler: async (ctx, args) => {
    await ctx.db.delete("apiKeyIPs", args.apiKeyIPId);
    return { success: true };
  },
});
```

**Mutations**:

- **Create**: New IP record for API key
- **Update**: Increment count, update last seen time
- **Query**: Get record by API key + IP
- **Query All**: Get all IPs for a key
- **Query Expired**: Get IPs older than 24 hours (for cleanup)
- **Delete**: Remove IP record

**Output**: IP tracking mutations

---

### Subtask 4.2.4: Add API Key IP Queries

Create Convex queries for IP tracking.

**File to create**: `packages/backend/convex/apikeys/queries/ip-tracking.ts`

**Implementation**:

```typescript
import { query, internalQuery } from "../_generated/server";
import type { Id } from "../_generated/dataModel";

/**
 * Get all IP records for an API key.
 */
export const getAPIKeyIPs = query({
  args: {
    apiKeyId: v.id("apikey"),
  },
  handler: async (ctx, args) => {
    const records = await ctx.db
      .query("apiKeyIPs")
      .withIndex("apiKeyId")
      .eq("apiKeyId", args.apiKeyId)
      .order("desc")
      .collect();

    return records;
  },
});

// Already defined in mutations file
export const getApiKeyIP = internalQuery(
  api.apikeys.queries.getApiKeyIP
);

export const getExpiredAPIKeyIPs = internalQuery(
  api.apikeys.mutations.getExpiredAPIKeyIPs
);
```

**Queries**:

- **Get all**: List all IPs for an API key
- **Get one**: Get specific IP record by API key + IP
- **Get expired**: Get IPs older than 24 hours (for cleanup)

**Output**: IP tracking queries

---

### Subtask 4.2.5: Add Unit Tests

Test IP tracking across all tiers and scenarios.

**File to create**: `packages/backend/convex/routes/__tests__/ip-tracking.test.ts`

**Test Cases**:

```typescript
describe("IP Tracking", () => {
  describe("IP extraction", () => {
    it("should extract X-Forwarded-For header", () => {
      const mockReq = new Request("https://test.com", {
        headers: new Headers({
          "X-Forwarded-For": "192.168.1.1, 10.0.0.1",
        }),
      });

      const ip = getIPAddress(mockReq);
      expect(ip).toBe("192.168.1.1");
    });

    it("should fall back to CF-Connecting-IP", () => {
      const mockReq = new Request("https://test.com", {
        headers: new Headers({
          "CF-Connecting-IP": "203.0.113.1",
        }),
      });

      const ip = getIPAddress(mockReq);
      expect(ip).toBe("203.0.113.1");
    });
  });

  describe("tier limits", () => {
    it("should allow 2 IPs for free tier", async () => {
      const result = await testIPLimitWithTier("free", 2);

      expect(result.allowed).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it("should block 3rd IP for free tier", async () => {
      const result = await testIPLimitWithTier("free", 3);

      expect(result.allowed).toBe(false);
      expect(result.error?.message).toContain("allows 2 unique IPs");
      expect(result.error?.status).toBe(429);
    });

    it("should allow 5 IPs for pro tier", async () => {
      const result = await testIPLimitWithTier("pro", 5);

      expect(result.allowed).toBe(true);
      expect(result.error).toBeUndefined();
    });

    it("should allow unlimited for enterprise tier", async () => {
      const result = await testIPLimitWithTier("enterprise", 100);

      expect(result.allowed).toBe(true);
      expect(result.error).toBeUndefined();
    });
  });

  describe("auto-cleanup", () => {
    it("should remove IPs older than 24 hours", async () => {
      // Create IP records 25 hours old
      await createTestIPRecords(testApiKey, 5, false); // 5 IPs, all 25h old

      // Make request (should trigger cleanup)
      const result = await testIPLimitRequest(testApiKey);

      // Check that old records were removed
      const remainingRecords = await getAPIKeyIPs(testApiKey);

      const activeRecords = remainingRecords.filter(
        (r) => Date.now() - r.lastSeenAt <= 24 * 60 * 60 * 1000
      );

      expect(activeRecords.length).toBeLessThan(5);
      expect(activeRecords.length).toBe(0); // Old ones cleaned
    });
  });
});

// Helper functions
async function createTestIPRecords(apiKeyId: string, count: number, old: boolean) {
  const now = Date.now();

  for (let i = 0; i < count; i++) {
    await apikeys.mutations.createAPIKeyIP({
      apiKeyId,
      ipAddress: `192.168.1.${i + 1}`,
      firstSeenAt: old ? now - 25 * 60 * 60 * 1000 : now,
      lastSeenAt: now,
      requestCount: 1,
    });
  }
}

async function testIPLimitWithTier(tier: string, requestCount: number) {
  // Create requestCount + 1 IPs
  await createTestIPRecords(testApiKey, requestCount + 1, false);

  const response = await api.v1.contents.list(
    {},
    { apiKeyId: testApiKey }
  );

  return response;
}

async function testIPLimitRequest(apiKeyId: string) {
  return await fetch("http://localhost:3002/v1/contents", {
    headers: {
      "Authorization": `Bearer ${testApiKey}`,
    },
  });
}
```

**Coverage**:

- ‚úÖ IP extraction from headers (X-Forwarded-For, CF-Connecting-IP)
- ‚úÖ Tier limits enforced (Free: 2, Pro: 5, Enterprise: unlimited)
- ‚úÖ Auto-cleanup of old records
- ‚úÖ Proper error messages with retry timing
- ‚úÖ Clear response headers

**Output**: Comprehensive test suite

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 4.3 - Add Request Signature Verification
2. **Phase 4**: Continue building anti-scraping layers

## üîó Related Tasks

- Task 0.2: Extend Better Auth Schema (creates `apiKeyIPs` table)
- Task 4.1: Implement Velocity-Based Scraping Detection (uses `contentAccessLog`)
- Task 4.3: Add Request Signature Verification (additional security layer)
- Task 4.5: Implement Automatic API Key Revocation (triggers on critical alerts)

## ‚ö†Ô∏è Important Notes

### IP Extraction Strategy

- **Proxies handled**: Checks `X-Forwarded-For` header (multiple IPs comma-separated)
- **Cloudflare**: Falls back to `CF-Connecting-IP` if available
- **Fallback**: Returns `null` if neither header available

### Tier-Based Limits

- **Free tier**: 2 IPs in 24 hours (indie dev, single device)
- **Pro tier**: 5 IPs in 24 hours (small team, multiple devices)
- **Enterprise tier**: Unlimited (monitored for abuse patterns)
- **Auto-expiry**: Records older than 24 hours don't count toward limit

### Auto-Cleanup

- Runs on every request to check for expired records
- Removes IPs where `lastSeenAt < 24 hours ago`
- Prevents database bloat

### Integration

- Apply middleware to all `/v1/contents*` endpoints
- Add to `/v1/contents/search` endpoint
- Can be added to MCP endpoints (if needed)

### False Positives

- Legitimate users with multiple devices might trigger false alerts
- Review in security dashboard can resolve warnings
- User can re-enable revoked key if false positive

### Future Enhancements

- Consider adding IP geolocation (detect VPN/proxy usage)
- Consider adding AS reputation (block known abusive ASNs)
- Consider adding fingerprinting (detect botnets beyond IP limits)
- Consider adding CAPTCHA for suspicious IP patterns
