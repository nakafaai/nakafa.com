# Task 2.5.1: Create API Key Mutation

## Goal

Create mutation to generate and store API keys using Better Auth's built-in API key functionality.

## Context

**Better Auth Already Provides**:
- ✅ API key generation (`betterAuth.createApiKey`)
- ✅ Key hashing and security
- ✅ Built-in validation
- ✅ Rate limiting configuration

**We Need**:
- Wrapper mutation that configures tier-based limits
- App-specific initialization (usage tracking, etc.)
- Better integration with our app's user system

See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

## PRD

```json
{
  "category": "functional",
  "description": "API key generation with Better Auth integration",
  "steps": [
    "Create createApiKey mutation with v.object() validators",
    "Call Better Auth's createApiKey with tier configuration",
    "Initialize app-specific tracking",
    "Return key with metadata",
    "Add tests"
  ],
  "passes": false
}
```

## Success

- [ ] Mutation created
- [ ] Better Auth's API key generation used
- [ ] Tier limits configured correctly
- [ ] Tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 2.5.1.1: Create Mutation

**File**: `packages/backend/convex/betterAuth/mutations/createApiKey.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { internalMutation } from "../../_generated/server";
import { configureTierLimits } from "../../lib/rateLimitConfig";

export const createApiKey = internalMutation({
  args: v.object({
    userId: v.id("users"),
    name: v.string(),
    subscriptionTier: v.union(
      v.literal("free"),
      v.literal("pro"),
      v.literal("enterprise")
    ),
    permissions: v.optional(v.array(v.string())),
  }),
  returns: v.object({
    success: v.boolean(),
    apiKey: v.optional(v.string()),
    apiKeyId: v.optional(v.string()),
    error: v.optional(v.string()),
  }),
  handler: async (ctx, args) => {
    const { userId, name, subscriptionTier, permissions } = args;

    const user = await ctx.db.get("users", userId);
    if (!user) {
      return { success: false, error: "User not found" };
    }

    const authUser = await ctx.runQuery(
      internal.betterAuth.queries.getUserByAuthId,
      { authId: user.authId }
    );

    if (!authUser) {
      return { success: false, error: "Auth user not found" };
    }

    // Check existing API key count (Better Auth uses string IDs)
    const existingKeys = await ctx.runQuery(
      internal.betterAuth.queries.listApiKeysByUserId,
      { userId: authUser._id }
    );

    if (existingKeys.length >= 5) {
      return { success: false, error: "Maximum 5 API keys per user" };
    }

    // Configure tier-based rate limits
    const tierConfig = configureTierLimits(subscriptionTier);

    try {
      // Use Better Auth's createApiKey
      const result = await ctx.runMutation(
        internal.betterAuth.mutations.createApiKey,
        {
          userId: authUser._id,
          name,
          permissions: permissions ?? ["contents"],
          rateLimitEnabled: tierConfig.rateLimitEnabled,
          rateLimitMax: tierConfig.rateLimitMax,
          rateLimitTimeWindow: tierConfig.rateLimitTimeWindow,
          refillInterval: tierConfig.refillInterval,
          refillAmount: tierConfig.refillAmount,
          metadata: JSON.stringify(tierConfig.metadata),
        }
      );

      if (!result.success || !result.apiKey) {
        return { success: false, error: result.error ?? "Failed to create API key" };
      }

      // Log security event
      await ctx.runMutation(internal.securityEvents.mutations.logEvent, {
        type: "api_key_created",
        severity: "info",
        apiKeyId: result.apiKeyId,
        userId,
        details: JSON.stringify({
          subscriptionTier,
          name,
        }),
      });

      return {
        success: true,
        apiKey: result.apiKey,
        apiKeyId: result.apiKeyId,
      };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown error",
      };
    }
  },
});
```

**Note**: This wraps Better Auth's `createApiKey` mutation with our tier configuration. You'll need to implement the Better Auth queries/mutations separately.

**Better Auth Integration File** (may already exist or need to create):

**File**: `packages/backend/convex/betterAuth/queries.ts`

```typescript
import { v } from "convex/values";
import { query } from "../../_generated/server";

export const getUserByAuthId = query({
  args: v.object({ authId: v.string() }),
  returns: v.any(),
  handler: async (ctx, args) => {
    // Query Better Auth's user table
    const user = await ctx.db
      .query("user")
      .withIndex("userId")
      .eq("userId", args.authId)
      .unique();

    return user;
  },
});

export const listApiKeysByUserId = query({
  args: v.object({ userId: v.string() }),
  returns: v.array(v.any()),
  handler: async (ctx, args) => {
    const apiKeys = await ctx.db
      .query("apikey")
      .withIndex("userId")
      .eq("userId", args.userId)
      .collect();

    return apiKeys;
  },
});
```

**Better Auth Mutations** (may already exist):

**File**: `packages/backend/convex/betterAuth/mutations.ts`

```typescript
import { v } from "convex/values";
import { mutation } from "../../_generated/server";
import crypto from "node:crypto";

export const createApiKey = mutation({
  args: v.object({
    userId: v.string(),
    name: v.optional(v.string()),
    permissions: v.optional(v.array(v.string())),
    rateLimitEnabled: v.optional(v.boolean()),
    rateLimitMax: v.optional(v.number()),
    rateLimitTimeWindow: v.optional(v.number()),
    refillInterval: v.optional(v.number()),
    refillAmount: v.optional(v.number()),
    metadata: v.optional(v.string()),
  }),
  returns: v.object({
    success: v.boolean(),
    apiKey: v.optional(v.string()),
    apiKeyId: v.optional(v.string()),
    error: v.optional(v.string()),
  }),
  handler: async (ctx, args) => {
    const {
      userId,
      name,
      permissions,
      rateLimitEnabled,
      rateLimitMax,
      rateLimitTimeWindow,
      refillInterval,
      refillAmount,
      metadata,
    } = args;

    const keyPrefix = "nak_pk_";
    const randomBytes = crypto.randomBytes(32);
    const apiKey = `${keyPrefix}${randomBytes.toString("base64url")}`;

    const now = Date.now();

    const apiKeyId = await ctx.db.insert("apikey", {
      name: name ?? "API Key",
      key: apiKey, // Better Auth handles hashing
      userId,
      permissions: permissions?.join(",") ?? "contents",
      rateLimitEnabled: rateLimitEnabled ?? true,
      rateLimitMax: rateLimitMax ?? 25,
      rateLimitTimeWindow: rateLimitTimeWindow ?? 86400000,
      refillInterval: refillInterval,
      refillAmount: refillAmount,
      requestCount: 0,
      remaining: rateLimitMax ?? 25,
      lastRequest: undefined,
      metadata,
      createdAt: now,
      updatedAt: now,
    });

    return {
      success: true,
      apiKey, // Return plain text key (only once!)
      apiKeyId, // Better Auth uses string ID
    };
  },
});
```

**Output**: Mutation created

---

### Subtask 2.5.1.2: Add Tests

**File**: `packages/backend/convex/betterAuth/__tests__/createApiKey.test.ts`

**Tests**:

```typescript
describe("createApiKey", () => {
  it("should create free tier key with 25/day limit", async () => {
    const result = await createApiKey({
      userId: testUserId,
      name: "Test Key",
      subscriptionTier: "free",
    });

    expect(result.success).toBe(true);
    expect(result.apiKey).toBeDefined();
    expect(result.apiKey?.startsWith("nak_pk_")).toBe(true);
    expect(result.apiKeyId).toBeDefined();
  });

  it("should create pro tier key with 100/min limit", async () => {
    const result = await createApiKey({
      userId: testUserId,
      name: "Pro Key",
      subscriptionTier: "pro",
    });

    expect(result.success).toBe(true);

    // Verify the key was created with correct limits
    const apiKey = await ctx.runQuery(
      internal.betterAuth.queries.getApiKeyById,
      { apiKeyId: result.apiKeyId! }
    );

    expect(apiKey.rateLimitMax).toBe(100);
    expect(apiKey.rateLimitTimeWindow).toBe(60000); // 1 minute
    expect(apiKey.refillInterval).toBe(60000);
    expect(apiKey.refillAmount).toBe(100);
  });

  it("should create enterprise key with unlimited access", async () => {
    const result = await createApiKey({
      userId: testUserId,
      name: "Enterprise Key",
      subscriptionTier: "enterprise",
    });

    expect(result.success).toBe(true);

    const apiKey = await ctx.runQuery(
      internal.betterAuth.queries.getApiKeyById,
      { apiKeyId: result.apiKeyId! }
    );

    expect(apiKey.rateLimitEnabled).toBe(false);
    expect(apiKey.rateLimitMax).toBeNull();
  });

  it("should limit to 5 keys per user", async () => {
    for (let i = 0; i < 5; i++) {
      await createApiKey({
        userId: testUserId,
        name: `Key ${i}`,
        subscriptionTier: "free",
      });
    }

    const result = await createApiKey({
      userId: testUserId,
      name: "Key 6",
      subscriptionTier: "free",
    });

    expect(result.success).toBe(false);
    expect(result.error).toBe("Maximum 5 API keys per user");
  });

  it("should store subscriptionTier in metadata", async () => {
    const result = await createApiKey({
      userId: testUserId,
      name: "Test Key",
      subscriptionTier: "pro",
    });

    const apiKey = await ctx.runQuery(
      internal.betterAuth.queries.getApiKeyById,
      { apiKeyId: result.apiKeyId! }
    );

    const metadata = JSON.parse(apiKey.metadata);
    expect(metadata.subscriptionTier).toBe("pro");
  });

  it("should log security event on creation", async () => {
    const result = await createApiKey({
      userId: testUserId,
      name: "Test Key",
      subscriptionTier: "free",
    });

    const events = await ctx.runQuery(
      internal.securityEvents.queries.listEvents,
      { apiKeyId: result.apiKeyId }
    );

    expect(events.length).toBeGreaterThan(0);
    expect(events[0].type).toBe("api_key_created");
  });
});
```

**Output**: Tests

---

## Next Steps

After: Task 2.5.2 - List Keys Query

## Related

- Task 2.4.1: Rate Limit Config (uses configureTierLimits)
- Task 2.5.2: List Keys (uses this mutation)
- Task 2.5.3: Delete Key (complementary)

## Progress

```
[YYYY-MM-DD HH:mm] Task 2.5.1 completed

Key decisions:
- Wrap Better Auth's createApiKey with tier configuration
- Store subscriptionTier in Better Auth's metadata field
- Log security events for audit trail
- Maximum 5 keys per user
- No need to initialize usage counter (Better Auth handles it)

Files changed:
- packages/backend/convex/betterAuth/mutations/createApiKey.ts (created)
- packages/backend/convex/betterAuth/queries.ts (updated)
- packages/backend/convex/betterAuth/mutations.ts (updated)
- packages/backend/convex/betterAuth/__tests__/createApiKey.test.ts

Blockers: None
```
