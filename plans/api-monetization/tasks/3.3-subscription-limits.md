# Task 3.3: Subscription Limits

## Goal

Apply user's subscription rate limits to MCP.

## Context

MCP needs to:
See `../CONVEX_GUIDE.md` for Convex best practices (indexes, validators, helpers).

- Use user's subscription tier
- Apply tier-based limits
- Enforce daily/minute limits

## PRD
```json
{
  "category": "functional",
  "description": "Apply user subscription rate limits to MCP",
  "steps": [
    "Get user subscription tier",
    "Apply tier-based rate limits to MCP routes",
    "Track MCP usage separately",
    "Add tests"
  ],
  "passes": false
}
```

## Success

- [ ] User tier fetched
- [ ] Limits applied to MCP routes
- [ ] Usage tracked separately
- [ ] Tests pass

## Commands

```bash
pnpm lint
pnpm typecheck
pnpm test
```

## Subtasks

### Subtask 3.3.1: Get User Subscription

**File**: `packages/mcp/lib/subscription.ts`

**Implementation**:

```typescript
import { api } from "@repo/backend/convex/_generated/api";

export async function getUserSubscriptionTier(userId: string): Promise<"free" | "pro" | "enterprise"> {
  const user = await api.users.queries.byId({ userId });

  if (!user) {
    return "free";
  }

  return user.subscriptionTier ?? "free";
}
```

**Output**: Subscription fetcher

---

### Subtask 3.3.2: Apply Limits to MCP

**File**: `packages/mcp/server/index.ts`

**Changes**:

```typescript
export async function invokeMCPTool(
  toolName: string,
  args: any,
  context: MCPContext
): Promise<any> {
  const subscriptionTier = await getUserSubscriptionTier(context.userId);

  const tierLimits = TIER_LIMITS[subscriptionTier];

  if (tierLimits.rateLimitMinute) {
    await checkRateLimit({
      apiKeyId: context.apiKeyId,
      resource: "mcp",
      action: toolName,
      minuteLimit: tierLimits.rateLimitMinute,
    });
  }

  return await toolCall(toolName, args);
}
```

**Output**: Limits applied

---

### Subtask 3.3.3: Track MCP Usage

**File**: `packages/backend/convex/contents/mutations/trackMCPUsage.ts`

**Implementation**:

```typescript
import { v } from "convex/values";
import { mutation } from "../../_generated/server";

export const trackMCPUsage = mutation({
  args: v.object({
    userId: v.id("users"),
    toolName: v.string(),
  }),
  handler: async (ctx, args) => {
    await ctx.db.insert("mcpUsage", {
      userId: args.userId,
      toolName: args.toolName,
      count: 1,
      lastUsedAt: Date.now(),
    });

    return { success: true };
  },
});
```

**Output**: Usage tracking

---

### Subtask 3.3.4: Add Tests

**File**: `packages/mcp/server/__tests__/subscription.test.ts`

**Tests**:

```typescript
describe("MCP Subscription Limits", () => {
  it("should apply free tier limits", async () => {
    const tier = await getUserSubscriptionTier(freeUserId);

    expect(tier).toBe("free");
  });

  it("should apply pro tier limits", async () => {
    const tier = await getUserSubscriptionTier(proUserId);

    expect(tier).toBe("pro");
  });

  it("should track MCP usage", async () => {
    await trackMCPUsage({
      userId: testUserId,
      toolName: "list_contents",
    });

    const usage = await ctx.db.query("mcpUsage").collect();

    expect(usage.length).toBeGreaterThan(0);
  });
});
```

**Output**: Tests

---

## Next Steps

Phase 3 Complete.

## Related

- Task 4.1: Velocity Detection (security layers)
- Task 4.2: IP-Based Limiting (additional security)

## Progress

```
[YYYY-MM-DD HH:mm] Phase 3 complete

Tasks completed:
- Task 3.1: MCP Auth
- Task 3.2: MCP Routes
- Task 3.3: Subscription Limits

Key decisions:
- Use existing subscription tier from users table
- Apply same rate limiting pattern to MCP
- Track MCP usage separately for analytics

Files changed:
- apps/mcp/lib/auth.ts
- apps/mcp/index.ts
- packages/mcp/server/index.ts
- packages/mcp/lib/subscription.ts
- packages/backend/convex/contents/mutations/trackMCPUsage.ts
- All test files

Blockers: None

Phase 4 Next: Anti-scraping layers
```
