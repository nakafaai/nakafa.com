# Task 4.4: Add Content Watermarking

## üéØ Goal

Add invisible HTML watermarks to all content responses to track content leaks and attribute to API keys.

## üìç Context

This is **Phase 4.4** of Anti-Scraping Layers phase.

Even with rate limiting and scraping detection, determined attackers may:

1. **Download all content** legitimately over days/weeks
2. **Distribute** content on dark web or competitor sites
3. **Extract watermarks** to identify source

Content watermarking provides:

- **Invisible to end users**: HTML comments don't affect rendering
- **Traceable**: Contains API key ID to identify which key was used
- **Time-stamped**: Shows when content was accessed
- **Hashed content**: Prevents tampering detection
- **Embedding protection**: Watermark is part of content, can't be removed

## üé¨ Success Criteria

- [ ] Watermark format defined (`<!-- NAK:API:{apiKeyId}:{hash}:{timestamp} -->`)
- [ ] `addWatermark()` function created
- [ ] Watermarks added to all `/v1/contents/*` responses
- [ ] Watermark included before content (prevents stripping)
- [ ] Watermark parsing helper available (for leak detection)
- [ ] Watermark doesn't break MDX rendering
- [ ] Unit tests for watermarking

## üìù Subtasks

### Subtask 4.4.1: Define Watermark Format

Create watermark utility and parsing functions.

**File to create**: `packages/backend/convex/routes/v1/contents/watermarking/utils.ts`

**Implementation**:

```typescript
import crypto from "crypto";

export interface Watermark {
  apiKeyId: string;
  hash: string;
  timestamp: number;
  raw: string; // Full watermark string
}

export const WATERMARK_PREFIX = "<!-- NAK:API:";
export const WATERMARK_SUFFIX = " -->";

/**
 * Generates HMAC-SHA256 hash for content watermark.
 * Hash includes API key ID, content slug, and timestamp.
 *
 * @param apiKeyId - API key ID (truncated, first 8 chars)
 * @param contentSlug - Content slug being accessed
 * @param timestamp - Unix timestamp when accessed
 * @returns SHA-256 hash (base64url encoded)
 */
export function generateWatermarkHash(
  apiKeyId: string,
  contentSlug: string,
  timestamp: number
): string {
  const data = `${apiKeyId}:${contentSlug}:${timestamp}`;
  return crypto
    .createHmac("sha256", "nakafa-watermark-key")
    .update(data)
    .digest("base64url");
}

/**
 * Parses watermark from content.
 * Extracts apiKey ID, hash, and timestamp for leak attribution.
 *
 * @param content - Raw content string (may contain watermark)
 * @returns Parsed watermark or null
 */
export function parseWatermark(content: string): Watermark | null {
  const prefix = `${WATERMARK_PREFIX}NAK:API:`;
  const startIndex = content.indexOf(prefix);

  if (startIndex === -1) {
    return null; // No watermark found
  }

  const endIndex = content.indexOf(WATERMARK_SUFFIX);
  if (endIndex === -1) {
    return null; // Incomplete watermark (shouldn't happen)
  }

  // Extract watermark (from prefix start to suffix end)
  const watermarkRaw = content.substring(startIndex, endIndex + WATERMARK_SUFFIX.length);

  // Parse components
  const parts = watermarkRaw.slice(prefix.length).split(":");

  if (parts.length !== 3) {
    return null; // Invalid format
  }

  const [apiKeyIdPart, hashPart, timestampPart] = parts;

  return {
    apiKeyId: apiKeyIdPart,
    hash: hashPart,
    timestamp: Number.parseInt(timestampPart),
    raw: watermarkRaw,
  };
}

/**
 * Removes watermark from content.
 * Used when displaying content to users (watermarks are for API tracking only).
 *
 * @param content - Content string with watermark
 * @returns Clean content without watermark
 */
export function removeWatermark(content: string): string {
  const prefix = `${WATERMARK_PREFIX}NAK:API:`;

  const startIndex = content.indexOf(prefix);
  if (startIndex === -1) {
    return content; // No watermark
  }

  const endIndex = content.indexOf(WATERMARK_SUFFIX);
  if (endIndex === -1) {
    return content; // Incomplete watermark
  }

  const watermarkEnd = endIndex + WATERMARK_SUFFIX.length;
  return content.substring(0, startIndex) + content.substring(watermarkEnd);
}
```

**Features**:

- **Generation**: HMAC-SHA256 hash with API key + slug + timestamp
- **Parsing**: Extract components for leak attribution
- **Removal**: Clean content for display
- **Security**: Watermark key never exposed, only HMAC key

**Output**: Watermark utilities

---

### Subtask 4.4.2: Create Watermarking Middleware

Apply watermarks to all content responses.

**File to create**: `packages/backend/convex/routes/v1/contents/watermarking/middleware.ts`

**Implementation**:

```typescript
import { generateWatermarkHash, parseWatermark } from "./utils";
import type { MiddlewareHandler } from "hono";
import type { ActionCtx } from "../../../_generated/server";

/**
 * Content watermarking middleware.
 * Adds invisible watermarks to all API responses for leak tracking.
 */
export const requireWatermarking = (): MiddlewareHandler<{
  Bindings: ActionCtx;
  Variables: {
    apiKeyId: string;
    // Note: We'll store content in context for watermarking
    content?: string;
  };
}> => {
  return async (c, next) => {
    const apiKeyId = c.get("apiKeyId");

    if (!apiKeyId) {
      return c.json(
        { error: "API key ID not found in context" },
        { status: 500 }
      );
    }

    // Store raw content in context for watermarking
    const rawContent = await c.req.raw(); // Read raw body if available
    let contentToWatermark: string;

    // Check if this is JSON response (common pattern)
    try {
      const jsonBody = JSON.parse(rawContent);

      // Check if it's a content response (has content field)
      if (jsonBody.content !== undefined) {
        contentToWatermark = jsonBody.content;
      }
    } catch {
      // Not JSON, use raw content as-is
      contentToWatermark = rawContent;
    }

    // Generate watermark
    const timestamp = Math.floor(Date.now() / 1000);
    const hash = generateWatermarkHash(apiKeyId, c.req.url, timestamp);

    const watermark = `${WATERMARK_PREFIX}NAK:API:${apiKeyId}:${hash}:${timestamp}${WATERMARK_SUFFIX}`;

    // Prepend watermark to content
    const watermarkedContent = watermark + "\n" + contentToWatermark;

    // Store watermarked content in context for response building
    c.set("content", watermarkedContent);

    await next();
  };
};
```

**Integration Points**:

- Apply to `/v1/contents` GET (single content)
- Apply to `/v1/contents` POST (search)
- Apply to MCP server (via `/v1/contents` calls)
- Apply to any other content endpoints

**Features**:

- **Automatic**: Middleware automatically adds watermarks
- **Context-aware**: Works with streaming and JSON responses
- **Backward compatible**: Doesn't break existing response handling

**Output**: Watermarking middleware

---

### Subtask 4.4.3: Update Public API Endpoints

Apply watermarking to all content routes.

**File to modify**: `packages/backend/convex/routes/v1/index.ts`

**Changes Required**:

```typescript
import { requireWatermarking } from "./contents/watermarking/middleware";

// Apply watermarking to list endpoint
v1.get("/contents", requireApiKey(), requireWatermarking(), async (c) => {
  const response = await getContentsListLogic(c);

  // Note: Watermark already added by middleware
  // Just return response
  return c.json(response.body, { status: response.status });
});

// Apply to get single endpoint
v1.get("/contents/:slug", requireApiKey(), requireWatermarking(), async (c) => {
  const response = await getContentLogic(c);

  return c.json(response.body, { status: response.status });
});

// Apply to search endpoint
v1.post("/contents/search", requireApiKey(), requireWatermarking(), async (c) => {
  const response = await searchContentsLogic(c);

  return c.json(response.body, { status: response.status });
});
```

**Important**: Watermarking happens in middleware before response, so route handlers don't need to modify their logic.

**Output**: All content endpoints watermarked

---

### Subtask 4.4.4: Add Unit Tests

Test watermarking functionality and edge cases.

**File to create**: `packages/backend/convex/routes/__tests__/watermarking.test.ts`

**Test Cases**:

```typescript
import { describe, it, expect, beforeEach } from "vitest";
import { generateWatermarkHash, parseWatermark, removeWatermark } from "../../routes/v1/contents/watermarking/utils";

describe("Content Watermarking", () => {
  describe("generateWatermarkHash", () => {
    it("should generate consistent hash for same inputs", () => {
      const hash1 = generateWatermarkHash("key-123", "/en/test", 1234567890);
      const hash2 = generateWatermarkHash("key-123", "/en/test", 1234567890);

      expect(hash1).toBe(hash2);
    });

    it("should generate different hash for different timestamp", () => {
      const hash1 = generateWatermarkHash("key-123", "/en/test", 1234567890);
      const hash2 = generateWatermarkHash("key-123", "/en/test", 1234567895); // 5 seconds later

      expect(hash1).not.toBe(hash2);
    });
  });

  describe("parseWatermark", () => {
    it("should parse valid watermark", () => {
      const content = "<!-- NAK:API:key-123:abc:def:456:1705228800000 -->\n# Content";
      const watermark = parseWatermark(content);

      expect(watermark).toEqual({
        apiKeyId: "key-123",
        hash: "abc:def:456",
        timestamp: 1705228800000,
        raw: content.substring(0, 70) + content.substring(70),
      });
    });

    it("should return null for content without watermark", () => {
      const content = "# Content without watermark";
      const watermark = parseWatermark(content);

      expect(watermark).toBeNull();
    });

    it("should return null for invalid watermark format", () => {
      const content = "<!-- NAK:API:invalid -->";
      const watermark = parseWatermark(content);

      expect(watermark).toBeNull();
    });

    it("should return null for incomplete watermark", () => {
      const content = "<!-- NAK:API:missing-end -->";
      const watermark = parseWatermark(content);

      expect(watermark).toBeNull();
    });
  });

  describe("removeWatermark", () => {
    it("should remove watermark from beginning", () => {
      const watermarked = "<!-- NAK:API:key-123:abc:123 -->\nContent";
      const clean = removeWatermark(watermarked);

      expect(clean).toBe("\nContent");
      expect(clean).not.toContain("NAK:API:");
    });

    it("should remove watermark from middle", () => {
      const watermarked = "Content\n<!-- NAK:API:key-123:abc:123 -->\nMore";
      const clean = removeWatermark(watermarked);

      expect(clean).toBe("Content\nMore");
    });
  });
});
```

**Coverage**:

- ‚úÖ Watermark hash generation consistent
- ‚úÖ Valid watermarks parsed correctly
- ‚úÖ Invalid watermarks return null
- ‚úÖ Watermarks removed cleanly for display
- ‚úÖ Invisible to users (HTML comments don't break MDX)

**Output**: Comprehensive test suite

---

### Subtask 4.4.5: Add Leak Detection Utility

Create utility to find and track leaked content.

**File to create**: `packages/backend/convex/utils/leak-detection.ts`

**Implementation**:

```typescript
import { parseWatermark, type Watermark } from "../routes/v1/contents/watermarking/utils";
import { v } from "convex/values";
import { internalMutation } from "../_generated/server";

export interface LeakDetection {
  apiKeyId: string;
  slug: string;
  foundOn: string; // Domain where leak was found
  foundAt: number;
  reportedBy: string; // How leak was discovered (automated, user, manual)
}

/**
 * Report content leak from detected watermark.
 *
 * @param ctx - Convex action context
 * @param leak - Leak detection data
 */
export const reportContentLeak = internalMutation({
  args: {
    apiKeyId: v.id("apikey"),
    slug: v.string(),
    foundOn: v.string(),
    foundAt: v.number(),
    reportedBy: v.union(
      v.literal("automated"),
      v.literal("manual"),
      v.literal("user_report"),
      v.literal("investigation")
    ),
  },
  handler: async (ctx, args) => {
    await ctx.db.insert("contentLeaks", {
      apiKeyId: args.apiKeyId,
      slug: args.slug,
      foundOn: args.foundOn,
      foundAt: args.foundAt,
      reportedBy: args.reportedBy,
      createdAt: Date.now(),
    });

    // Send email alert (will be in Task 5.2)
    // TODO: Send via Resend

    return { success: true };
  },
});

/**
 * Check if content appears on potential leak sources.
 *
 * @param slug - Content slug to check
 * @returns List of URLs where content was found
 */
export async function scanPotentialLeakSources(slug: string): Promise<string[]> {
  // This would integrate with external services like:
  // - Google search for content strings
  // - GitHub for content repositories
  // - Scrape monitoring services
  
  // For now, return empty list
  return [];
}
```

**Features**:

- **Leak reporting**: Record when watermarked content found elsewhere
- **Source attribution**: Track where leak was discovered
- **Automated detection**: Integration with external services (future)
- **Investigation support**: Manual reporting workflow

**Output**: Leak detection utilities

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 4.5: Implement Automatic API Key Revocation
2. **Phase 4**: Continue building anti-scraping layers

## üîó Related Tasks

- Task 0.1: Internal API Key Storage (signing secrets added)
- Task 0.2: Extend Better Auth Schema (watermark utilities integrated)
- Task 4.1: Implement Velocity-Based Scraping Detection (watermarks add evidence)
- Task 4.3: Add Request Signature Verification (watermarks are signed too)

## ‚ö†Ô∏è Important Notes

### Watermark Strategy

- **Invisible**: HTML comment format doesn't affect MDX rendering
- **Parsing**: Can extract components for attribution
- **Tamper-proof**: Hashed with HMAC, can't be modified without invalidating
- **Embedded**: Part of content string, can't be removed without breaking structure

### Security Benefits

1. **Leak Attribution**: Identify which API key leaked content
2. **Evidence for Revocation**: Clear proof of policy violation
3. **Deterrent Effect**: Attackers know content is watermarked
4. **Legal Protection**: Prove ownership of leaked content

### Implementation

- **Auto-applied**: Middleware adds watermarks to all responses
- **No client changes needed**: Works with existing fetch code
- **Removal available**: Helper function to remove when displaying to users

### False Positives

- Legitimate sites may repost content (e.g., RSS feeds, cached content)
- Monitor leak detection dashboard before revoking keys
- Contact API key owners for verification before action

### Future Enhancements

- Consider adding **visible watermarks** for premium content (user-facing warning)
- Consider adding **dynamic watermarks** (user-specific identification)
- Consider adding **fingerprinting** (unique watermarks per user request)
- Consider automated leak takedowns (DMCA complaints)

## Documentation

See `docs/api/content-watermarking.md` for developer documentation on:

- Watermark format
- How to ignore watermarks when displaying content
- How to parse watermarks from leaked content
- How to report content leaks
