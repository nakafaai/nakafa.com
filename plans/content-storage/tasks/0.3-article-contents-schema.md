# Task 0.3: Article Contents Schema

## Goal

Create articleContents and articleReferences tables for storing article MDX content with normalized citations.

## Context

Articles have 5-50+ references which exceeds Convex's "5-10 elements" recommendation. References are normalized into a separate table.

## PRD

```json
{
  "category": "architecture",
  "description": "Create articleContents and articleReferences tables with proper indexes",
  "steps": [
    "Create packages/backend/convex/articleContents directory",
    "Create schema.ts with both tables",
    "Define indexes for locale, slug, category queries",
    "Verify lint passes"
  ],
  "passes": false
}
```

## Success Criteria

- [ ] Directory created at `packages/backend/convex/articleContents/`
- [ ] Schema file created with both tables
- [ ] Indexes match query patterns
- [ ] No lint errors
- [ ] No TypeScript errors

## Commands

```bash
mkdir -p packages/backend/convex/articleContents
pnpm lint
pnpm typecheck
```

## Implementation

### File: `packages/backend/convex/articleContents/schema.ts`

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";
import {
  articleCategoryValidator,
  localeValidator,
} from "../lib/contentValidators";

const tables = {
  articleContents: defineTable({
    locale: localeValidator,
    slug: v.string(),
    category: articleCategoryValidator,
    articleSlug: v.string(),
    title: v.string(),
    description: v.optional(v.string()),
    date: v.number(),
    body: v.string(),
    contentHash: v.string(),
    syncedAt: v.number(),
  })
    .index("locale_slug", ["locale", "slug"])
    .index("locale_category", ["locale", "category"])
    .index("contentHash", ["contentHash"]),

  articleReferences: defineTable({
    articleId: v.id("articleContents"),
    title: v.string(),
    authors: v.string(),
    year: v.number(),
    url: v.optional(v.string()),
    citation: v.optional(v.string()),
    publication: v.optional(v.string()),
    details: v.optional(v.string()),
    order: v.number(),
  }).index("articleId", ["articleId"]),
};

export default tables;
```

## Schema Design

### articleContents Table

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `locale` | "en" \| "id" | Yes | Content language |
| `slug` | string | Yes | Full URL path: "articles/politics/nepotism" |
| `category` | "politics" | Yes | Article category |
| `articleSlug` | string | Yes | Article identifier: "nepotism-in-political-governance" |
| `title` | string | Yes | Article title |
| `description` | string | No | Article description/summary |
| `date` | number | Yes | Publication date (epoch millis) |
| `body` | string | Yes | MDX content without metadata export |
| `contentHash` | string | Yes | SHA-256 of body for sync detection |
| `syncedAt` | number | Yes | Last sync timestamp (epoch millis) |

### articleReferences Table

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `articleId` | Id<"articleContents"> | Yes | Parent article reference |
| `title` | string | Yes | Reference title |
| `authors` | string | Yes | Author names as string |
| `year` | number | Yes | Publication year |
| `url` | string | No | Source URL |
| `citation` | string | No | Citation key (e.g., "2024a") |
| `publication` | string | No | Journal/publication name |
| `details` | string | No | Additional details |
| `order` | number | Yes | Order in reference list |

### Indexes

| Index | Fields | Use Case |
|-------|--------|----------|
| `locale_slug` | ["locale", "slug"] | Get article by URL |
| `locale_category` | ["locale", "category"] | List articles by category |
| `contentHash` | ["contentHash"] | Check if content changed |
| `articleId` | ["articleId"] | Get references for article |

## URL Mapping

```
URL: /en/articles/politics/nepotism-in-political-governance

Fields:
- locale: "en"
- slug: "articles/politics/nepotism-in-political-governance"
- category: "politics"
- articleSlug: "nepotism-in-political-governance"
```

## Query Examples

### Get Article by URL

```typescript
const article = await ctx.db
  .query("articleContents")
  .withIndex("locale_slug", (q) =>
    q.eq("locale", "en").eq("slug", "articles/politics/nepotism")
  )
  .unique();
```

### Get Article References

```typescript
const references = await ctx.db
  .query("articleReferences")
  .withIndex("articleId", (q) => q.eq("articleId", article._id))
  .collect();

const sorted = references.sort((a, b) => a.order - b.order);
```

### List Articles by Category

```typescript
const articles = await ctx.db
  .query("articleContents")
  .withIndex("locale_category", (q) =>
    q.eq("locale", "en").eq("category", "politics")
  )
  .take(50);
```

## Content Hash

Used for sync detection:

```typescript
import { createHash } from "crypto";

function getContentHash(body: string): string {
  return createHash("sha256").update(body).digest("hex");
}
```

## Next Steps

After this task:
- Next: Task 0.4 (subjectContents schema)
- Dependencies: Task 0.1 (contentValidators)

## Related Tasks

- Task 0.1: Uses validators
- Task 0.2: Authors linked via contentAuthors join table

## Notes

### Why Normalize References?

- Articles can have 50+ references (exceeds 5-10 limit)
- References are rich objects with 7 fields
- May need to query references independently later
- Easy to update individual references

### Convex Best Practices Applied

- Normalized references to separate table
- Proper indexes for common queries
- Date as number for sorting
- Content hash for sync detection
