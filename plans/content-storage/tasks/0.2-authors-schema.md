# Task 0.2: Authors Schema

## Goal

Create normalized authors table and contentAuthors join table for N:M relationship between content and authors.

## Context

Following Convex best practice: "Limit Arrays to 5-10 elements. Leverage separate tables and references."

Authors can have many fields (name, url, social, bio, avatar) and are shared across content. Normalizing prevents data duplication and allows easy updates.

## PRD

```json
{
  "category": "architecture",
  "description": "Create authors and contentAuthors tables with proper indexes",
  "steps": [
    "Create packages/backend/convex/authors directory",
    "Create schema.ts with authors and contentAuthors tables",
    "Define proper indexes for queries",
    "Verify lint passes"
  ],
  "passes": false
}
```

## Success Criteria

- [ ] Directory created at `packages/backend/convex/authors/`
- [ ] Schema file created with both tables
- [ ] Indexes defined for common query patterns
- [ ] No lint errors
- [ ] No TypeScript errors

## Commands

```bash
mkdir -p packages/backend/convex/authors
pnpm lint
pnpm typecheck
```

## Implementation

### File: `packages/backend/convex/authors/schema.ts`

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";
import { contentTypeValidator } from "../lib/contentValidators";

const tables = {
  authors: defineTable({
    name: v.string(),
    slug: v.string(),
    url: v.optional(v.string()),
    twitter: v.optional(v.string()),
    linkedin: v.optional(v.string()),
    github: v.optional(v.string()),
    bio: v.optional(v.string()),
    avatarUrl: v.optional(v.string()),
  })
    .index("slug", ["slug"])
    .index("name", ["name"]),

  contentAuthors: defineTable({
    contentId: v.string(),
    contentType: contentTypeValidator,
    authorId: v.id("authors"),
    order: v.number(),
  })
    .index("contentId_contentType", ["contentId", "contentType"])
    .index("authorId", ["authorId"]),
};

export default tables;
```

## Schema Design

### authors Table

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `name` | string | Yes | Display name |
| `slug` | string | Yes | URL-friendly identifier |
| `url` | string | No | Personal website |
| `twitter` | string | No | Twitter handle |
| `linkedin` | string | No | LinkedIn profile URL |
| `github` | string | No | GitHub username |
| `bio` | string | No | Short biography |
| `avatarUrl` | string | No | Profile picture URL |

### contentAuthors Table (Join)

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `contentId` | string | Yes | Content document ID (as string for polymorphic) |
| `contentType` | union | Yes | "article", "subject", or "exercise" |
| `authorId` | Id<"authors"> | Yes | Reference to authors table |
| `order` | number | Yes | 0 = primary author, 1 = second, etc. |

### Indexes

| Index | Fields | Use Case |
|-------|--------|----------|
| `slug` | ["slug"] | Find author by URL slug |
| `name` | ["name"] | Search authors by name |
| `contentId_contentType` | ["contentId", "contentType"] | Get authors for content |
| `authorId` | ["authorId"] | Get all content by author |

## Query Examples

### Get Authors for Content

```typescript
const authorLinks = await ctx.db
  .query("contentAuthors")
  .withIndex("contentId_contentType", (q) =>
    q.eq("contentId", contentId).eq("contentType", "article")
  )
  .collect();

const authors = await Promise.all(
  authorLinks
    .sort((a, b) => a.order - b.order)
    .map((link) => ctx.db.get(link.authorId))
);
```

### Get All Content by Author

```typescript
const contentLinks = await ctx.db
  .query("contentAuthors")
  .withIndex("authorId", (q) => q.eq("authorId", authorId))
  .collect();
```

## Why Polymorphic contentId?

Using `contentId: v.string()` instead of `v.id("articleContents")` because:

1. Single join table for all content types
2. Convex doesn't support union of IDs: `v.union(v.id("a"), v.id("b"))`
3. `contentType` field disambiguates the reference
4. Can still type-safely cast when querying

## Next Steps

After this task:
- Next: Task 0.3 (articleContents schema)
- Dependencies: Task 0.1 (contentValidators)

## Related Tasks

- Task 0.1: Uses contentTypeValidator from here
- Task 0.3-0.5: Content tables reference authors via this join table

## Notes

### Convex Best Practices Applied

- Separate table for shared data (authors)
- Join table for N:M relationships
- Proper indexes for query patterns
- No deeply nested objects
