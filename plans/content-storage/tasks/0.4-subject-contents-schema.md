# Task 0.4: Subject Contents Schema

## Goal

Create subjectContents table for storing subject/lesson MDX content with hierarchical path structure.

## Context

Subject content has a deep hierarchy: category → grade → material → topic → section. All path parts are stored for flexible querying and filtering.

## PRD

```json
{
  "category": "architecture",
  "description": "Create subjectContents table with hierarchical indexes",
  "steps": [
    "Create packages/backend/convex/subjectContents directory",
    "Create schema.ts with subjectContents table",
    "Define hierarchical indexes for filtering",
    "Verify lint passes"
  ],
  "passes": false
}
```

## Success Criteria

- [ ] Directory created at `packages/backend/convex/subjectContents/`
- [ ] Schema file created with proper fields
- [ ] Hierarchical indexes defined
- [ ] No lint errors
- [ ] No TypeScript errors

## Commands

```bash
mkdir -p packages/backend/convex/subjectContents
pnpm lint
pnpm typecheck
```

## Implementation

### File: `packages/backend/convex/subjectContents/schema.ts`

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";
import {
  gradeValidator,
  localeValidator,
  materialValidator,
  subjectCategoryValidator,
} from "../lib/contentValidators";

const tables = {
  subjectContents: defineTable({
    locale: localeValidator,
    slug: v.string(),
    category: subjectCategoryValidator,
    grade: gradeValidator,
    material: materialValidator,
    topic: v.string(),
    section: v.string(),
    title: v.string(),
    description: v.optional(v.string()),
    date: v.number(),
    subject: v.optional(v.string()),
    body: v.string(),
    contentHash: v.string(),
    syncedAt: v.number(),
  })
    .index("locale_slug", ["locale", "slug"])
    .index("locale_category_grade", ["locale", "category", "grade"])
    .index("locale_category_grade_material", [
      "locale",
      "category",
      "grade",
      "material",
    ])
    .index("contentHash", ["contentHash"]),
};

export default tables;
```

## Schema Design

### subjectContents Table

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `locale` | "en" \| "id" | Yes | Content language |
| `slug` | string | Yes | Full URL path |
| `category` | union | Yes | "elementary-school", "middle-school", "high-school", "university" |
| `grade` | union | Yes | "1"-"12", "bachelor", "master", "phd" |
| `material` | union | Yes | "mathematics", "physics", etc. (17 values) |
| `topic` | string | Yes | Topic slug: "limit" |
| `section` | string | Yes | Section slug: "concept-of-limit-function" |
| `title` | string | Yes | Content title |
| `description` | string | No | Content description |
| `date` | number | Yes | Publication date (epoch millis) |
| `subject` | string | No | Chapter/topic name from metadata |
| `body` | string | Yes | MDX content without metadata export |
| `contentHash` | string | Yes | SHA-256 of body for sync detection |
| `syncedAt` | number | Yes | Last sync timestamp (epoch millis) |

### Indexes

| Index | Fields | Use Case |
|-------|--------|----------|
| `locale_slug` | ["locale", "slug"] | Get content by URL |
| `locale_category_grade` | ["locale", "category", "grade"] | List by grade |
| `locale_category_grade_material` | ["locale", "category", "grade", "material"] | List by material |
| `contentHash` | ["contentHash"] | Check if content changed |

## URL Mapping

```
URL: /id/subject/high-school/12/mathematics/limit/concept-of-limit-function

Fields:
- locale: "id"
- slug: "subject/high-school/12/mathematics/limit/concept-of-limit-function"
- category: "high-school"
- grade: "12"
- material: "mathematics"
- topic: "limit"
- section: "concept-of-limit-function"
```

## Query Examples

### Get Content by URL

```typescript
const content = await ctx.db
  .query("subjectContents")
  .withIndex("locale_slug", (q) =>
    q.eq("locale", "id").eq("slug", "subject/high-school/12/mathematics/limit/concept-of-limit-function")
  )
  .unique();
```

### List by Grade

```typescript
const contents = await ctx.db
  .query("subjectContents")
  .withIndex("locale_category_grade", (q) =>
    q.eq("locale", "id").eq("category", "high-school").eq("grade", "12")
  )
  .take(100);
```

### List by Material

```typescript
const contents = await ctx.db
  .query("subjectContents")
  .withIndex("locale_category_grade_material", (q) =>
    q.eq("locale", "id")
      .eq("category", "high-school")
      .eq("grade", "12")
      .eq("material", "mathematics")
  )
  .take(100);
```

## Why No Separate Tables for Topics?

Unlike articles with references, subjects don't have:
- Unbounded arrays
- Data that needs independent querying
- Shared entities across content

The hierarchical path (category/grade/material/topic/section) is:
- Fixed structure
- Always read together
- Efficiently queryable via compound indexes

## Next Steps

After this task:
- Next: Task 0.5 (exerciseContents schema)
- Dependencies: Task 0.1 (contentValidators)

## Related Tasks

- Task 0.1: Uses validators
- Task 0.2: Authors linked via contentAuthors join table

## Notes

### Hierarchical Index Strategy

Convex compound indexes work left-to-right. Our indexes support:

1. `locale_slug` → Direct content lookup
2. `locale_category_grade` → Browse by grade (e.g., "Grade 12")
3. `locale_category_grade_material` → Browse by subject (e.g., "Grade 12 Math")

### Why Store Both slug and Parts?

- `slug`: URL matching, unique identifier
- Parsed parts: Filtering, sorting, grouping without string parsing

### Convex Best Practices Applied

- No arrays that could grow
- Compound indexes for hierarchical queries
- All query patterns supported by indexes
