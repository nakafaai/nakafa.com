# Task 1.1: Create Audio Studies Actions

## Goal
Create AI actions for script generation and speech synthesis.

## File
`packages/backend/convex/audioStudies/actions.ts`

## Implementation

```typescript
import { internalAction } from "@repo/backend/convex/functions";
import { internal } from "@repo/backend/convex/_generated/api";
import type { ActionCtx } from "@repo/backend/convex/_generated/server";
import { generateText, experimental_generateSpeech as generateSpeech } from "ai";
import { vercelGateway } from "@repo/ai/config/vercel";
import { elevenlabs } from "@repo/ai/config/elevenlabs";
import { vv } from "@repo/backend/convex/lib/validators";
import { v, ConvexError } from "convex/values";
import type { Id } from "@repo/backend/convex/_generated/dataModel";

export const generateScript = internalAction({
  args: { contentAudioId: vv.id("contentAudios") },
  returns: v.null(),
  handler: async (ctx, args) => {
    const audio = await ctx.runQuery(internal.audioStudies.queries.get, { id: args.contentAudioId });
    if (!audio) throw new ConvexError({ code: "NOT_FOUND", message: "Audio not found" });

    await ctx.runMutation(internal.audioStudies.mutations.updateStatus, {
      id: args.contentAudioId,
      status: "generating-script",
    });

    try {
      const content = await fetchContent(ctx, audio.contentId, audio.contentType);
      
      const { text: script } = await generateText({
        model: vercelGateway.languageModel("google/gemini-2.5-flash"),
        system: `Create podcast script with ElevenLabs v3 tags: [excited], [curious], [calm], [pauses], [sigh]`,
        prompt: `Title: ${content.title}\n\n${content.body}\n\nCreate 3-5 minute script in ${content.locale === "id" ? "Indonesian" : "English"}.`,
      });

      await ctx.runMutation(internal.audioStudies.mutations.saveScript, {
        id: args.contentAudioId,
        script,
      });
    } catch (error) {
      await ctx.runMutation(internal.audioStudies.mutations.markFailed, {
        id: args.contentAudioId,
        error: error instanceof Error ? error.message : "Script failed",
      });
      throw error;
    }
    return null;
  },
});

export const generateSpeech = internalAction({
  args: { contentAudioId: vv.id("contentAudios") },
  returns: v.null(),
  handler: async (ctx, args) => {
    const audio = await ctx.runQuery(internal.audioStudies.queries.getWithScript, { id: args.contentAudioId });
    if (!audio?.script) throw new ConvexError({ code: "NOT_FOUND", message: "No script" });

    await ctx.runMutation(internal.audioStudies.mutations.updateStatus, {
      id: args.contentAudioId,
      status: "generating-speech",
    });

    try {
      const result = await generateSpeech({
        model: elevenlabs.speech("eleven_multilingual_v2"),
        text: audio.script,
        voice: audio.voiceId,
        providerOptions: { elevenlabs: { voiceSettings: audio.voiceSettings } },
      });

      const storageId = await ctx.storage.store(result.audio);
      const wordCount = audio.script.split(/\s+/).length;
      const duration = Math.ceil((wordCount / 150) * 60);

      await ctx.runMutation(internal.audioStudies.mutations.saveAudio, {
        id: args.contentAudioId,
        storageId,
        duration,
        size: result.audio.byteLength || result.audio.length,
      });
    } catch (error) {
      await ctx.runMutation(internal.audioStudies.mutations.markFailed, {
        id: args.contentAudioId,
        error: error instanceof Error ? error.message : "Speech failed",
      });
      throw error;
    }
    return null;
  },
});

async function fetchContent(ctx: ActionCtx, id: string, type: "article" | "subject") {
  if (type === "article") {
    const article = await ctx.runQuery(internal.articleContents.getById, { id: id as Id<"articleContents"> });
    if (!article) throw new ConvexError({ code: "NOT_FOUND", message: "Article not found" });
    return article;
  } else {
    const section = await ctx.runQuery(internal.subjectSections.getById, { id: id as Id<"subjectSections"> });
    if (!section) throw new ConvexError({ code: "NOT_FOUND", message: "Section not found" });
    return section;
  }
}
```

## Commands
```bash
pnpm typecheck
pnpm lint
```
