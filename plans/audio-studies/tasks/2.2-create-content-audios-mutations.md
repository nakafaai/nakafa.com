# Task 2.2: Create contentAudios Mutations

## üéØ Goal

Create mutation functions for creating and updating contentAudios records with proper validation and error handling.

## üìç Context

Mutations handle database writes for the audio generation workflow. Following Convex best practices, they should be idempotent and handle edge cases gracefully.

## PRD

```json
{
  "category": "architecture",
  "description": "Create mutations for contentAudios CRUD operations",
  "steps": [
    "Create upsertContentAudio mutation (create or get existing)",
    "Create updateStatus mutation (track generation progress)",
    "Create saveScript mutation (store generated script)",
    "Create saveAudio mutation (store audio metadata)",
    "Create completeAudioGeneration mutation (mark done)",
    "Create markFailed mutation (error handling)",
    "Create invalidateAudio mutation (cache invalidation with storage cleanup)"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Mutations file exists at `packages/backend/convex/audioStudies/mutations.ts`
- [ ] All mutations are idempotent where possible
- [ ] Proper validation of arguments
- [ ] Update updatedAt field on every mutation
- [ ] Handle edge cases (duplicate creation, missing records)

## Commands

```bash
pnpm typecheck
pnpm lint
```

## üìù Subtasks

### Subtask 2.2.1: Create Core Mutations

**File to create**: `packages/backend/convex/audioStudies/mutations.ts`

**Implementation**:

```typescript
import { mutation, internalMutation } from "@repo/backend/convex/functions";
import { vv } from "@repo/backend/convex/lib/validators";
import {
  localeValidator,
  audioStatusValidator,
  voiceSettingsValidator,
} from "@repo/backend/convex/lib/contentValidators";
import { v } from "convex/values";
import { ConvexError } from "convex/values";

/**
 * Upsert contentAudio record
 * Creates new record or returns existing ID
 * Idempotent: safe to call multiple times
 */
export const upsertContentAudio = internalMutation({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    locale: localeValidator,
    contentHash: v.string(),
    voiceId: v.string(),
    voiceSettings: voiceSettingsValidator,
  },
  returns: vv.id("contentAudios"),
  handler: async (ctx, args) => {
    const now = Date.now();

    // Check for existing record
    const existing = await ctx.db
      .query("contentAudios")
      .withIndex("content_voice", (q) =>
        q
          .eq("contentId", args.contentId)
          .eq("contentType", args.contentType)
          .eq("voiceId", args.voiceId)
      )
      .first();

    if (existing) {
      // Check if content changed (hash mismatch)
      if (existing.contentHash !== args.contentHash) {
        // Content updated, reset for regeneration
        await ctx.db.patch("contentAudios", existing._id, {
          contentHash: args.contentHash,
          status: "pending",
          script: undefined,
          audioStorageId: undefined,
          audioDuration: undefined,
          audioSize: undefined,
          errorMessage: undefined,
          failedAt: undefined,
          generationAttempts: 0,
          updatedAt: now,
        });
      }
      return existing._id;
    }

    // Create new record
    const id = await ctx.db.insert("contentAudios", {
      contentId: args.contentId,
      contentType: args.contentType,
      locale: args.locale,
      contentHash: args.contentHash,
      voiceId: args.voiceId,
      voiceSettings: args.voiceSettings,
      status: "pending",
      generationAttempts: 0,
      updatedAt: now,
    });

    return id;
  },
});

/**
 * Update generation status
 * Called by workflow to track progress
 */
export const updateStatus = internalMutation({
  args: {
    contentAudioId: vv.id("contentAudios"),
    status: audioStatusValidator,
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch("contentAudios", args.contentAudioId, {
      status: args.status,
      updatedAt: Date.now(),
    });
    return null;
  },
});

/**
 * Save generated script
 * Called after AI script generation completes
 */
export const saveScript = internalMutation({
  args: {
    contentAudioId: vv.id("contentAudios"),
    script: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const audio = await ctx.db.get("contentAudios", args.contentAudioId);
    if (!audio) {
      throw new ConvexError({
        code: "NOT_FOUND",
        message: "Audio study not found",
      });
    }

    await ctx.db.patch("contentAudios", args.contentAudioId, {
      script: args.script,
      status: "generating_speech", // Advance to next stage
      updatedAt: Date.now(),
    });

    return null;
  },
});

/**
 * Save generated audio
 * Called after ElevenLabs speech synthesis
 */
export const saveAudio = internalMutation({
  args: {
    contentAudioId: vv.id("contentAudios"),
    storageId: vv.id("_storage"),
    audioDuration: v.number(),
    audioSize: v.number(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch("contentAudios", args.contentAudioId, {
      audioStorageId: args.storageId,
      audioDuration: args.audioDuration,
      audioSize: args.audioSize,
      updatedAt: Date.now(),
    });

    return null;
  },
});

/**
 * Mark audio generation as completed
 * Called at end of workflow
 */
export const completeAudioGeneration = internalMutation({
  args: {
    contentAudioId: vv.id("contentAudios"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch("contentAudios", args.contentAudioId, {
      status: "completed",
      updatedAt: Date.now(),
    });

    return null;
  },
});

/**
 * Mark audio generation as failed
 * Called when error occurs
 */
export const markFailed = internalMutation({
  args: {
    contentAudioId: vv.id("contentAudios"),
    errorMessage: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const audio = await ctx.db.get("contentAudios", args.contentAudioId);
    if (!audio) {
      return null;
    }

    await ctx.db.patch("contentAudios", args.contentAudioId, {
      status: "failed",
      errorMessage: args.errorMessage,
      failedAt: Date.now(),
      generationAttempts: audio.generationAttempts + 1,
      updatedAt: Date.now(),
    });

    return null;
  },
});

/**
 * Invalidate audio when content updates
 * Called by content sync triggers
 * Also deletes old audio files from storage to prevent orphans
 */
export const invalidateAudio = internalMutation({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    newContentHash: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    // Find all audios for this content (all voices)
    const audios = await ctx.db
      .query("contentAudios")
      .withIndex("content", (q) =>
        q.eq("contentId", args.contentId).eq("contentType", args.contentType)
      )
      .collect();

    const now = Date.now();

    for (const audio of audios) {
      // Only invalidate if hash changed
      if (audio.contentHash !== args.newContentHash) {
        // Delete old audio file from storage (prevent orphaned files)
        if (audio.audioStorageId) {
          await ctx.storage.delete(audio.audioStorageId);
        }

        await ctx.db.patch("contentAudios", audio._id, {
          contentHash: args.newContentHash,
          status: "pending",
          script: undefined,
          audioStorageId: undefined,
          audioDuration: undefined,
          audioSize: undefined,
          errorMessage: undefined,
          failedAt: undefined,
          generationAttempts: 0,
          updatedAt: now,
        });
      }
    }

    return null;
  },
});
```

**Output**: Complete mutations for contentAudios lifecycle.

---

## üöÄ Next Steps

After this task:
- Next: Task 2.3 (Create userContentAudios mutations)
- Dependencies: Task 0.2 (schema defined)

## üîó Related Tasks

- Task 1.1-1.3: Actions and workflow call these mutations
- Task 4.1-4.2: Content sync calls invalidateAudio

## ‚ö†Ô∏è Important Notes

### Shared Validators

We use shared validators from `lib/contentValidators.ts`:
- `audioStatusValidator` - Prevents duplication
- `voiceSettingsValidator` - Prevents duplication
- `localeValidator` - Reuses existing validator

### Idempotency

`upsertContentAudio` is idempotent:
- Same content+voice = return existing ID
- Changed content = reset and return ID
- New combination = create and return ID

### Error Handling

Uses `ConvexError` for structured error responses:
- User-facing errors have code and message
- Internal errors (record not found) handled gracefully

### Field Clearing

When invalidating or resetting:
- Set optional fields to `undefined` (not `null`)
- This removes the field from document (saves storage)
- Convex treats `undefined` as "field doesn't exist"

### updatedAt Pattern

Every mutation updates `updatedAt`:
- Enables "recently updated" queries
- Useful for debugging and analytics
- Follows Convex best practice (no automatic _updateTime)

### Storage Cleanup

When invalidating audio, we delete the old storage file:
```typescript
if (audio.audioStorageId) {
  await ctx.storage.delete(audio.audioStorageId);
}
```

This prevents orphaned files from accumulating in Convex storage.

### Real-time Subscriptions

Status changes are automatically pushed to clients via Convex subscriptions:
- Frontend uses `useQuery(api.audioStudies.getAudioStatus, { contentAudioId })`
- No polling needed - updates instantly when database changes
- Works across all connected clients automatically
