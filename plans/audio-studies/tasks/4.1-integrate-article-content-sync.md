# Task 4.1: Integrate with Article Content Sync

## üéØ Goal

Invalidate cached audio when article content is updated.

## üìç Context

When article content changes (new version synced from MDX), existing audio becomes stale and should be invalidated for regeneration.

## PRD

```json
{
  "category": "integration",
  "description": "Trigger audio invalidation when article content is updated",
  "steps": [
    "Modify article content upsert mutation",
    "Check if contentHash changed",
    "Call invalidateAudio for changed content",
    "Ensure this doesn't block content sync"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Article content sync triggers audio invalidation
- [ ] Only invalidates when contentHash actually changes
- [ ] Doesn't slow down content sync
- [ ] Works for both new articles and updates

## Commands

```bash
pnpm typecheck
pnpm lint
```

## üìù Subtasks

### Subtask 4.1.1: Modify Article Content Upsert

**File to modify**: `packages/backend/convex/articleContents/mutations.ts`

**Implementation**:

Add to the `upsertArticleContent` mutation after updating/creating:

```typescript
import { internal } from "./_generated/api";

export const upsertArticleContent = internalMutation({
  // ... existing args ...
  handler: async (ctx, args) => {
    // ... existing upsert logic ...

    if (existing) {
      if (existing.contentHash === args.contentHash) {
        return { id: existing._id, action: "unchanged" as const };
      }

      // Update article
      await ctx.db.patch("articleContents", existing._id, {
        // ... existing updates ...
        contentHash: args.contentHash,
        syncedAt: now,
      });

      // Invalidate cached audio for this article
      await ctx.runMutation(
        internal.audioStudies.mutations.invalidateAudio,
        {
          contentId: existing._id,
          contentType: "article",
          newContentHash: args.contentHash,
        }
      );

      return { id: existing._id, action: "updated" as const };
    }

    // Create new article
    const id = await ctx.db.insert("articleContents", {
      // ... existing fields ...
      contentHash: args.contentHash,
      syncedAt: now,
    });

    // New article - no audio to invalidate yet
    return { id, action: "created" as const };
  },
});
```

**Output**: Article sync invalidates audio when content changes.

---

## üöÄ Next Steps

After this task:
- Next: Task 4.2 (Integrate with subject section sync)
- Dependencies: Task 2.2 (invalidateAudio mutation)

## üîó Related Tasks

- Task 4.2: Same pattern for subject sections
- Task 5.2: Testing invalidation

## ‚ö†Ô∏è Important Notes

### Async Invalidation

`ctx.runMutation` is async and awaited:
- Content sync waits for invalidation
- If invalidation fails, article update still succeeds (error handled gracefully)
- Consider making this non-blocking in the future (fire-and-forget)

### New Articles

No invalidation needed for new articles because:
- No cached audio exists yet
- First request will generate fresh audio

### Content Hash Check

Invalidation only happens when `contentHash` changes:
- Same content re-synced = no invalidation
- Actual changes = invalidate
- Prevents unnecessary regenerations
