# Task 2.1: Create contentAudios Queries

## üéØ Goal

Create query functions for fetching contentAudios data with proper indexes and validation.

## üìç Context

Queries support the workflow and UI by efficiently fetching audio data using the indexes defined in the schema.

## PRD

```json
{
  "category": "architecture",
  "description": "Create query functions for contentAudios with proper indexing",
  "steps": [
    "Create getContentAudio query (by ID)",
    "Create getContentAudioStatus query (lightweight status check)",
    "Create getContentAudioWithScript query (for speech generation)",
    "Create getContentAudioByContentVoice query (cache lookup)",
    "Create queries for article and subject content fetching",
    "Use proper indexes in all queries"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Queries file exists at `packages/backend/convex/audioStudies/queries.ts`
- [ ] All queries use withIndex for efficient lookups
- [ ] Proper argument and return validators
- [ ] Type-safe using vv validator
- [ ] No redundant data fetching (only fetch needed fields)

## Commands

```bash
pnpm typecheck
pnpm lint
```

## üìù Subtasks

### Subtask 2.1.1: Create Core Queries

**File to create**: `packages/backend/convex/audioStudies/queries.ts`

**Implementation**:

```typescript
import { query, internalQuery } from "@repo/backend/convex/functions";
import { vv } from "@repo/backend/convex/lib/validators";
import { localeValidator, audioStatusValidator, voiceSettingsValidator } from "@repo/backend/convex/lib/contentValidators";
import { v } from "convex/values";

/**
 * Get contentAudio by ID with full details
 * Used by workflow to fetch record for processing
 */
export const getContentAudio = internalQuery({
  args: {
    contentAudioId: vv.id("contentAudios"),
  },
  returns: v.union(
    v.object({
      _id: vv.id("contentAudios"),
      contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
      contentType: v.union(v.literal("article"), v.literal("subject")),
      locale: localeValidator,
      contentHash: v.string(),
      voiceId: v.string(),
      voiceSettings: v.optional(voiceSettingsValidator),
      status: audioStatusValidator,
      script: v.optional(v.string()),
      audioStorageId: v.optional(vv.id("_storage")),
      audioDuration: v.optional(v.number()),
      audioSize: v.optional(v.number()),
      errorMessage: v.optional(v.string()),
      generationAttempts: v.number(),
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    return await ctx.db.get("contentAudios", args.contentAudioId);
  },
});

/**
 * Get lightweight status for deduping check
 * Only fetches status field for efficiency
 */
export const getContentAudioStatus = internalQuery({
  args: {
    contentAudioId: vv.id("contentAudios"),
  },
  returns: v.union(
    v.object({
      status: audioStatusValidator,
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    const audio = await ctx.db.get("contentAudios", args.contentAudioId);
    if (!audio) return null;
    return { status: audio.status };
  },
});

/**
 * Get contentAudio with script for speech generation
 */
export const getContentAudioWithScript = internalQuery({
  args: {
    contentAudioId: vv.id("contentAudios"),
  },
  returns: v.union(
    v.object({
      script: v.string(),
      voiceId: v.string(),
      voiceSettings: v.optional(voiceSettingsValidator),
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    const audio = await ctx.db.get("contentAudios", args.contentAudioId);
    if (!audio || !audio.script) return null;
    return {
      script: audio.script,
      voiceId: audio.voiceId,
      voiceSettings: audio.voiceSettings,
    };
  },
});

/**
 * Lookup audio by content + voice (cache check)
 * Returns matching audio or null (not found)
 */
export const getContentAudioByContentVoice = internalQuery({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    voiceId: v.string(),
  },
  returns: v.union(
    v.object({
      _id: vv.id("contentAudios"),
      contentHash: v.string(),
      status: audioStatusValidator,
      audioStorageId: v.optional(vv.id("_storage")),
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("contentAudios")
      .withIndex("content_voice", (q) =>
        q
          .eq("contentId", args.contentId)
          .eq("contentType", args.contentType)
          .eq("voiceId", args.voiceId)
      )
      .first();
  },
});

/**
 * Get article content for script generation
 */
export const getArticleContent = internalQuery({
  args: {
    articleId: vv.id("articleContents"),
  },
  returns: v.union(
    v.object({
      title: v.string(),
      description: v.optional(v.string()),
      body: v.string(),
      locale: localeValidator,
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    const article = await ctx.db.get("articleContents", args.articleId);
    if (!article) return null;
    return {
      title: article.title,
      description: article.description,
      body: article.body,
      locale: article.locale,
    };
  },
});

/**
 * Get subject section for script generation
 */
export const getSubjectSection = internalQuery({
  args: {
    sectionId: vv.id("subjectSections"),
  },
  returns: v.union(
    v.object({
      title: v.string(),
      description: v.optional(v.string()),
      body: v.string(),
      locale: localeValidator,
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    const section = await ctx.db.get("subjectSections", args.sectionId);
    if (!section) return null;
    return {
      title: section.title,
      description: section.description,
      body: section.body,
      locale: section.locale,
    };
  },
});
```

**Output**: Query functions using proper indexes for efficient lookups.

---

## üöÄ Next Steps

After this task:
- Next: Task 2.2 (Create contentAudios mutations)
- Dependencies: Task 0.2 (schema defined)

## üîó Related Tasks

- Task 1.1-1.3: Actions use these queries
- Task 3.1: Public mutation uses getContentAudioByContentVoice

## ‚ö†Ô∏è Important Notes

### Shared Validators

We use shared validators from `lib/contentValidators.ts`:
- `audioStatusValidator` - Prevents duplication
- `localeValidator` - Reuses existing validator

### Index Usage

All queries use `withIndex` for efficiency:
- `getContentAudioByContentVoice` uses `content_voice` index
- Direct `ctx.db.get()` uses primary index on `_id`

### Field Selection

Queries only return needed fields to minimize bandwidth:
- `getContentAudioStatus` only returns status
- `getContentAudioWithScript` only returns script-related fields

### Internal vs Public

All these are `internalQuery` because:
1. Called by actions/mutations, not directly by clients
2. Client uses higher-level public queries (Task 3.2)
3. Follows Convex best practice: only expose what clients need

### N+1 Query Pattern

`getUserAudioHistory` (in Task 3.2) does N+1 queries:
1. Get userContentAudios
2. For each, get contentAudios + content title

This is acceptable for 20 items. For larger lists, consider denormalizing title into userContentAudios.
