# Task 1.3: Create Workflow Orchestrator

## üéØ Goal

Create a Convex workflow that orchestrates the full audio generation pipeline: script generation ‚Üí speech generation ‚Üí completion.

## üìç Context

Workflows provide durable execution with automatic retries, ensuring the multi-step audio generation process completes reliably even with failures.

## PRD

```json
{
  "category": "architecture",
  "description": "Create Convex workflow to orchestrate script generation and speech synthesis",
  "steps": [
    "Create workflow definition using WorkflowManager",
    "Define workflow steps: create record ‚Üí generate script ‚Üí generate speech ‚Üí complete",
    "Handle deduping for simultaneous requests",
    "Implement proper error handling and retries",
    "Add status tracking throughout pipeline"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Workflow exists at `packages/backend/convex/audioStudies/workflows.ts`
- [ ] Uses workflow manager from `@convex-dev/workflow`
- [ ] Orchestrates 3 steps: script generation ‚Üí speech generation ‚Üí completion
- [ ] Handles errors with status updates
- [ ] Prevents duplicate generation via status checking

## Commands

```bash
pnpm typecheck
pnpm lint
```

## üìù Subtasks

### Subtask 1.3.1: Create Workflow Orchestrator

**File to create**: `packages/backend/convex/audioStudies/workflows.ts`

**Implementation**:

```typescript
import { workflow } from "@repo/backend/convex/workflow";
import { internal } from "./_generated/api";
import { v } from "convex/values";
import { vv } from "@repo/backend/convex/lib/validators";
import { localeValidator } from "@repo/backend/convex/lib/contentValidators";
import type { VoiceKey } from "@repo/ai/config/voices";

/**
 * Start audio generation workflow
 * 
 * This workflow orchestrates the full pipeline:
 * 1. Create contentAudios record with pending status
 * 2. Generate script from content using AI
 * 3. Generate speech from script using ElevenLabs
 * 4. Mark as completed
 * 
 * If audio already exists for this content+voice combination,
 * returns existing record without starting workflow.
 */
export const generateAudio = workflow.start({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    locale: localeValidator,
    contentHash: v.string(),
    voiceKey: v.string(), // VoiceKey validated in mutation
    voiceId: v.string(),
    voiceSettings: v.optional(
      v.object({
        stability: v.optional(v.number()),
        similarityBoost: v.optional(v.number()),
        style: v.optional(v.number()),
      })
    ),
  },
  returns: vv.id("contentAudios"),
  handler: async (ctx, args) => {
    // Step 1: Create or get existing contentAudios record
    const contentAudioId = await ctx.runMutation(
      internal.audioStudies.mutations.upsertContentAudio,
      {
        contentId: args.contentId,
        contentType: args.contentType,
        locale: args.locale,
        contentHash: args.contentHash,
        voiceId: args.voiceId,
        voiceSettings: args.voiceSettings,
      }
    );

    // Check if already completed or in progress
    const existing = await ctx.runQuery(
      internal.audioStudies.queries.getContentAudioStatus,
      { contentAudioId }
    );

    if (existing?.status === "completed") {
      // Already done, return existing
      return contentAudioId;
    }

    if (existing?.status === "pending" || 
        existing?.status === "generating_script" || 
        existing?.status === "generating_speech") {
      // Already in progress, return ID (caller should poll/wait)
      return contentAudioId;
    }

    // Step 2: Generate script
    await ctx.runAction(
      internal.audioStudies.actions.generateScript,
      { contentAudioId }
    );

    // Step 3: Generate speech
    await ctx.runAction(
      internal.audioStudies.actions.generateSpeechAction,
      { contentAudioId }
    );

    // Step 4: Mark as completed
    await ctx.runMutation(
      internal.audioStudies.mutations.completeAudioGeneration,
      { contentAudioId }
    );

    return contentAudioId;
  },
});
```

**Output**: Workflow that orchestrates the full audio generation pipeline.

### Subtask 1.3.2: Verify Workflow Manager Setup

**File to verify**: `packages/backend/convex/workflow.ts`

**Should already be**:

```typescript
import { WorkflowManager } from "@convex-dev/workflow";
import { components } from "@repo/backend/convex/_generated/api";

export const workflow = new WorkflowManager(components.workflow, {
  workpoolOptions: {
    maxParallelism: 20,
  },
});
```

**Also verify convex.config.ts includes workflow component** (already done per your codebase).

**Output**: Workflow manager properly configured.

---

## üöÄ Next Steps

After this task:
- Next: Task 2.1 (Create contentAudios queries)
- Dependencies: Task 1.1, 1.2 (actions used by workflow)

## üîó Related Tasks

- Task 3.1: Public mutation calls this workflow
- Task 2.2: Mutations used by workflow (upsertContentAudio, completeAudioGeneration)

## ‚ö†Ô∏è Important Notes

### Workflow vs Direct Mutation

We use workflow instead of direct action calls because:
1. **Durable execution**: Automatic retries on failure
2. **Status tracking**: Each step updates status for progress monitoring
3. **Observability**: Workflow provides built-in logging and monitoring
4. **Scalability**: Workpool manages concurrent generations

### Deduping Strategy

Before starting workflow:
1. Check if audio exists with matching contentHash
2. If yes ‚Üí return existing (cached)
3. If generating ‚Üí return ID (user polls for completion)
4. If stale/failed ‚Üí start new generation

This is handled in the public mutation (Task 3.1), not the workflow itself.

### Error Handling

Workflow automatically retries failed steps. After max retries:
1. Status set to "failed"
2. errorMessage stored
3. failedAt timestamp recorded
4. User can retry manually

### Parallelism

`maxParallelism: 20` means:
- Up to 20 audio generations run simultaneously
- Additional requests queue until slot available
- Prevents overwhelming ElevenLabs API
