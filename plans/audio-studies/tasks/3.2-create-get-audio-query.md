# Task 3.2: Create Get Audio Queries (Public API)

## ðŸŽ¯ Goal

Create public queries for fetching audio status and user listening history.

## ðŸ“ Context

Clients need to:
1. Check generation status (real-time updates via subscription)
2. Get audio URL for playback
3. View listening history

## PRD

```json
{
  "category": "integration",
  "description": "Create public queries for audio status and user history",
  "steps": [
    "Create getAudioStatus query for real-time status",
    "Create getAudioUrl query for playback",
    "Create getUserAudioHistory query for history",
    "Create getAvailableVoices query for voice selector",
    "Add proper auth checks"
  ],
  "passes": false
}
```

## ðŸŽ¬ Success Criteria

- [ ] Public queries exist in `packages/backend/convex/audioStudies/api.ts`
- [ ] getAudioStatus returns current generation status
- [ ] getAudioUrl returns signed URL for playback
- [ ] getUserAudioHistory returns user's listening history
- [ ] getAvailableVoices returns voice options with preview URLs
- [ ] All queries validate authentication

## Commands

```bash
pnpm typecheck
pnpm lint
```

## ðŸ“ Subtasks

### Subtask 3.2.1: Create Public Queries

**File to modify**: `packages/backend/convex/audioStudies/api.ts` (add to existing)

**Implementation**:

```typescript
import { query } from "@repo/backend/convex/functions";
import { audioStatusValidator } from "@repo/backend/convex/lib/contentValidators";
import { getVoiceSamples } from "./queries";

/**
 * Get current status of audio generation
 * Called by UI to subscribe to status updates
 * Automatically updates in real-time via Convex subscriptions
 */
export const getAudioStatus = query({
  args: {
    contentAudioId: vv.id("contentAudios"),
  },
  returns: v.union(
    v.object({
      status: audioStatusValidator,
      audioUrl: v.optional(v.string()),
      audioDuration: v.optional(v.number()),
      errorMessage: v.optional(v.string()),
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    const audio = await ctx.db.get("contentAudios", args.contentAudioId);
    if (!audio) return null;

    let audioUrl: string | undefined;
    if (audio.status === "completed" && audio.audioStorageId) {
      audioUrl = await ctx.storage.getUrl(audio.audioStorageId) || undefined;
    }

    return {
      status: audio.status,
      audioUrl,
      audioDuration: audio.audioDuration,
      errorMessage: audio.errorMessage,
    };
  },
});

/**
 * Get audio URL for immediate playback
 * Validates user has access to this audio
 */
export const getAudioUrl = query({
  args: {
    contentAudioId: vv.id("contentAudios"),
  },
  returns: v.union(
    v.object({
      url: v.string(),
      duration: v.number(),
      voiceKey: v.string(),
    }),
    v.null()
  ),
  handler: async (ctx, args) => {
    // Check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    const user = await ctx.db
      .query("users")
      .withIndex("tokenIdentifier", (q) =>
        q.eq("tokenIdentifier", identity.tokenIdentifier)
      )
      .first();

    if (!user) return null;

    // Get audio
    const audio = await ctx.db.get("contentAudios", args.contentAudioId);
    if (!audio || audio.status !== "completed" || !audio.audioStorageId) {
      return null;
    }

    // Get URL
    const url = await ctx.storage.getUrl(audio.audioStorageId);
    if (!url) return null;

    // Find voice key from voiceId
    const voiceKey =
      Object.entries(PREDEFINED_VOICES).find(
        ([, v]) => v.id === audio.voiceId
      )?.[0] || "unknown";

    return {
      url,
      duration: audio.audioDuration || 0,
      voiceKey,
    };
  },
});

/**
 * Get user's audio listening history
 * For "Continue Listening" feature
 */
export const getUserAudioHistory = query({
  args: {
    limit: v.optional(v.number()), // Default 20
  },
  returns: v.array(
    v.object({
      userContentAudioId: vv.id("userContentAudios"),
      contentAudioId: vv.id("contentAudios"),
      contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
      contentType: v.union(v.literal("article"), v.literal("subject")),
      title: v.string(),
      playCount: v.number(),
      lastPlayedAt: v.number(),
      audioDuration: v.number(),
      voiceKey: v.string(),
    })
  ),
  handler: async (ctx, args) => {
    // Check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    const user = await ctx.db
      .query("users")
      .withIndex("tokenIdentifier", (q) =>
        q.eq("tokenIdentifier", identity.tokenIdentifier)
      )
      .first();

    if (!user) return [];

    // Get user's audio records
    const userAudios = await ctx.db
      .query("userContentAudios")
      .withIndex("user", (q) => q.eq("userId", user._id))
      .order("desc") // Most recent first
      .take(args.limit || 20);

    // Enrich with content and audio details
    const enriched = await Promise.all(
      userAudios.map(async (ua) => {
        const audio = await ctx.db.get("contentAudios", ua.contentAudioId);
        if (!audio) return null;

        // Get content title
        let title = "Unknown";
        if (ua.contentType === "article") {
          const article = await ctx.db.get("articleContents", ua.contentId as Id<"articleContents">);
          title = article?.title || "Unknown";
        } else {
          const section = await ctx.db.get("subjectSections", ua.contentId as Id<"subjectSections">);
          title = section?.title || "Unknown";
        }

        // Find voice key
        const voiceKey =
          Object.entries(PREDEFINED_VOICES).find(
            ([, v]) => v.id === audio.voiceId
          )?.[0] || "unknown";

        return {
          userContentAudioId: ua._id,
          contentAudioId: ua.contentAudioId,
          contentId: ua.contentId,
          contentType: ua.contentType,
          title,
          playCount: ua.playCount,
          lastPlayedAt: ua.lastPlayedAt || ua._creationTime,
          audioDuration: audio.audioDuration || 0,
          voiceKey,
        };
      })
    );

    return enriched.filter((item): item is NonNullable<typeof item> => item !== null);
  },
});

/**
 * Get available voices with preview URLs
 * For voice selector UI
 */
export const getAvailableVoices = query({
  args: {},
  returns: v.array(
    v.object({
      key: v.string(),
      name: v.string(),
      description: v.string(),
      isDefault: v.boolean(),
      sampleUrl: v.optional(v.string()),
    })
  ),
  handler: async (ctx) => {
    return getVoiceSamples.handler(ctx, {});
  },
});
```

**Output**: Complete set of public queries for UI integration.

---

## ðŸš€ Next Steps

After this task:
- Next: Task 4.1 (Integrate with article content sync)
- Dependencies: Task 0.3 (voice samples)

## ðŸ”— Related Tasks

- Task 6.1: Testing these queries

## âš ï¸ Important Notes

### Real-time Updates (No Polling!)

Convex uses **subscriptions**, not polling:

```typescript
// âœ… CORRECT - Automatic real-time updates
const { data } = useQuery(api.audioStudies.getAudioStatus, { contentAudioId });

// UI automatically re-renders when status changes:
// pending â†’ generating_script â†’ generating_speech â†’ completed
// No setInterval, no polling needed!
```

```typescript
// âŒ WRONG - Don't do this
useEffect(() => {
  const interval = setInterval(() => {
    refetch(); // DON'T POLL
  }, 5000);
  return () => clearInterval(interval);
}, []);
```

### URL Expiration

`ctx.storage.getUrl()` returns signed URLs that expire after 1 hour.
For audio playback (which may pause/resume), either:
1. Refresh URL on play
2. Use shorter audio segments (future enhancement)

For now, assume user finishes listening within 1 hour or refreshes page.

### History Performance

`getUserAudioHistory` does N+1 queries:
1. Get userContentAudios
2. For each, get contentAudios + content title

This is acceptable for 20 items. For larger lists, consider:
- Denormalizing title into userContentAudios
- Or using a separate "recent listening" table

### Auth Returns Null

Queries return null/empty array instead of throwing for unauthenticated users:
- Cleaner UI handling (show login vs error)
- No stack traces in console
- Graceful degradation

### Shared Validators

Uses `audioStatusValidator` from `lib/contentValidators.ts` to avoid duplication.
