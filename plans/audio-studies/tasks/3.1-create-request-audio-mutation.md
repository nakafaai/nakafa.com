# Task 3.1: Create Request Audio Mutation (Public API)

## üéØ Goal

Create public mutation for Pro users to request audio generation with proper access control and deduping.

## üìç Context

This is the main entry point for the audio feature. Pro users call this to request audio for content. It handles caching, deduping, and initiates the workflow.

## PRD

```json
{
  "category": "integration",
  "description": "Create public mutation for requesting audio generation with Pro subscription check",
  "steps": [
    "Create requestAudio mutation with auth check",
    "Validate Pro subscription status",
    "Validate voice selection",
    "Check cache (existing audio)",
    "Handle deduping (already generating)",
    "Start workflow if needed",
    "Track user access",
    "Return appropriate response"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Public mutation exists with auth validator
- [ ] Checks Pro subscription via subscriptions table
- [ ] Validates voice key against PREDEFINED_VOICES
- [ ] Returns cached audio if available
- [ ] Returns "generating" status if in progress
- [ ] Starts workflow for new requests
- [ ] Records user access

## Commands

```bash
pnpm typecheck
pnpm lint
```

## üìù Subtasks

### Subtask 3.1.1: Create Public Request Audio Mutation

**File to create**: `packages/backend/convex/audioStudies/api.ts`

**Implementation**:

```typescript
import { mutation } from "@repo/backend/convex/functions";
import { internal } from "@repo/backend/convex/_generated/api";
import type { MutationCtx } from "@repo/backend/convex/_generated/server";
import { vv } from "@repo/backend/convex/lib/validators";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import {
  PREDEFINED_VOICES,
  DEFAULT_VOICE_KEY,
  type VoiceKey,
  isValidVoiceKey,
  getVoiceConfig,
} from "@repo/ai/config/voices";
import type { Id } from "@repo/backend/convex/_generated/dataModel";

/**
 * Request audio generation for content
 * 
 * Returns:
 * - { status: "cached", audioUrl: string } if audio exists
 * - { status: "generating", contentAudioId: string } if in progress or started
 * - { status: "error", message: string } on failure
 * 
 * Requires Pro subscription.
 */
export const requestAudio = mutation({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    voiceKey: v.optional(v.string()), // Defaults to "nina"
  },
  returns: v.union(
    v.object({
      status: v.literal("cached"),
      contentAudioId: vv.id("contentAudios"),
      audioUrl: v.string(),
      audioDuration: v.number(),
      voiceKey: v.string(),
    }),
    v.object({
      status: v.literal("generating"),
      contentAudioId: vv.id("contentAudios"),
      voiceKey: v.string(),
      message: v.string(),
    }),
    v.object({
      status: v.literal("error"),
      message: v.string(),
    })
  ),
  handler: async (ctx, args) => {
    // Step 1: Authenticate user
    const user = await authenticateUser(ctx);

    // Step 2: Check Pro subscription
    await validateProSubscription(ctx, user._id);

    // Step 3: Validate voice selection
    const voiceKey = validateVoiceKey(args.voiceKey);
    const voiceConfig = getVoiceConfig(voiceKey);

    // Step 4: Fetch content info
    const contentInfo = await fetchContentInfo(ctx, args);
    if (!contentInfo) {
      throw new ConvexError({
        code: "NOT_FOUND",
        message: "Content not found",
      });
    }

    // Step 5: Check cache
    const cachedResult = await checkCachedAudio(ctx, {
      ...args,
      voiceId: voiceConfig.id,
      contentHash: contentInfo.contentHash,
      userId: user._id,
    });

    if (cachedResult) {
      return { ...cachedResult, voiceKey };
    }

    // Step 6: Start workflow
    const contentAudioId = await startAudioWorkflow(ctx, {
      ...args,
      locale: contentInfo.locale,
      contentHash: contentInfo.contentHash,
      voiceKey,
      voiceId: voiceConfig.id,
      voiceSettings: voiceConfig.settings,
    });

    // Step 7: Track user access
    await trackUserAccess(ctx, {
      userId: user._id,
      contentAudioId,
      contentId: args.contentId,
      contentType: args.contentType,
    });

    return {
      status: "generating",
      contentAudioId,
      voiceKey,
      message: "Audio generation started. This may take a minute...",
    };
  },
});

// Helper: Authenticate user
async function authenticateUser(ctx: MutationCtx) {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) {
    throw new ConvexError({
      code: "UNAUTHORIZED",
      message: "Authentication required",
    });
  }

  const user = await ctx.db
    .query("users")
    .withIndex("tokenIdentifier", (q) =>
      q.eq("tokenIdentifier", identity.tokenIdentifier)
    )
    .first();

  if (!user) {
    throw new ConvexError({
      code: "NOT_FOUND",
      message: "User not found",
    });
  }

  return user;
}

// Helper: Validate Pro subscription
async function validateProSubscription(ctx: MutationCtx, userId: Id<"users">) {
  const customer = await ctx.db
    .query("customers")
    .withIndex("userId", (q) => q.eq("userId", userId))
    .first();

  if (!customer) {
    throw new ConvexError({
      code: "FORBIDDEN",
      message: "Pro subscription required",
    });
  }

  const activeSubscription = await ctx.db
    .query("subscriptions")
    .withIndex("customerId_status", (q) =>
      q.eq("customerId", customer.id).eq("status", "active")
    )
    .first();

  if (!activeSubscription) {
    throw new ConvexError({
      code: "FORBIDDEN",
      message: "Pro subscription required",
    });
  }
}

// Helper: Validate voice key
function validateVoiceKey(voiceKey: string | undefined): VoiceKey {
  return isValidVoiceKey(voiceKey) ? voiceKey : DEFAULT_VOICE_KEY;
}

// Helper: Fetch content info
async function fetchContentInfo(
  ctx: MutationCtx,
  args: {
    contentId: Id<"articleContents"> | Id<"subjectSections">;
    contentType: "article" | "subject";
  }
) {
  if (args.contentType === "article") {
    const article = await ctx.db.get("articleContents", args.contentId);
    if (!article) return null;
    return {
      title: article.title,
      contentHash: article.contentHash,
      locale: article.locale,
    };
  } else {
    const section = await ctx.db.get("subjectSections", args.contentId);
    if (!section) return null;
    return {
      title: section.title,
      contentHash: section.contentHash,
      locale: section.locale,
    };
  }
}

// Helper: Check cached audio
async function checkCachedAudio(
  ctx: MutationCtx,
  args: {
    contentId: Id<"articleContents"> | Id<"subjectSections">;
    contentType: "article" | "subject";
    voiceId: string;
    contentHash: string;
    userId: Id<"users">;
  }
) {
  const existing = await ctx.runQuery(
    internal.audioStudies.queries.getContentAudioByContentVoice,
    {
      contentId: args.contentId,
      contentType: args.contentType,
      voiceId: args.voiceId,
    }
  );

  if (!existing) return null;

  // Check if cached audio is valid
  if (
    existing.status === "completed" &&
    existing.audioStorageId &&
    existing.contentHash === args.contentHash
  ) {
    // Valid cached audio
    const audioUrl = await ctx.storage.getUrl(existing.audioStorageId);

    // Track user access
    await ctx.runMutation(
      internal.audioStudies.mutations.recordUserAudioAccess,
      {
        userId: args.userId,
        contentAudioId: existing._id,
        contentId: args.contentId,
        contentType: args.contentType,
      }
    );

    return {
      status: "cached" as const,
      contentAudioId: existing._id,
      audioUrl: audioUrl || "",
      audioDuration: existing.audioDuration || 0,
    };
  }

  // Audio exists but still generating
  if (
    existing.status === "pending" ||
    existing.status === "generating-script" ||
    existing.status === "generating-speech"
  ) {
    return {
      status: "generating" as const,
      contentAudioId: existing._id,
      voiceKey: "", // Will be added by caller
      message: "Audio is being generated. Please wait...",
    };
  }

  // Failed or stale - will regenerate
  return null;
}

// Helper: Start audio workflow
async function startAudioWorkflow(
  ctx: MutationCtx,
  args: {
    contentId: Id<"articleContents"> | Id<"subjectSections">;
    contentType: "article" | "subject";
    locale: "en" | "id";
    contentHash: string;
    voiceKey: VoiceKey;
    voiceId: string;
    voiceSettings: {
      stability?: number;
      similarityBoost?: number;
      style?: number;
    };
  }
) {
  // Use workflow manager to start generation
  const { workflow } = await import("@repo/backend/convex/workflow");
  
  const contentAudioId = await workflow.start(
    ctx,
    internal.audioStudies.workflows.generateAudio,
    {
      contentId: args.contentId,
      contentType: args.contentType,
      locale: args.locale,
      contentHash: args.contentHash,
      voiceKey: args.voiceKey,
      voiceId: args.voiceId,
      voiceSettings: args.voiceSettings,
    }
  );

  return contentAudioId;
}

// Helper: Track user access
async function trackUserAccess(
  ctx: MutationCtx,
  args: {
    userId: Id<"users">;
    contentAudioId: Id<"contentAudios">;
    contentId: Id<"articleContents"> | Id<"subjectSections">;
    contentType: "article" | "subject";
  }
) {
  await ctx.runMutation(
    internal.audioStudies.mutations.recordUserAudioAccess,
    {
      userId: args.userId,
      contentAudioId: args.contentAudioId,
      contentId: args.contentId,
      contentType: args.contentType,
    }
  );
}
```

**Output**: Public mutation with full access control and caching logic, split into helper functions for maintainability.

---

## üöÄ Next Steps

After this task:
- Next: Task 3.2 (Create get audio query)
- Dependencies: Task 1.3 (workflow), Task 2.1-2.3 (queries/mutations)

## üîó Related Tasks

- Task 3.2: Query used by UI to check generation status
- Task 5.1: Testing this mutation

## ‚ö†Ô∏è Important Notes

### Code Organization

The mutation is split into helper functions for clarity:
1. `authenticateUser` - Validates authentication
2. `validateProSubscription` - Checks Pro status
3. `validateVoiceKey` - Validates voice selection
4. `fetchContentInfo` - Gets content metadata
5. `checkCachedAudio` - Checks cache and returns if valid
6. `startAudioWorkflow` - Starts generation workflow
7. `trackUserAccess` - Records user access

This makes the main handler readable and each function testable.

### Auth Pattern

Uses standard Convex auth pattern:
1. `ctx.auth.getUserIdentity()` to get authenticated identity
2. Lookup user by `tokenIdentifier`
3. Use user._id for subsequent operations

### Pro Check

Checks `subscriptions` table via `customers`:
- Must have active subscription
- Uses `customerId_status` index for efficiency
- Throws `FORBIDDEN` if not Pro

### Workflow Start

Uses workflow manager from `@convex-dev/workflow`:
```typescript
const { workflow } = await import("@repo/backend/convex/workflow");
const contentAudioId = await workflow.start(
  ctx,
  internal.audioStudies.workflows.generateAudio,
  { ...args }
);
```

This provides:
- Durable execution with automatic retries
- Status tracking throughout pipeline
- Concurrent generation management

### Error Handling

Uses `ConvexError` with codes:
- `UNAUTHORIZED`: Not logged in
- `NOT_FOUND`: User or content not found
- `FORBIDDEN`: Not Pro subscriber

Client can handle these appropriately (show login modal, upgrade prompt, etc.)

### Import Paths

Uses package imports (not relative):
- `import { internal } from "@repo/backend/convex/_generated/api"`
- `import type { Id } from "@repo/backend/convex/_generated/dataModel"`
