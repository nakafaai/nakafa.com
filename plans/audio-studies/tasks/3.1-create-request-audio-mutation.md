# Task 3.1: Create Request Audio Mutation (Public API)

## üéØ Goal

Create public mutation for Pro users to request audio generation with proper access control and deduping.

## üìç Context

This is the main entry point for the audio feature. Pro users call this to request audio for content. It handles caching, deduping, and initiates the workflow.

## PRD

```json
{
  "category": "integration",
  "description": "Create public mutation for requesting audio generation with Pro subscription check",
  "steps": [
    "Create requestAudio mutation with auth check",
    "Validate Pro subscription status",
    "Validate voice selection",
    "Check cache (existing audio)",
    "Handle deduping (already generating)",
    "Start workflow if needed",
    "Track user access",
    "Return appropriate response"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Public mutation exists with auth validator
- [ ] Checks Pro subscription via subscriptions table
- [ ] Validates voice key against PREDEFINED_VOICES
- [ ] Returns cached audio if available
- [ ] Returns "generating" status if in progress
- [ ] Starts workflow for new requests
- [ ] Records user access

## Commands

```bash
pnpm typecheck
pnpm lint
```

## üìù Subtasks

### Subtask 3.1.1: Create Public Request Audio Mutation

**File to create**: `packages/backend/convex/audioStudies/api.ts`

**Implementation**:

```typescript
import { mutation } from "@repo/backend/convex/functions";
import { internal } from "./_generated/api";
import { vv } from "@repo/backend/convex/lib/validators";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import {
  PREDEFINED_VOICES,
  DEFAULT_VOICE_KEY,
  type VoiceKey,
  isValidVoiceKey,
  getVoiceConfig,
} from "@repo/ai/config/voices";
import { workflow } from "@repo/backend/convex/workflow";

/**
 * Request audio generation for content
 * 
 * Returns:
 * - { status: "cached", audioUrl: string } if audio exists
 * - { status: "generating", contentAudioId: string } if in progress or started
 * - { status: "error", message: string } on failure
 * 
 * Requires Pro subscription.
 */
export const requestAudio = mutation({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    voiceKey: v.optional(v.string()), // Defaults to "nina"
  },
  returns: v.union(
    v.object({
      status: v.literal("cached"),
      contentAudioId: vv.id("contentAudios"),
      audioUrl: v.string(),
      audioDuration: v.number(),
      voiceKey: v.string(),
    }),
    v.object({
      status: v.literal("generating"),
      contentAudioId: vv.id("contentAudios"),
      voiceKey: v.string(),
      message: v.string(),
    }),
    v.object({
      status: v.literal("error"),
      message: v.string(),
    })
  ),
  handler: async (ctx, args) => {
    // 1. Check authentication
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        code: "UNAUTHORIZED",
        message: "Authentication required",
      });
    }

    // 2. Get user
    const user = await ctx.db
      .query("users")
      .withIndex("tokenIdentifier", (q) =>
        q.eq("tokenIdentifier", identity.tokenIdentifier)
      )
      .first();

    if (!user) {
      throw new ConvexError({
        code: "NOT_FOUND",
        message: "User not found",
      });
    }

    // 3. Check Pro subscription
    const customer = await ctx.db
      .query("customers")
      .withIndex("userId", (q) => q.eq("userId", user._id))
      .first();

    if (!customer) {
      throw new ConvexError({
        code: "FORBIDDEN",
        message: "Pro subscription required",
      });
    }

    const activeSubscription = await ctx.db
      .query("subscriptions")
      .withIndex("customerId_status", (q) =>
        q.eq("customerId", customer.id).eq("status", "active")
      )
      .first();

    if (!activeSubscription) {
      throw new ConvexError({
        code: "FORBIDDEN",
        message: "Pro subscription required",
      });
    }

    // 4. Validate voice key
    const voiceKey: VoiceKey = isValidVoiceKey(args.voiceKey)
      ? args.voiceKey
      : DEFAULT_VOICE_KEY;

    const voiceConfig = getVoiceConfig(voiceKey);

    // 5. Fetch content and contentHash
    const contentInfo = await getContentInfo(ctx, {
      contentId: args.contentId,
      contentType: args.contentType,
    });

    if (!contentInfo) {
      throw new ConvexError({
        code: "NOT_FOUND",
        message: "Content not found",
      });
    }

    // 6. Check cache (existing audio)
    const existing = await ctx.runQuery(
      internal.audioStudies.queries.getContentAudioByContentVoice,
      {
        contentId: args.contentId,
        contentType: args.contentType,
        voiceId: voiceConfig.id,
      }
    );

    if (existing) {
      // 6a. Check if cached audio is still valid
      if (
        existing.status === "completed" &&
        existing.audioStorageId &&
        existing.contentHash === contentInfo.contentHash
      ) {
        // Valid cached audio - return it
        const audioUrl = await ctx.storage.getUrl(existing.audioStorageId);

        // Track user access
        await ctx.runMutation(
          internal.audioStudies.mutations.recordUserAudioAccess,
          {
            userId: user._id,
            contentAudioId: existing._id,
            contentId: args.contentId,
            contentType: args.contentType,
          }
        );

        return {
          status: "cached",
          contentAudioId: existing._id,
          audioUrl: audioUrl || "",
          audioDuration: existing.audioDuration || 0,
          voiceKey,
        };
      }

      // 6b. Audio exists but stale or not completed
      if (
        existing.status === "pending" ||
        existing.status === "generating_script" ||
        existing.status === "generating_speech"
      ) {
        // Already generating - return status
        return {
          status: "generating",
          contentAudioId: existing._id,
          voiceKey,
          message: "Audio is being generated. Please wait...",
        };
      }

      // Failed or stale - will regenerate below
    }

    // 7. Start workflow for new or regeneration
    const contentAudioId = await workflow.start(ctx, "audioStudies/workflows:generateAudio", {
      contentId: args.contentId,
      contentType: args.contentType,
      contentHash: contentInfo.contentHash,
      voiceKey,
      voiceId: voiceConfig.id,
      voiceSettings: voiceConfig.settings,
    });

    // 8. Track user access
    await ctx.runMutation(
      internal.audioStudies.mutations.recordUserAudioAccess,
      {
        userId: user._id,
        contentAudioId,
        contentId: args.contentId,
        contentType: args.contentType,
      }
    );

    return {
      status: "generating",
      contentAudioId,
      voiceKey,
      message: "Audio generation started. This may take a minute...",
    };
  },
});

/**
 * Helper to fetch content info (title, hash) based on type
 */
async function getContentInfo(
  ctx: MutationCtx,
  args: {
    contentId: string;
    contentType: "article" | "subject";
  }
) {
  if (args.contentType === "article") {
    const article = await ctx.db.get("articleContents", args.contentId as Id<"articleContents">);
    if (!article) return null;
    return {
      title: article.title,
      contentHash: article.contentHash,
    };
  } else {
    const section = await ctx.db.get("subjectSections", args.contentId as Id<"subjectSections">);
    if (!section) return null;
    return {
      title: section.title,
      contentHash: section.contentHash,
    };
  }
}
```

**Output**: Public mutation with full access control and caching logic.

---

## üöÄ Next Steps

After this task:
- Next: Task 3.2 (Create get audio query)
- Dependencies: Task 1.3 (workflow), Task 2.1-2.3 (queries/mutations)

## üîó Related Tasks

- Task 3.2: Query used by UI to check generation status
- Task 6.1: Testing this mutation

## ‚ö†Ô∏è Important Notes

### Auth Pattern

Uses standard Convex auth pattern:
1. `ctx.auth.getUserIdentity()` to get authenticated identity
2. Lookup user by `tokenIdentifier`
3. Use user._id for subsequent operations

### Pro Check

Checks `subscriptions` table via `customers`:
- Must have active subscription
- Uses `customerId_status` index for efficiency
- Throws `FORBIDDEN` if not Pro

### Workflow Start

`workflow.start()` returns the contentAudioId immediately:
- Creates record with "pending" status
- Workflow runs asynchronously
- Client polls for completion

### Error Handling

Uses `ConvexError` with codes:
- `UNAUTHORIZED`: Not logged in
- `NOT_FOUND`: User or content not found
- `FORBIDDEN`: Not Pro subscriber

Client can handle these appropriately (show login modal, upgrade prompt, etc.)
