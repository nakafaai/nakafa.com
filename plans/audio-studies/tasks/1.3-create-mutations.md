# Task 1.3: Create Audio Studies Mutations

## Goal
Create mutations for audio CRUD and user access tracking.

## File
`packages/backend/convex/audioStudies/mutations.ts`

## Implementation

```typescript
import { mutation, internalMutation } from "@repo/backend/convex/functions";
import { internal } from "@repo/backend/convex/_generated/api";
import { vv } from "@repo/backend/convex/lib/validators";
import { audioStatusValidator } from "@repo/backend/convex/lib/contentValidators";
import { v, ConvexError } from "convex/values";
import type { Id } from "@repo/backend/convex/_generated/dataModel";
import { workflow } from "@repo/backend/convex/workflow";
import { isValidVoiceKey, getVoiceConfig, DEFAULT_VOICE_KEY } from "@repo/ai/config/voices";

// Public: Request audio
export const request = mutation({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    voiceKey: v.optional(v.string()),
  },
  returns: v.union(
    v.object({ status: v.literal("cached"), id: vv.id("contentAudios"), url: v.string(), duration: v.number() }),
    v.object({ status: v.literal("generating"), id: vv.id("contentAudios") }),
    v.object({ status: v.literal("error"), message: v.string() })
  ),
  handler: async (ctx, args) => {
    // Auth
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError({ code: "UNAUTHORIZED", message: "Login required" });
    
    const user = await ctx.db.query("users")
      .withIndex("tokenIdentifier", q => q.eq("tokenIdentifier", identity.tokenIdentifier))
      .first();
    if (!user) throw new ConvexError({ code: "NOT_FOUND", message: "User not found" });
    
    // Pro check
    const customer = await ctx.db.query("customers")
      .withIndex("userId", q => q.eq("userId", user._id))
      .first();
    if (!customer) throw new ConvexError({ code: "FORBIDDEN", message: "Pro required" });
    
    const sub = await ctx.db.query("subscriptions")
      .withIndex("customerId_status", q => q.eq("customerId", customer.id).eq("status", "active"))
      .first();
    if (!sub) throw new ConvexError({ code: "FORBIDDEN", message: "Pro required" });

    // Voice
    const voiceKey = isValidVoiceKey(args.voiceKey || "") ? args.voiceKey as typeof DEFAULT_VOICE_KEY : DEFAULT_VOICE_KEY;
    const voice = getVoiceConfig(voiceKey);

    // Content
    const content = args.contentType === "article"
      ? await ctx.db.get("articleContents", args.contentId)
      : await ctx.db.get("subjectSections", args.contentId);
    if (!content) throw new ConvexError({ code: "NOT_FOUND", message: "Content not found" });

    // Cache check
    const existing = await ctx.runQuery(internal.audioStudies.queries.findByContentVoice, {
      contentId: args.contentId,
      contentType: args.contentType,
      voiceId: voice.id,
    });

    if (existing?.status === "completed" && existing.audioStorageId && existing.contentHash === content.contentHash) {
      const url = await ctx.storage.getUrl(existing.audioStorageId);
      await trackAccess(ctx, user._id, existing.id, args.contentId, args.contentType);
      return { status: "cached", id: existing.id, url: url || "", duration: 0 };
    }

    if (existing?.status === "pending" || existing?.status === "generating-script" || existing?.status === "generating-speech") {
      return { status: "generating", id: existing.id };
    }

    // Start workflow
    const id = await workflow.start(ctx, internal.audioStudies.workflows.generate, {
      contentId: args.contentId,
      contentType: args.contentType,
      locale: content.locale,
      contentHash: content.contentHash,
      voiceId: voice.id,
      voiceSettings: voice.settings,
    });

    await trackAccess(ctx, user._id, id, args.contentId, args.contentType);
    return { status: "generating", id };
  },
});

async function trackAccess(
  ctx: any,
  userId: Id<"users">,
  audioId: Id<"contentAudios">,
  contentId: Id<"articleContents"> | Id<"subjectSections">,
  contentType: "article" | "subject"
) {
  const existing = await ctx.db.query("userContentAudios")
    .withIndex("user_content", q =>
      q.eq("userId", userId).eq("contentId", contentId).eq("contentType", contentType)
    ).first();
  
  if (existing) {
    await ctx.db.patch(existing._id, { 
      contentAudioId: audioId, 
      lastPlayedAt: Date.now(), 
      updatedAt: Date.now() 
    });
  } else {
    await ctx.db.insert("userContentAudios", {
      userId,
      contentAudioId: audioId,
      contentId,
      contentType,
      playCount: 1,
      lastPlayedAt: Date.now(),
      updatedAt: Date.now(),
    });
  }
}

// Internal mutations
export const upsert = internalMutation({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    locale: v.union(v.literal("en"), v.literal("id")),
    contentHash: v.string(),
    voiceId: v.string(),
    voiceSettings: v.optional(v.object({
      stability: v.optional(v.number()),
      similarityBoost: v.optional(v.number()),
      style: v.optional(v.number()),
      useSpeakerBoost: v.optional(v.boolean()),
    })),
  },
  returns: vv.id("contentAudios"),
  handler: async (ctx, args) => {
    const existing = await ctx.db.query("contentAudios")
      .withIndex("content_voice", q =>
        q.eq("contentId", args.contentId).eq("contentType", args.contentType).eq("voiceId", args.voiceId)
      ).first();
    
    if (existing) {
      if (existing.contentHash !== args.contentHash) {
        await ctx.db.patch(existing._id, {
          contentHash: args.contentHash,
          status: "pending",
          script: undefined,
          audioStorageId: undefined,
          generationAttempts: 0,
          updatedAt: Date.now(),
        });
      }
      return existing._id;
    }
    
    return ctx.db.insert("contentAudios", {
      ...args,
      status: "pending",
      generationAttempts: 0,
      updatedAt: Date.now(),
    });
  },
});

export const updateStatus = internalMutation({
  args: { id: vv.id("contentAudios"), status: audioStatusValidator },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, { status: args.status, updatedAt: Date.now() });
    return null;
  },
});

export const saveScript = internalMutation({
  args: { id: vv.id("contentAudios"), script: v.string() },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, { script: args.script, status: "generating-speech", updatedAt: Date.now() });
    return null;
  },
});

export const saveAudio = internalMutation({
  args: {
    id: vv.id("contentAudios"),
    storageId: vv.id("_storage"),
    duration: v.number(),
    size: v.number(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch(args.id, {
      audioStorageId: args.storageId,
      audioDuration: args.duration,
      audioSize: args.size,
      status: "completed",
      updatedAt: Date.now(),
    });
    return null;
  },
});

export const markFailed = internalMutation({
  args: { id: vv.id("contentAudios"), error: v.string() },
  returns: v.null(),
  handler: async (ctx, args) => {
    const a = await ctx.db.get("contentAudios", args.id);
    if (a) {
      await ctx.db.patch(args.id, {
        status: "failed",
        errorMessage: args.error,
        failedAt: Date.now(),
        generationAttempts: a.generationAttempts + 1,
        updatedAt: Date.now(),
      });
    }
    return null;
  },
});

export const invalidate = internalMutation({
  args: {
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    newHash: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const audios = await ctx.db.query("contentAudios")
      .withIndex("content", q => q.eq("contentId", args.contentId).eq("contentType", args.contentType))
      .collect();
    
    for (const a of audios) {
      if (a.contentHash !== args.newHash) {
        if (a.audioStorageId) await ctx.storage.delete(a.audioStorageId);
        await ctx.db.patch(a._id, {
          contentHash: args.newHash,
          status: "pending",
          script: undefined,
          audioStorageId: undefined,
          generationAttempts: 0,
          updatedAt: Date.now(),
        });
      }
    }
    return null;
  },
});
```

## Commands
```bash
pnpm typecheck
```
