# Task 6.2: Test Cache Invalidation

## üéØ Goal

Test that audio cache is properly invalidated when content is updated.

## üìç Context

Verify the cache invalidation flow: content sync detects hash change ‚Üí invalidateAudio mutation resets records ‚Üí next request regenerates audio.

## PRD

```json
{
  "category": "testing",
  "description": "Test cache invalidation on content updates",
  "steps": [
    "Generate audio for content",
    "Verify audio is cached (second request returns cached)",
    "Update content (change MDX file)",
    "Run content sync",
    "Verify audio records are invalidated",
    "Request audio again",
    "Verify regeneration occurs"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Audio generated and cached correctly
- [ ] Content sync detects hash change
- [ ] invalidateAudio resets status to "pending"
- [ ] Audio fields cleared (script, storageId, etc.)
- [ ] New request triggers regeneration
- [ ] Same content re-synced (no hash change) doesn't invalidate

## Commands

```bash
pnpm typecheck
pnpm lint
pnpm test
```

## üìù Subtasks

### Subtask 6.2.1: Create Invalidation Test

**File to create**: `packages/backend/convex/audioStudies/__tests__/cacheInvalidation.test.ts`

**Implementation**:

```typescript
import { describe, it, expect, beforeEach } from "vitest";
import { convexTest } from "convex-test";
import schema from "../../schema";
import { api, internal } from "../_generated/api";

describe("Cache Invalidation", () => {
  const test = convexTest(schema);

  it("should invalidate audio when content changes", async () => {
    // Setup: Create article and generate audio
    const articleId = await test.mutation(
      internal.contentSync.mutations.upsertArticleContent,
      {
        // ... article data ...
        contentHash: "hash_v1",
      }
    );

    // Generate audio
    await test.mutation(internal.audioStudies.api.requestAudio, {
      contentId: articleId,
      contentType: "article",
      voiceKey: "nina",
    });

    // Verify audio is completed
    let audio = await test.query(
      internal.audioStudies.queries.getContentAudioByContentVoice,
      {
        contentId: articleId,
        contentType: "article",
        voiceId: PREDEFINED_VOICES.nina.id,
      }
    );
    expect(audio?.status).toBe("completed");

    // Update article with new content
    await test.mutation(
      internal.contentSync.mutations.upsertArticleContent,
      {
        // ... same article ...
        contentHash: "hash_v2", // Different hash
      }
    );

    // Verify audio is invalidated
    audio = await test.query(
      internal.audioStudies.queries.getContentAudioByContentVoice,
      {
        contentId: articleId,
        contentType: "article",
        voiceId: PREDEFINED_VOICES.nina.id,
      }
    );
    expect(audio?.status).toBe("pending");
    expect(audio?.script).toBeUndefined();
    expect(audio?.audioStorageId).toBeUndefined();
  });

  it("should not invalidate when content unchanged", async () => {
    // Same test but with same hash
    // Verify audio remains completed
  });
});
```

**Output**: Test suite for cache invalidation.

### Subtask 6.2.2: Manual Invalidation Test

**Test Steps**:

```markdown
## Manual Cache Invalidation Test

1. **Initial Generation**
   - Request audio for article "nepotism-in-governance"
   - Wait for completion
   - Note contentAudioId

2. **Verify Caching**
   - Request same audio again
   - Should return immediately (status: cached)

3. **Update Content**
   - Edit `articles/politics/nepotism-in-governance.mdx`
   - Change some text
   - Save file

4. **Run Sync**
   ```bash
   pnpm --filter backend sync:articles
   ```

5. **Verify Invalidation**
   - Check Convex dashboard
   - Find contentAudios record
   - Status should be "pending"
   - script, audioStorageId should be empty

6. **Request Regeneration**
   - Request audio again
   - Should return status: generating
   - Should trigger new workflow

7. **Verify New Audio**
   - Wait for completion
   - Audio URL should be different
   - Play to verify new content
```

**Output**: Step-by-step manual test guide.

---

## üöÄ Next Steps

After this task:
- Feature is complete and tested
- Ready for deployment

## üîó Related Tasks

- Task 6.1: Basic flow testing
- Tasks 4.1-4.2: Content sync integration being tested

## ‚ö†Ô∏è Important Notes

### Testing Environment

Use staging environment for testing:
- Separate Convex deployment
- Lower ElevenLabs costs
- Safe to regenerate multiple times

### Content Sync

Manual testing requires content sync to run:
```bash
pnpm --filter backend sync:articles
pnpm --filter backend sync:subjects
```

Or use Convex dashboard to manually trigger mutations.
