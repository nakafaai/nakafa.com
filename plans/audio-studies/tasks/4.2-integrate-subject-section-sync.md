# Task 4.2: Integrate with Subject Section Sync

## ðŸŽ¯ Goal

Invalidate cached audio when subject section content is updated.

## ðŸ“ Context

Same as article content sync - when subject sections are updated from MDX files, invalidate the cached audio.

## PRD

```json
{
  "category": "integration",
  "description": "Trigger audio invalidation when subject section content is updated",
  "steps": [
    "Modify subject section upsert mutation",
    "Check if contentHash changed",
    "Call invalidateAudio for changed content"
  ],
  "passes": false
}
```

## ðŸŽ¬ Success Criteria

- [ ] Subject section sync triggers audio invalidation
- [ ] Only invalidates when contentHash actually changes
- [ ] Consistent with article content sync pattern

## Commands

```bash
pnpm typecheck
pnpm lint
```

## ðŸ“ Subtasks

### Subtask 4.2.1: Modify Subject Section Upsert

**File to modify**: `packages/backend/convex/subjectSections/mutations.ts`

**Implementation**:

Add to the `upsertSubjectSection` mutation:

```typescript
import { internal } from "./_generated/api";

export const upsertSubjectSection = internalMutation({
  // ... existing args ...
  handler: async (ctx, args) => {
    // ... existing upsert logic ...

    if (existing) {
      if (existing.contentHash === args.contentHash) {
        return { id: existing._id, action: "unchanged" as const };
      }

      // Update section
      await ctx.db.patch("subjectSections", existing._id, {
        // ... existing updates ...
        contentHash: args.contentHash,
        syncedAt: now,
      });

      // Invalidate cached audio for this section
      await ctx.runMutation(
        internal.audioStudies.mutations.invalidateAudio,
        {
          contentId: existing._id,
          contentType: "subject",
          newContentHash: args.contentHash,
        }
      );

      return { id: existing._id, action: "updated" as const };
    }

    // Create new section
    const id = await ctx.db.insert("subjectSections", {
      // ... existing fields ...
      contentHash: args.contentHash,
      syncedAt: now,
    });

    // New section - no audio to invalidate
    return { id, action: "created" as const };
  },
});
```

**Output**: Subject section sync invalidates audio when content changes.

---

## ðŸš€ Next Steps

After this task:
- Next: Task 5.1 (Test audio generation flow)
- Dependencies: Task 4.1 (article sync)

## ðŸ”— Related Tasks

- Task 4.1: Same pattern for articles

## âš ï¸ Important Notes

### Consistency

Both article and subject sync use identical invalidation pattern:
- Check if hash changed
- Call invalidateAudio mutation
- Works for all voices (invalidateAudio finds all audios for content)

### Future: Trigger-Based Invalidation

Consider using Convex triggers for automatic invalidation:

```typescript
// In functions.ts
triggers.register("articleContents", async (ctx, change) => {
  if (change.operation === "update" && change.newDoc && change.oldDoc) {
    if (change.newDoc.contentHash !== change.oldDoc.contentHash) {
      await invalidateAudioHelper(ctx, {
        contentId: change.id,
        contentType: "article",
        newContentHash: change.newDoc.contentHash,
      });
    }
  }
});
```

This would centralize invalidation logic, but explicit calls in mutations are clearer for now.
