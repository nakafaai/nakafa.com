# Task 0.2: Create contentAudios Schema

## ðŸŽ¯ Goal

Define the database schema for contentAudios table with proper indexes and validation.

## ðŸ“ Context

Following Convex best practices, we need a well-indexed schema for:
1. Fast lookup by content + voice combination
2. Efficient cache invalidation by contentHash
3. Monitoring pending/failed jobs

## PRD

```json
{
  "category": "architecture",
  "description": "Create contentAudios schema with polymorphic content support and proper indexes",
  "steps": [
    "Create schema.ts in audioStudies directory",
    "Define contentAudios table with all required fields",
    "Add optimized indexes for query patterns",
    "Use vv validator for type-safe ID references",
    "Update main schema.ts to include new table"
  ],
  "passes": false
}
```

## ðŸŽ¬ Success Criteria

- [ ] Schema file exists at `packages/backend/convex/audioStudies/schema.ts`
- [ ] contentAudios table defined with all fields
- [ ] Indexes: content_voice, content, contentHash, status
- [ ] Uses vv validator for ID references
- [ ] Main schema.ts imports and includes the table
- [ ] TypeScript compiles without errors

## Commands

```bash
pnpm typecheck
pnpm lint
```

## ðŸ“ Subtasks

### Subtask 0.2.1: Create Schema File

**File to create**: `packages/backend/convex/audioStudies/schema.ts`

**Implementation**:

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";
import { vv } from "@repo/backend/convex/lib/validators";
import { localeValidator } from "@repo/backend/convex/lib/contentValidators";

const tables = {
  /**
   * Cached audio content for articles and subject sections.
   * Keyed by content + voice combination for cost optimization.
   * Auto-regenerates when contentHash changes.
   */
  contentAudios: defineTable({
    // Polymorphic content reference
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),

    // Content locale (en/id) - determines AI prompt language and voice settings
    locale: localeValidator,

    // Content hash for change detection and cache invalidation
    contentHash: v.string(),

    // Voice configuration
    voiceId: v.string(),
    voiceSettings: v.optional(
      v.object({
        stability: v.optional(v.number()),
        similarityBoost: v.optional(v.number()),
        style: v.optional(v.number()),
      })
    ),

    // Workflow status
    status: v.union(
      v.literal("pending"),
      v.literal("generating_script"),
      v.literal("generating_speech"),
      v.literal("completed"),
      v.literal("failed")
    ),

    // Generated script with intonation markers
    script: v.optional(v.string()),

    // Audio storage reference
    audioStorageId: v.optional(vv.id("_storage")),
    audioDuration: v.optional(v.number()), // seconds
    audioSize: v.optional(v.number()), // bytes

    // Error tracking
    errorMessage: v.optional(v.string()),
    failedAt: v.optional(v.number()),

    // Retry tracking
    generationAttempts: v.number(),

    // Manual update tracking (Convex has _creationTime but no _updateTime)
    updatedAt: v.number(),
  })
    // Primary lookup: get audio for specific content + voice
    .index("content_voice", ["contentId", "contentType", "voiceId"])
    // Check if audio exists for content (any voice)
    .index("content", ["contentId", "contentType"])
    // Find stale audios when content updates
    .index("contentHash", ["contentHash"])
    // Monitor pending/failed jobs
    .index("status", ["status"]),

  /**
   * User access tracking for content audios.
   * Separate table enables:
   * - User history/listening stats
   * - Rate limiting per user
   * - Analytics on popular content
   */
  userContentAudios: defineTable({
    userId: vv.id("users"),
    contentAudioId: vv.id("contentAudios"),
    // Denormalized for efficient queries without joins
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
    // Usage tracking
    playCount: v.number(),
    lastPlayedAt: v.optional(v.number()),
    // Manual update tracking
    updatedAt: v.number(),
  })
    .index("user", ["userId"])
    .index("user_content", ["userId", "contentId", "contentType"])
    .index("contentAudio", ["contentAudioId"]),
};

export default tables;
```

**Output**: Schema file with contentAudios and userContentAudios tables.

### Subtask 0.2.2: Update Main Schema

**File to modify**: `packages/backend/convex/schema.ts`

**Implementation**:

```typescript
// Add import at the top
import audioStudiesSchema from "@repo/backend/convex/audioStudies/schema";

// Add to defineSchema spread
export default defineSchema(
  {
    ...usersSchema,
    ...chatsSchema,
    // ... existing schemas ...
    ...audioStudiesSchema, // Add this
  },
  {
    schemaValidation: true,
  }
);
```

**Output**: Main schema includes new tables.

---

## ðŸš€ Next Steps

After this task:
- Next: Task 0.3 (Create voice samples storage)
- Dependencies: Task 0.1 (voice config used for voiceId validation)

## ðŸ”— Related Tasks

- Task 1.1-1.3: Use contentAudios schema in workflow
- Task 2.1-2.2: Query and mutate contentAudios
- Task 4.1-4.2: Content sync integration triggers

## âš ï¸ Important Notes

### Index Design Rationale

Following Convex best practices:

1. **`content_voice` index**: Primary lookup pattern. Compound index on [contentId, contentType, voiceId] for exact match queries.

2. **`content` index**: Find all audios for a content (any voice). Used for cache invalidation.

3. **`contentHash` index**: Find stale audios when content updates. Not for querying by hash value, but for the rare case we need to find all audios with a specific hash.

4. **`status` index**: Monitor pending/failed jobs. Consider adding time range if we query "pending for > 1 hour".

### No contentHash + voiceId Index

We don't need `.index("contentHash_voice", ["contentHash", "voiceId"])` because:
- We look up by content_voice first, then verify hash
- contentHash is only used for validation, not as primary lookup

### Polymorphic Design

Using `union` for contentId allows one table to handle both articles and subject sections. Alternative would be two separate tables, but that duplicates voice management logic.

### Locale Field

The `locale` field is stored for:
1. **AI Script Generation**: Determines prompt language (English vs Indonesian instructions)
2. **Analytics**: Track which locales have most audio usage
3. **Future Voice Selection**: If we add locale-specific voices later

Note: contentId is unique per locale (different IDs for en vs id content), so locale is not needed in the index for lookups. It's stored for analytics and AI prompt selection.
