# Task 2.3: Create userContentAudios Mutations

## ðŸŽ¯ Goal

Create mutations for tracking user audio access and play history.

## ðŸ“ Context

userContentAudios tracks which users have accessed which audio studies, enabling analytics, rate limiting, and user history features.

## PRD

```json
{
  "category": "architecture",
  "description": "Create mutations for userContentAudios table",
  "steps": [
    "Create recordUserAudioAccess mutation (track access)",
    "Create incrementPlayCount mutation (analytics)",
    "Create updateLastPlayed mutation (continue listening feature)"
  ],
  "passes": false
}
```

## ðŸŽ¬ Success Criteria

- [ ] Mutations for userContentAudios created
- [ ] Proper upsert pattern for tracking access
- [ ] Increment play count atomically
- [ ] Denormalized fields updated correctly

## Commands

```bash
pnpm typecheck
pnpm lint
```

## ðŸ“ Subtasks

### Subtask 2.3.1: Create User Audio Tracking Mutations

**File to create**: `packages/backend/convex/audioStudies/mutations.ts` (add to existing)

**Implementation**:

```typescript
/**
 * Record that a user accessed an audio study
 * Upsert pattern: creates if new, updates if exists
 */
export const recordUserAudioAccess = internalMutation({
  args: {
    userId: vv.id("users"),
    contentAudioId: vv.id("contentAudios"),
    contentId: v.union(vv.id("articleContents"), vv.id("subjectSections")),
    contentType: v.union(v.literal("article"), v.literal("subject")),
  },
  returns: vv.id("userContentAudios"),
  handler: async (ctx, args) => {
    const now = Date.now();

    // Check for existing record
    const existing = await ctx.db
      .query("userContentAudios")
      .withIndex("user_content", (q) =>
        q
          .eq("userId", args.userId)
          .eq("contentId", args.contentId)
          .eq("contentType", args.contentType)
      )
      .first();

    if (existing) {
      // Update last played
      await ctx.db.patch("userContentAudios", existing._id, {
        contentAudioId: args.contentAudioId, // Update in case voice changed
        lastPlayedAt: now,
        updatedAt: now,
      });
      return existing._id;
    }

    // Create new record
    const id = await ctx.db.insert("userContentAudios", {
      userId: args.userId,
      contentAudioId: args.contentAudioId,
      contentId: args.contentId,
      contentType: args.contentType,
      playCount: 1,
      lastPlayedAt: now,
      updatedAt: now,
    });

    return id;
  },
});

/**
 * Increment play count for analytics
 * Called when user plays audio
 */
export const incrementPlayCount = internalMutation({
  args: {
    userContentAudioId: vv.id("userContentAudios"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const record = await ctx.db.get("userContentAudios", args.userContentAudioId);
    if (!record) {
      return null;
    }

    await ctx.db.patch("userContentAudios", args.userContentAudioId, {
      playCount: record.playCount + 1,
      lastPlayedAt: Date.now(),
      updatedAt: Date.now(),
    });

    return null;
  },
});
```

**Output**: User audio tracking mutations.

---

## ðŸš€ Next Steps

After this task:
- Next: Task 3.1 (Create request audio mutation)
- Dependencies: Task 2.2 (contentAudios mutations)

## ðŸ”— Related Tasks

- Task 3.2: Public query uses userContentAudios for history

## âš ï¸ Important Notes

### Upsert Pattern

`recordUserAudioAccess` uses upsert:
- First access: create with playCount=1
- Subsequent access: update lastPlayedAt
- Voice change: update contentAudioId reference

### Rate Limiting

Future enhancement: check play count before allowing new generations:
```typescript
const recentAccesses = await ctx.db
  .query("userContentAudios")
  .withIndex("user", (q) => q.eq("userId", userId))
  .filter((q) => q.gte(q.field("updatedAt"), Date.now() - 24 * 60 * 60 * 1000))
  .collect();

if (recentAccesses.length > DAILY_LIMIT) {
  throw new Error("Daily limit exceeded");
}
```

### Analytics

userContentAudios enables:
- Most popular content (aggregate by contentId)
- User engagement (playCount distribution)
- Voice preferences (join with contentAudios)
- Retention (lastPlayedAt trends)
