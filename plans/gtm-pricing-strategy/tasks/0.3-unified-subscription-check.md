# Task 1.7: Update Unified Subscription Check

## ðŸŽ¯ Goal

Update `hasActiveSubscription` query to check both Polar subscriptions AND QRIS payments.

## ðŸ“ Context

**Current State:**
- `hasActiveSubscription` only checks Polar subscriptions table
- QRIS payments are stored in separate `qrisPayments` table
- Need unified check for both payment methods

**Why This Matters:**
- User might pay via Polar (international) OR QRIS (Indonesia)
- Both should grant Pro access
- Single source of truth for subscription status

## PRD

```json
{
  "category": "integration",
  "description": "Update hasActiveSubscription to check both Polar and QRIS payments",
  "steps": [
    "Read current hasActiveSubscription implementation",
    "Add QRIS payment check",
    "Return true if either Polar OR QRIS subscription is active",
    "Test with both payment methods"
  ],
  "passes": false
}
```

## ðŸŽ¬ Success Criteria

- [ ] hasActiveSubscription checks Polar subscriptions
- [ ] hasActiveSubscription checks QRIS payments
- [ ] Returns true if either is active
- [ ] Works for both Indonesia (QRIS) and International (Polar) users
- [ ] No breaking changes to existing Polar flow

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck
pnpm test
```

## ðŸ“ Subtasks

### Subtask 1.7.1: Read Current Implementation

Current `hasActiveSubscription` in `/packages/backend/convex/subscriptions/queries.ts`:

```typescript
export const hasActiveSubscription = query({
  args: {
    productId: v.string(),
  },
  returns: v.boolean(),
  handler: async (ctx, args) => {
    const { appUser } = await requireAuth(ctx);

    const customer = await ctx.db
      .query("customers")
      .withIndex("userId", (q) => q.eq("userId", appUser._id))
      .unique();

    if (!customer) {
      return false;
    }

    const subscription = await ctx.db
      .query("subscriptions")
      .withIndex("customerId_status", (q) =>
        q.eq("customerId", customer.id).eq("status", "active")
      )
      .first();

    return subscription?.productId === args.productId;
  },
});
```

**Output**: Current implementation understood

---

### Subtask 1.7.2: Add QRIS Payment Check

Update query to check both Polar and QRIS with proper validity checks.

**File**: `/packages/backend/convex/subscriptions/queries.ts`

```typescript
export const hasActiveSubscription = query({
  args: {
    productId: v.optional(v.string()), // Made optional for unified check
  },
  returns: v.boolean(),
  handler: async (ctx, args) => {
    const { appUser } = await requireAuth(ctx);

    // Check 1: Polar subscription
    const customer = await ctx.db
      .query("customers")
      .withIndex("userId", (q) => q.eq("userId", appUser._id))
      .unique();

    let hasPolarSub = false;
    if (customer) {
      const subscription = await ctx.db
        .query("subscriptions")
        .withIndex("customerId_status", (q) =>
          q.eq("customerId", customer.id).eq("status", "active")
        )
        .first();
      
      // If productId specified, check match. Otherwise any active sub counts.
      hasPolarSub = args.productId 
        ? subscription?.productId === args.productId
        : !!subscription;
    }

    // Check 2: QRIS payment (with 30 days + 3 days grace period)
    const qrisPayment = await ctx.db
      .query("qrisPayments")
      .withIndex("userId_status", (q) =>
        q.eq("userId", appUser._id).eq("status", "paid")
      )
      .order("desc")
      .first();

    let hasValidQris = false;
    if (qrisPayment?.paidAt) {
      const THIRTY_DAYS = 30 * 24 * 60 * 60 * 1000;
      const GRACE_PERIOD = 3 * 24 * 60 * 60 * 1000;
      const timeSincePayment = Date.now() - qrisPayment.paidAt;
      
      // Valid if within 30 days OR within grace period (33 days total)
      hasValidQris = timeSincePayment < (THIRTY_DAYS + GRACE_PERIOD);
    }

    // Return true if EITHER payment method is active
    return hasPolarSub || hasValidQris;
  },
});
```

**Key Changes:**
1. Made `productId` optional (for unified check)
2. Added QRIS payment query with `userId_status` index
3. **CRITICAL**: Added validity check - QRIS payment only counts if within 30 days + 3 days grace period
4. Uses `.order("desc")` to get most recent payment first
5. Returns true if either Polar OR QRIS is active
6. Maintains backward compatibility

**Why the Validity Check Matters:**
Without this check, any past QRIS payment would grant permanent Pro access. The check ensures:
- Payment is within 30-day subscription period
- Includes 3-day grace period after expiry
- Users must renew to maintain access

**Output**: Unified subscription check implemented

---

### Subtask 1.7.3: Test Both Payment Methods

Test that both Polar and QRIS grant Pro access.

**Test Case 1: Polar Subscription**
```typescript
// User with active Polar subscription
const result = await ctx.runQuery(api.subscriptions.hasActiveSubscription, {
  productId: "pro"
});
// Expected: true
```

**Test Case 2: QRIS Payment**
```typescript
// User with paid QRIS payment (no Polar)
const result = await ctx.runQuery(api.subscriptions.hasActiveSubscription, {});
// Expected: true
```

**Test Case 3: No Subscription**
```typescript
// User with no payments
const result = await ctx.runQuery(api.subscriptions.hasActiveSubscription, {});
// Expected: false
```

**Output**: Both payment methods verified working

---

## ðŸš€ Next Steps

After completing this task:

1. **Test end-to-end**: Create test payments via both methods
2. **Verify frontend**: Ensure UI shows Pro features for both
3. **Deploy**: Both payment methods now work seamlessly

## ðŸ”— Related Tasks

- Task 1.3: QRIS Backend Integration (creates qrisPayments table)
- Task 1.4: Frontend Checkout (uses this query)

## âš ï¸ Important Notes

### Backward Compatibility

- Existing Polar flow continues to work unchanged
- `productId` parameter still works as before
- New QRIS check is additive (OR logic)

### Data Consistency

- Polar subscriptions: Use `subscriptions` table
- QRIS payments: Use `qrisPayments` table
- Both grant Pro access via unified query

### Future Considerations

If you need to differentiate between Polar and QRIS subscribers:
```typescript
// Get subscription source
const polarSub = await ctx.db.query("subscriptions")...
const qrisPayment = await ctx.db.query("qrisPayments")...

const source = polarSub ? "polar" : qrisPayment ? "qris" : "none";
```

### Progress Tracking

After completing this task, update `plans/gtm-pricing-strategy/progress.txt`:

```txt
[YYYY-MM-DD HH:mm] Task 1.7 completed

Key decisions:
- Unified hasActiveSubscription query
- Checks both Polar (subscriptions table) and QRIS (qrisPayments table)
- Backward compatible with existing Polar flow
- Returns true if EITHER payment method is active

Files changed:
- packages/backend/convex/subscriptions/queries.ts (updated)

Blockers/notes:
- None. Both payment methods now work.
```
