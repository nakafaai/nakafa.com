# Task 1.3: QRIS.id Backend Integration

## üéØ Goal

Implement complete QRIS.id payment backend with server-side polling and subscription activation.

## üìç Context

**Prerequisites:**
- QRIS.id merchant approved (Task 1.1)
- API credentials received (apikey, mID, NMID)
- Convex environment variables set

**Architecture:**
- Server-side polling (not frontend)
- Works even if user closes browser
- Handles all edge cases automatically
- Batch processing for efficiency

**API Documentation:** https://qris.online/api-doc/

## PRD

```json
{
  "category": "integration",
  "description": "Implement QRIS.id payment backend with automated polling and subscription activation",
  "steps": [
    "Create QRIS API client",
    "Implement invoice creation",
    "Implement status checking",
    "Set up Convex cron jobs for polling",
    "Create subscription activation logic",
    "Handle edge cases (expired, failed, duplicate)"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] QRIS API client created and tested
- [ ] Invoice creation working
- [ ] Status checking with polling implemented
- [ ] Cron jobs running every 30 seconds
- [ ] Subscription activation on payment
- [ ] Edge cases handled (expired, failed, duplicate)
- [ ] Error tracking and retry logic

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck
pnpm test
pnpm --filter backend dev
```

## üìù Subtasks

### Subtask 1.3.1: Create QRIS API Client

Create API client for QRIS.id endpoints.

**File**: `packages/backend/convex/qris/api.ts`

```typescript
const QRIS_API_BASE = "https://qris.interactive.co.id/restapi/qris";

interface QrisInvoiceResponse {
  status: "success" | "failed";
  data: {
    qris_content: string;
    qris_request_date: string;
    qris_invoiceid: string;
    qris_nmid: string;
  };
}

interface QrisCheckResponse {
  status: "success" | "failed";
  data: {
    qris_status: "paid" | "unpaid";
    qris_payment_customername?: string;
    qris_payment_methodby?: string;
  };
}

export async function createQrisInvoice(params: {
  apiKey: string;
  mId: string;
  amount: number;
  transactionNumber: string;
}) {
  const url = new URL(`${QRIS_API_BASE}/show_qris.php`);
  url.searchParams.set("do", "create-invoice");
  url.searchParams.set("apikey", params.apiKey);
  url.searchParams.set("mID", params.mId);
  url.searchParams.set("cliTrxNumber", params.transactionNumber);
  url.searchParams.set("cliTrxAmount", params.amount.toString());
  url.searchParams.set("useTip", "no");

  const response = await fetch(url.toString());
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const data: QrisInvoiceResponse = await response.json();

  if (data.status !== "success") {
    throw new Error("Failed to create QRIS invoice");
  }

  return {
    content: data.data.qris_content,
    invoiceId: data.data.qris_invoiceid,
    nmid: data.data.qris_nmid,
  };
}

export async function checkQrisPayment(params: {
  apiKey: string;
  mId: string;
  invoiceId: string;
  amount: number;
  date: string;
}) {
  const url = new URL(`${QRIS_API_BASE}/checkpaid_qris.php`);
  url.searchParams.set("do", "checkStatus");
  url.searchParams.set("apikey", params.apiKey);
  url.searchParams.set("mID", params.mId);
  url.searchParams.set("invid", params.invoiceId);
  url.searchParams.set("trxvalue", params.amount.toString());
  url.searchParams.set("trxdate", params.date);

  const response = await fetch(url.toString());
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const data: QrisCheckResponse = await response.json();

  if (data.status !== "success") {
    return { status: "unpaid" as const };
  }

  return {
    status: data.data.qris_status,
    customerName: data.data.qris_payment_customername,
    paymentMethod: data.data.qris_payment_methodby,
  };
}
```

**Output**: QRIS API client created

---

### Subtask 1.3.2: Create Database Schema

Add QRIS payments table to Convex schema.

**File**: Create `packages/backend/convex/qrisPayments/schema.ts`

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";

const tables = {
  qrisPayments: defineTable({
    userId: v.id("users"),
    invoiceId: v.string(),
    amount: v.number(),
    qrisContent: v.string(),
    status: v.union(
      v.literal("pending"),
      v.literal("paid"),
      v.literal("expired"),
      v.literal("failed")
    ),
    expiresAt: v.number(),
    createdAt: v.number(),
    lastCheckedAt: v.optional(v.number()),
    checkCount: v.number(),
    paidAt: v.optional(v.number()),
    paymentMethod: v.optional(v.string()),
    customerName: v.optional(v.string()),
    errorCount: v.number(),
    lastError: v.optional(v.string()),
  })
    .index("by_invoiceId", ["invoiceId"])
    .index("by_userId", ["userId"])
    .index("by_status", ["status"])
    .index("by_status_createdAt", ["status", "createdAt"]),
};

export default tables;
```

**File**: Update `packages/backend/convex/schema.ts`

```typescript
import qrisPaymentsSchema from "./qrisPayments/schema"; // Add import

export default defineSchema(
  {
    ...usersSchema,
    ...chatsSchema,
    ...commentsSchema,
    ...customersSchema,
    ...subscriptionsSchema,
    ...qrisPaymentsSchema, // Add to schema
    ...schoolsSchema,
    // ... rest of schemas
  },
  {
    schemaValidation: true,
  }
);
```

**Output**: Database schema extended with qrisPayments table

---

### Subtask 1.3.3: Implement Create Payment Action

Create Convex action to generate QRIS invoice.

**File**: `packages/backend/convex/qris/actions.ts`

```typescript
import { action } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";
import { createQrisInvoice } from "./api";

export const createPayment = action({
  args: {
    amount: v.number(),
    planType: v.union(v.literal("monthly"), v.literal("yearly")),
  },
  returns: v.object({
    invoiceId: v.string(),
    qrisContent: v.string(),
    expiresAt: v.number(),
    nmid: v.string(),
  }),
  handler: async (ctx, args) => {
    const userId = await ctx.auth.getUserIdentity();
    if (!userId) {
      throw new Error("Unauthorized");
    }

    // Check for existing pending payment
    const existing = await ctx.runQuery(
      internal.qris.queries.getPendingPaymentByUser,
      { userId: userId.subject }
    );

    if (existing && existing.expiresAt > Date.now()) {
      return {
        invoiceId: existing.invoiceId,
        qrisContent: existing.qrisContent,
        expiresAt: existing.expiresAt,
        nmid: process.env.QRIS_NMID!,
      };
    }

    // Create new QRIS invoice
    const transactionNumber = `NAKAFA-${userId.subject}-${Date.now()}`;
    
    const invoice = await createQrisInvoice({
      apiKey: process.env.QRIS_API_KEY!,
      mId: process.env.QRIS_MID!,
      amount: args.amount,
      transactionNumber,
    });

    // Store in database
    await ctx.runMutation(internal.qris.mutations.createPayment, {
      userId: userId.subject,
      invoiceId: invoice.invoiceId,
      amount: args.amount,
      qrisContent: invoice.content,
      planType: args.planType,
      expiresAt: Date.now() + 30 * 60 * 1000, // 30 minutes
    });

    return {
      invoiceId: invoice.invoiceId,
      qrisContent: invoice.content,
      expiresAt: Date.now() + 30 * 60 * 1000,
      nmid: invoice.nmid,
    };
  },
});
```

**Output**: Create payment action implemented

---

### Subtask 1.3.4: Implement Server-Side Polling

Create cron job and scheduler for automated payment checking.

**File**: Create `packages/backend/convex/crons.ts`

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

// Check pending QRIS payments every 30 seconds
cronJobs.interval(
  "check pending QRIS payments",
  { seconds: 30 },
  internal.qris.scheduler.checkPendingPayments
);

// Cleanup expired payments every hour
cronJobs.interval(
  "cleanup expired QRIS payments",
  { hours: 1 },
  internal.qris.scheduler.cleanupExpiredPayments
);
```

**Note**: This file does not exist yet. Create it at `packages/backend/convex/crons.ts`.

**Output**: Cron jobs configured for QRIS polling

**File**: `packages/backend/convex/qris/scheduler.ts`

```typescript
import { internalAction } from "./_generated/server";
import { internal } from "./_generated/api";

const CONFIG = {
  BATCH_SIZE: 5,
  CHECK_INTERVAL_MS: 15000,
  MAX_CHECK_ATTEMPTS: 40,
};

export const checkPendingPayments = internalAction({
  args: {},
  handler: async (ctx) => {
    const now = Date.now();
    
    const payments = await ctx.runQuery(
      internal.qris.queries.getPaymentsToCheck,
      {
        limit: CONFIG.BATCH_SIZE,
        minIntervalMs: CONFIG.CHECK_INTERVAL_MS,
        maxAttempts: CONFIG.MAX_CHECK_ATTEMPTS,
        now,
      }
    );

    for (const payment of payments) {
      try {
        await ctx.runAction(internal.qris.actions.checkPayment, {
          invoiceId: payment.invoiceId,
          amount: payment.amount,
        });
      } catch (error) {
        console.error(`Failed to check ${payment.invoiceId}:`, error);
        await ctx.runMutation(internal.qris.mutations.recordError, {
          invoiceId: payment.invoiceId,
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    }
  },
});
```

**Output**: Server-side polling implemented

---

### Subtask 1.3.5: Implement Subscription Activation

Activate Pro subscription when payment is detected.

**File**: Create `packages/backend/convex/qris/mutations.ts`

```typescript
import { internalMutation } from "./_generated/server";
import { v } from "convex/values";
import { internal } from "./_generated/api";

export const activateSubscription = internalMutation({
  args: {
    invoiceId: v.string(),
    paymentMethod: v.string(),
    customerName: v.string(),
  },
  handler: async (ctx, args) => {
    const payment = await ctx.db
      .query("qrisPayments")
      .withIndex("by_invoiceId", (q) => q.eq("invoiceId", args.invoiceId))
      .unique();

    if (!payment || payment.status !== "pending") {
      return;
    }

    // Mark as paid
    await ctx.db.patch(payment._id, {
      status: "paid",
      paymentMethod: args.paymentMethod,
      customerName: args.customerName,
      paidAt: Date.now(),
    });

    // Note: Unlike Polar, QRIS doesn't create a subscription record
    // The qrisPayments table with status="paid" serves as the subscription proof
    // hasActiveSubscription query checks both subscriptions (Polar) and qrisPayments (QRIS)
  },
});
```

**Output**: Subscription activation implemented

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 1.4 - Frontend Checkout Implementation
2. **Test**: End-to-end payment flow

## üîó Related Tasks

- Task 1.1: QRIS.id Registration (prerequisite)
- Task 1.2: Polar Pricing Update (parallel)
- Task 1.4: Frontend Checkout (next)

## ‚ö†Ô∏è Important Notes

### Why Server-Side Polling?

**Problems with Frontend Polling:**
- ‚ùå Stops if user closes browser
- ‚ùå Stops if user refreshes page
- ‚ùå Misses payments on different device
- ‚ùå Duplicates requests from multiple tabs

**Server-Side Benefits:**
- ‚úÖ Works even if user closes browser
- ‚úÖ Detects payments from any device
- ‚úÖ Efficient batch processing
- ‚úÖ Handles all edge cases

### Edge Cases Handled

1. **User pays on different device**
   - Backend detects payment anyway
   - Status updates when user returns

2. **User refreshes page**
   - Polling continues on backend
   - New page load shows updated status

3. **Payment after expiry**
   - 5-minute grace period
   - Still honored if within grace period

4. **Duplicate payments**
   - Idempotent activation
   - Only activates once

### Rate Limiting

**QRIS.id API Limits:**
- Don't check more than every 15 seconds
- Max 3 checks per 15 seconds per invoice
- Our implementation: 30-second cron, 15-second min interval

### Progress Tracking

After completing this task, update `plans/gtm-pricing-strategy/progress.txt`:

```txt
[YYYY-MM-DD HH:mm] Task 1.3 completed

Key decisions:
- Server-side polling (not frontend)
- 30-second cron job interval
- 15-second minimum between checks
- Batch size: 5 payments per run

Files changed:
- packages/backend/convex/qris/api.ts (created)
- packages/backend/convex/qris/scheduler.ts (created)
- packages/backend/convex/qris/mutations.ts (created)
- packages/backend/convex/crons.ts (updated)
- packages/backend/convex/schema.ts (updated)

Blockers/notes:
- None. Ready for frontend integration.
```
