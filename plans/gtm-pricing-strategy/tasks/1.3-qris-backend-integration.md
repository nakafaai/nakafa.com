# Task 1.3: QRIS.id Backend Integration

## üéØ Goal

Implement complete QRIS.id payment backend with server-side polling and subscription activation.

## üìç Context

**Prerequisites:**
- QRIS.id merchant approved (Task 0.1)
- API credentials received (apikey, mID, NMID)
- Convex environment variables set

**Architecture:**
- Server-side polling (not frontend)
- Works even if user closes browser
- Handles all edge cases automatically
- Batch processing for efficiency

**API Documentation:** https://qris.online/api-doc/

## PRD

```json
{
  "category": "integration",
  "description": "Implement QRIS.id payment backend with automated polling and subscription activation",
  "steps": [
    "Create QRIS API client",
    "Create qrisPayments table schema",
    "Implement invoice creation action",
    "Implement status checking action",
    "Set up Convex cron jobs for polling",
    "Create subscription activation mutation"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] QRIS API client created and tested
- [ ] qrisPayments table schema created
- [ ] Invoice creation action working
- [ ] Status checking with polling implemented
- [ ] Cron jobs running every 30 seconds
- [ ] Subscription activation on payment
- [ ] Edge cases handled (expired, failed, duplicate)

## Commands

```bash
# From root directory
pnpm lint
pnpm typecheck
pnpm test
pnpm --filter backend dev
```

## üìù Subtasks

### Subtask 1.3.1: Create QRIS API Client

Create API client for QRIS.id endpoints.

**File**: `packages/backend/convex/payments/lib/qrisApi.ts`

```typescript
"use node";

const QRIS_API_BASE = "https://qris.interactive.co.id/restapi/qris";

interface QrisInvoiceResponse {
  status: "success" | "failed";
  data: {
    qris_content: string;
    qris_request_date: string;
    qris_invoiceid: string;
    qris_nmid: string;
  };
}

interface QrisCheckResponse {
  status: "success" | "failed";
  data: {
    qris_status: "paid" | "unpaid";
    qris_payment_customername?: string;
    qris_payment_methodby?: string;
  };
}

export async function createQrisInvoice(params: {
  apiKey: string;
  mId: string;
  amount: number;
  transactionNumber: string;
}) {
  const url = new URL(`${QRIS_API_BASE}/show_qris.php`);
  url.searchParams.set("do", "create-invoice");
  url.searchParams.set("apikey", params.apiKey);
  url.searchParams.set("mID", params.mId);
  url.searchParams.set("cliTrxNumber", params.transactionNumber);
  url.searchParams.set("cliTrxAmount", params.amount.toString());
  url.searchParams.set("useTip", "no");

  const response = await fetch(url.toString());
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const data: QrisInvoiceResponse = await response.json();

  if (data.status !== "success") {
    throw new Error("Failed to create QRIS invoice");
  }

  return {
    content: data.data.qris_content,
    invoiceId: data.data.qris_invoiceid,
    nmid: data.data.qris_nmid,
  };
}

export async function checkQrisPayment(params: {
  apiKey: string;
  mId: string;
  invoiceId: string;
  amount: number;
  date: string;
}) {
  const url = new URL(`${QRIS_API_BASE}/checkpaid_qris.php`);
  url.searchParams.set("do", "checkStatus");
  url.searchParams.set("apikey", params.apiKey);
  url.searchParams.set("mID", params.mId);
  url.searchParams.set("invid", params.invoiceId);
  url.searchParams.set("trxvalue", params.amount.toString());
  url.searchParams.set("trxdate", params.date);

  const response = await fetch(url.toString());
  
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }

  const data: QrisCheckResponse = await response.json();

  if (data.status !== "success") {
    return { status: "unpaid" as const };
  }

  return {
    status: data.data.qris_status,
    customerName: data.data.qris_payment_customername,
    paymentMethod: data.data.qris_payment_methodby,
  };
}
```

**Output**: QRIS API client created

---

### Subtask 1.3.2: Create Database Schema

Add QRIS payments table to Convex schema.

**File**: Create `packages/backend/convex/qrisPayments/schema.ts`

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";

const tables = {
  qrisPayments: defineTable({
    userId: v.id("users"),
    invoiceId: v.string(),
    amount: v.number(),
    currency: v.literal("IDR"),
    qrisContent: v.string(),
    status: v.union(
      v.literal("pending"),
      v.literal("paid"),
      v.literal("expired"),
      v.literal("failed")
    ),
    expiresAt: v.number(),
    createdAt: v.number(),
    updatedAt: v.number(),
    lastCheckedAt: v.optional(v.number()),
    checkCount: v.number(),
    paidAt: v.optional(v.number()),
    paymentMethod: v.optional(v.string()),
    customerName: v.optional(v.string()),
    errorCount: v.number(),
    lastError: v.optional(v.string()),
  })
    .index("userId", ["userId"])
    .index("userId_status", ["userId", "status"])
    .index("invoiceId", ["invoiceId"])
    .index("status", ["status"])
    .index("status_createdAt", ["status", "createdAt"]),
};

export default tables;
```

**File**: Update `packages/backend/convex/schema.ts`

```typescript
import qrisPaymentsSchema from "@repo/backend/convex/qrisPayments/schema";

export default defineSchema(
  {
    ...usersSchema,
    ...chatsSchema,
    ...commentsSchema,
    ...customersSchema,
    ...subscriptionsSchema,
    ...qrisPaymentsSchema,
    ...schoolsSchema,
    // ... rest of schemas
  },
  { schemaValidation: true }
);
```

**Output**: Database schema extended with qrisPayments table

---

### Subtask 1.3.3: Implement Create Payment Action

Create Convex action to generate QRIS invoice.

**File**: `packages/backend/convex/payments/actions.ts`

```typescript
"use node";

import { action } from "@repo/backend/convex/_generated/server";
import { internal } from "@repo/backend/convex/_generated/api";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import { createQrisInvoice } from "./lib/qrisApi";
import type { Id } from "@repo/backend/convex/_generated/dataModel";

const QRIS_CONFIG = {
  apiKey: process.env.QRIS_API_KEY || "",
  mId: process.env.QRIS_MID || "",
  nmid: process.env.QRIS_NMID || "",
};

export const createQrisPayment = action({
  args: {
    amount: v.number(),
  },
  returns: v.object({
    invoiceId: v.string(),
    qrisContent: v.string(),
    expiresAt: v.number(),
    nmid: v.string(),
  }),
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError({
        code: "UNAUTHORIZED",
        message: "User must be authenticated",
      });
    }

    const userId = identity.subject as Id<"users">;

    // Check for existing pending payment
    const existing = await ctx.runQuery(
      internal.qrisPayments.queries.getPendingPaymentByUser,
      { userId }
    );

    if (existing && existing.expiresAt > Date.now()) {
      return {
        invoiceId: existing.invoiceId,
        qrisContent: existing.qrisContent,
        expiresAt: existing.expiresAt,
        nmid: QRIS_CONFIG.nmid,
      };
    }

    // Create new QRIS invoice
    const transactionNumber = `NAKAFA-${userId}-${Date.now()}`;
    
    const invoice = await createQrisInvoice({
      apiKey: QRIS_CONFIG.apiKey,
      mId: QRIS_CONFIG.mId,
      amount: args.amount,
      transactionNumber,
    });

    const expiresAt = Date.now() + 30 * 60 * 1000; // 30 minutes

    // Store in database
    await ctx.runMutation(internal.qrisPayments.mutations.createPayment, {
      userId,
      invoiceId: invoice.invoiceId,
      amount: args.amount,
      currency: "IDR",
      qrisContent: invoice.content,
      expiresAt,
    });

    return {
      invoiceId: invoice.invoiceId,
      qrisContent: invoice.content,
      expiresAt,
      nmid: invoice.nmid,
    };
  },
});
```

**Output**: Create payment action implemented

---

### Subtask 1.3.4: Implement Server-Side Polling

Create cron job and scheduler for automated payment checking.

**File**: Create `packages/backend/convex/crons.ts`

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

cronJobs.interval(
  "checkPendingQrisPayments",
  { seconds: 30 },
  internal.payments.checkPendingQrisPayments
);

cronJobs.interval(
  "cleanupExpiredQrisPayments",
  { hours: 1 },
  internal.payments.cleanupExpiredQrisPayments
);
```

**File**: `packages/backend/convex/payments/actions.ts` (add to existing)

```typescript
"use node";

import { internalAction } from "@repo/backend/convex/_generated/server";
import { internal } from "@repo/backend/convex/_generated/api";

const CONFIG = {
  BATCH_SIZE: 5,
  CHECK_INTERVAL_MS: 15000,
  MAX_CHECK_ATTEMPTS: 40,
};

export const checkPendingQrisPayments = internalAction({
  args: {},
  handler: async (ctx) => {
    const now = Date.now();
    
    const payments = await ctx.runQuery(
      internal.qrisPayments.queries.getPaymentsToCheck,
      {
        limit: CONFIG.BATCH_SIZE,
        minIntervalMs: CONFIG.CHECK_INTERVAL_MS,
        maxAttempts: CONFIG.MAX_CHECK_ATTEMPTS,
        now,
      }
    );

    for (const payment of payments) {
      try {
        await ctx.runAction(internal.payments.checkQrisPaymentStatus, {
          invoiceId: payment.invoiceId,
          amount: payment.amount,
        });
      } catch (error) {
        console.error(`Failed to check ${payment.invoiceId}:`, error);
        await ctx.runMutation(internal.qrisPayments.mutations.recordError, {
          invoiceId: payment.invoiceId,
          error: error instanceof Error ? error.message : "Unknown error",
        });
      }
    }
  },
});
```

**Output**: Server-side polling implemented

---

### Subtask 1.3.5: Implement Subscription Activation

Activate Pro subscription when payment is detected.

**File**: Create `packages/backend/convex/qrisPayments/mutations.ts`

```typescript
import { internalMutation } from "@repo/backend/convex/_generated/server";
import { v } from "convex/values";

export const createPayment = internalMutation({
  args: {
    userId: v.id("users"),
    invoiceId: v.string(),
    amount: v.number(),
    currency: v.literal("IDR"),
    qrisContent: v.string(),
    expiresAt: v.number(),
  },
  returns: v.id("qrisPayments"),
  handler: async (ctx, args) => {
    const now = Date.now();
    
    return await ctx.db.insert("qrisPayments", {
      userId: args.userId,
      invoiceId: args.invoiceId,
      amount: args.amount,
      currency: args.currency,
      qrisContent: args.qrisContent,
      status: "pending",
      expiresAt: args.expiresAt,
      createdAt: now,
      updatedAt: now,
      checkCount: 0,
      errorCount: 0,
    });
  },
});

export const markAsPaid = internalMutation({
  args: {
    invoiceId: v.string(),
    paymentMethod: v.string(),
    customerName: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const payment = await ctx.db
      .query("qrisPayments")
      .withIndex("invoiceId", (q) => q.eq("invoiceId", args.invoiceId))
      .unique();

    if (!payment || payment.status !== "pending") {
      return null;
    }

    const now = Date.now();
    const thirtyDays = 30 * 24 * 60 * 60 * 1000;

    await ctx.db.patch(payment._id, {
      status: "paid",
      paymentMethod: args.paymentMethod,
      customerName: args.customerName,
      paidAt: now,
      expiresAt: now + thirtyDays,
      updatedAt: now,
    });

    return null;
  },
});
```

**Output**: Subscription activation implemented

---

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 1.4 - Frontend Checkout Implementation
2. **Test**: End-to-end payment flow

## üîó Related Tasks

- Task 0.1: QRIS.id merchant registration (prerequisite)
- Task 0.2: Polar pricing update (parallel)
- Task 0.3: Unified subscription check (parallel)
- Task 1.4: Frontend checkout (next)

## ‚ö†Ô∏è Important Notes

### Why Server-Side Polling?

**Problems with Frontend Polling:**
- Stops if user closes browser
- Stops if user refreshes page
- Misses payments on different device

**Server-Side Benefits:**
- Works even if user closes browser
- Detects payments from any device
- Efficient batch processing

### Rate Limiting

**QRIS.id API Limits:**
- Don't check more than every 15 seconds
- Max 3 checks per 15 seconds per invoice
- Our implementation: 30-second cron, 15-second min interval

### Progress Tracking

After completing this task, update `plans/gtm-pricing-strategy/progress.txt`.
