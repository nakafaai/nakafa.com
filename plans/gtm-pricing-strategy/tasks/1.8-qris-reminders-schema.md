# Task 1.8: QRIS Renewal Reminders Schema

## üéØ Goal

Create scalable schema for QRIS renewal reminders (separate from qrisPayments table).

## üìç Context

**Problem with Current Design:**
- Hardcoded `reminderSent25`, `reminderSent29`, `reminderSent30` fields in qrisPayments table
- Not scalable - adding new reminder days requires schema migration
- Mixing payment data with reminder tracking

**Solution:**
- Separate `qrisRenewalReminders` table (QRIS-specific, not for Polar)
- Flexible reminder scheduling without schema changes
- Clean separation of concerns

**Why QRIS Only?**
- Polar has automatic recurring billing - no manual reminders needed
- QRIS is one-time payment only - needs manual renewal reminders
- Table name reflects this is QRIS-specific

**Prerequisites:**
- Task 1.3 completed (qrisPayments table exists)

## PRD

```json
{
  "category": "schema",
  "description": "Create scalable QRIS renewal reminders schema",
  "steps": [
    "Create qrisRenewalReminders table schema",
    "Add to main schema.ts",
    "Create queries for reminder management"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] qrisRenewalReminders table schema created
- [ ] Schema registered in main schema.ts
- [ ] Queries for checking sent reminders
- [ ] Indexes for efficient reminder queries
- [ ] Uses kebab-case for literal strings

## üìù Implementation

### Create qrisRenewalReminders Schema

**File**: `packages/backend/convex/qrisRenewalReminders/schema.ts`

```typescript
import { defineTable } from "convex/server";
import { v } from "convex/values";

const tables = {
  qrisRenewalReminders: defineTable({
    userId: v.id("users"),
    paymentId: v.id("qrisPayments"),
    reminderType: v.union(
      v.literal("renewal-25-days"),  // Day 25 - friendly reminder
      v.literal("renewal-29-days"),  // Day 29 - urgent reminder
      v.literal("renewal-30-days"),  // Day 30 - grace period warning
      v.literal("renewal-expired")   // After grace period
    ),
    scheduledFor: v.number(),        // When reminder should be sent
    sentAt: v.optional(v.number()),  // When actually sent
    status: v.union(
      v.literal("pending"),
      v.literal("sent"),
      v.literal("failed"),
      v.literal("skipped")
    ),
    renewalLink: v.string(),         // Tokenized renewal URL
    errorMessage: v.optional(v.string()),
    createdAt: v.number(),
    updatedAt: v.number(),
  })
    .index("userId", ["userId"])
    .index("userId_status", ["userId", "status"])
    .index("paymentId", ["paymentId"])
    .index("status_scheduledFor", ["status", "scheduledFor"])
    .index("reminderType", ["reminderType"]),
};

export default tables;
```

**Key Design Decisions:**
1. **Table name** - `qrisRenewalReminders` (not `subscriptionReminders`) - clearly QRIS-specific
2. **Kebab-case literals** - `renewal-25-days` (not `renewal_25_days`) - Convex convention
3. **Separate table** - Not polluting qrisPayments with reminder data
4. **Flexible reminderType** - Can add new types without schema changes
5. **scheduledFor** - Allows scheduling reminders in advance
6. **status tracking** - Know if sent, failed, or skipped
7. **renewalLink stored** - Tokenized URL for one-click renewal

**Why Kebab-Case?**
Per Convex conventions, use hyphens (`-`) not underscores (`_`) for literal string values:
```typescript
// Good (kebab-case)
v.literal("renewal-25-days")

// Bad (snake_case)
v.literal("renewal_25_days")
```

### Register Schema

**File**: Update `packages/backend/convex/schema.ts`

```typescript
import qrisRenewalRemindersSchema from "@repo/backend/convex/qrisRenewalReminders/schema";

export default defineSchema(
  {
    ...usersSchema,
    ...chatsSchema,
    ...customersSchema,
    ...subscriptionsSchema,
    ...qrisPaymentsSchema,
    ...qrisRenewalRemindersSchema,  // Add this
    ...schoolsSchema,
    // ... rest
  },
  { schemaValidation: true }
);
```

### Create Queries

**File**: `packages/backend/convex/qrisRenewalReminders/queries.ts`

```typescript
import { query, internalQuery } from "@repo/backend/convex/_generated/server";
import { v } from "convex/values";

export const getPendingReminders = internalQuery({
  args: {
    limit: v.number(),
    beforeTimestamp: v.number(),
  },
  returns: v.array(
    v.object({
      _id: v.id("qrisRenewalReminders"),
      userId: v.id("users"),
      paymentId: v.id("qrisPayments"),
      reminderType: v.string(),
      scheduledFor: v.number(),
      renewalLink: v.string(),
    })
  ),
  handler: async (ctx, args) => {
    return await ctx.db
      .query("qrisRenewalReminders")
      .withIndex("status_scheduledFor", (q) =>
        q.eq("status", "pending").lte("scheduledFor", args.beforeTimestamp)
      )
      .take(args.limit);
  },
});

export const hasReminderBeenSent = internalQuery({
  args: {
    paymentId: v.id("qrisPayments"),
    reminderType: v.string(),
  },
  returns: v.boolean(),
  handler: async (ctx, args) => {
    const reminder = await ctx.db
      .query("qrisRenewalReminders")
      .withIndex("paymentId", (q) => q.eq("paymentId", args.paymentId))
      .filter((q) => q.eq(q.field("reminderType"), args.reminderType))
      .first();
    
    return reminder?.status === "sent";
  },
});
```

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 1.9 - QRIS Reminder Scheduler
2. **Next task**: Task 1.10 - QRIS Reminder Email Templates

## üîó Related Tasks

- Task 1.3: QRIS Backend Integration (prerequisite)
- Task 1.9: QRIS Reminder Scheduler (next)
- Task 1.10: QRIS Reminder Email Templates (next)

## ‚ö†Ô∏è Important Notes

### Why Separate Table?

**Before (Bad):**
```typescript
qrisPayments: defineTable({
  // ... payment fields
  reminderSent25: v.optional(v.boolean()),
  reminderSent29: v.optional(v.boolean()),
  reminderSent30: v.optional(v.boolean()),
  // Adding Day 27 requires schema migration!
})
```

**After (Good):**
```typescript
qrisRenewalReminders: defineTable({
  reminderType: v.union(
    v.literal("renewal-25-days"),
    v.literal("renewal-27-days"),  // Just add here
    v.literal("renewal-29-days"),
    // No schema migration needed!
  ),
})
```

### Why Not "subscriptionReminders"?

**subscriptionReminders** (Bad):
- Confusing - implies it works for all subscriptions
- Polar subscriptions don't need this (automatic renewal)
- Only QRIS needs manual renewal reminders

**qrisRenewalReminders** (Good):
- Clear it's QRIS-specific
- No confusion with Polar subscriptions
- Accurate domain naming

### Benefits

1. **Scalable** - Add new reminder types without migrations
2. **Queryable** - Easy to check reminder history
3. **Auditable** - Know exactly what was sent and when
4. **Flexible** - Can reschedule, skip, or retry reminders
5. **Clean** - Payment data and reminder data separated
6. **Clear naming** - No confusion with Polar subscriptions

### Progress Tracking

After completing this task, update `plans/gtm-pricing-strategy/progress.txt`.
