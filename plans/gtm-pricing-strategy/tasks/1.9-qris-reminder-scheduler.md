# Task 1.9: QRIS Reminder Scheduler

## üéØ Goal

Implement cron job and scheduler for sending QRIS renewal reminder emails.

## üìç Context

**Prerequisites:**
- Task 1.3 completed (qrisPayments table)
- Task 1.8 completed (qrisRenewalReminders table)
- Email infrastructure exists

**Reminder Schedule:**
- Day 25: Friendly reminder (5 days before expiry)
- Day 29: Urgent reminder (1 day before expiry)
- Day 30: Grace period warning (on expiry day)

## PRD

```json
{
  "category": "integration",
  "description": "Implement automated reminder scheduling and sending",
  "steps": [
    "Create cron job for daily reminder checks",
    "Implement reminder scheduling on payment",
    "Implement reminder sending logic",
    "Handle reminder status updates"
  ],
  "passes": false
}
```

## üé¨ Success Criteria

- [ ] Daily cron job checks for pending reminders
- [ ] Reminders scheduled when payment is marked paid
- [ ] Reminders sent at correct times
- [ ] Status tracked (pending/sent/failed)
- [ ] No duplicate reminders sent
- [ ] Uses kebab-case for reminder types

## üìù Implementation

### Update Cron Jobs

**File**: Update `packages/backend/convex/crons.ts`

```typescript
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

// Check pending QRIS payments every 30 seconds
cronJobs.interval(
  "checkPendingQrisPayments",
  { seconds: 30 },
  internal.payments.checkPendingQrisPayments
);

// NEW: Send QRIS renewal reminders daily
cronJobs.interval(
  "sendQrisRenewalReminders",
  { hours: 24 },
  internal.payments.sendQrisRenewalReminders
);

// Cleanup expired payments every hour
cronJobs.interval(
  "cleanupExpiredQrisPayments",
  { hours: 1 },
  internal.payments.cleanupExpiredQrisPayments
);
```

### Schedule Reminders on Payment

**File**: Update `packages/backend/convex/qrisPayments/mutations.ts`

```typescript
import { internalMutation } from "@repo/backend/convex/_generated/server";
import { v } from "convex/values";
import { internal } from "@repo/backend/convex/_generated/api";

export const markAsPaid = internalMutation({
  args: {
    invoiceId: v.string(),
    paymentMethod: v.string(),
    customerName: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const payment = await ctx.db
      .query("qrisPayments")
      .withIndex("invoiceId", (q) => q.eq("invoiceId", args.invoiceId))
      .unique();

    if (!payment || payment.status !== "pending") {
      return null;
    }

    const now = Date.now();
    const thirtyDays = 30 * 24 * 60 * 60 * 1000;
    const expiresAt = now + thirtyDays;

    // Mark as paid
    await ctx.db.patch(payment._id, {
      status: "paid",
      paymentMethod: args.paymentMethod,
      customerName: args.customerName,
      paidAt: now,
      expiresAt,
      updatedAt: now,
    });

    // Schedule QRIS renewal reminders
    await ctx.runMutation(internal.qrisRenewalReminders.mutations.scheduleReminders, {
      userId: payment.userId,
      paymentId: payment._id,
      expiresAt,
    });

    return null;
  },
});
```

### Create Reminder Scheduling Mutation

**File**: `packages/backend/convex/qrisRenewalReminders/mutations.ts`

```typescript
import { internalMutation } from "@repo/backend/convex/_generated/server";
import { v } from "convex/values";

// Kebab-case for reminder types per Convex convention
const REMINDER_SCHEDULE = [
  { type: "renewal-25-days", daysBeforeExpiry: 5 },
  { type: "renewal-29-days", daysBeforeExpiry: 1 },
  { type: "renewal-30-days", daysBeforeExpiry: 0 },
];

export const scheduleReminders = internalMutation({
  args: {
    userId: v.id("users"),
    paymentId: v.id("qrisPayments"),
    expiresAt: v.number(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    const now = Date.now();

    for (const schedule of REMINDER_SCHEDULE) {
      const scheduledFor = args.expiresAt - (schedule.daysBeforeExpiry * 24 * 60 * 60 * 1000);
      
      // Skip if scheduled time is in the past
      if (scheduledFor < now) continue;

      // Generate renewal token
      const renewalToken = await ctx.runMutation(
        internal.qrisRenewalReminders.mutations.createRenewalToken,
        { userId: args.userId, paymentId: args.paymentId }
      );

      const renewalLink = `https://nakafa.com/pricing?renewal=${renewalToken}`;

      await ctx.db.insert("qrisRenewalReminders", {
        userId: args.userId,
        paymentId: args.paymentId,
        reminderType: schedule.type,  // Kebab-case: "renewal-25-days"
        scheduledFor,
        status: "pending",
        renewalLink,
        createdAt: now,
        updatedAt: now,
      });
    }

    return null;
  },
});

export const createRenewalToken = internalMutation({
  args: {
    userId: v.id("users"),
    paymentId: v.id("qrisPayments"),
  },
  returns: v.string(),
  handler: async (ctx, args) => {
    const token = crypto.randomUUID();
    
    await ctx.db.insert("renewalTokens", {
      token,
      userId: args.userId,
      paymentId: args.paymentId,
      createdAt: Date.now(),
      expiresAt: Date.now() + (7 * 24 * 60 * 60 * 1000), // 7 days
    });
    
    return token;
  },
});

export const markReminderSent = internalMutation({
  args: {
    reminderId: v.id("qrisRenewalReminders"),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch(args.reminderId, {
      status: "sent",
      sentAt: Date.now(),
      updatedAt: Date.now(),
    });
    return null;
  },
});

export const markReminderFailed = internalMutation({
  args: {
    reminderId: v.id("qrisRenewalReminders"),
    errorMessage: v.string(),
  },
  returns: v.null(),
  handler: async (ctx, args) => {
    await ctx.db.patch(args.reminderId, {
      status: "failed",
      errorMessage: args.errorMessage,
      updatedAt: Date.now(),
    });
    return null;
  },
});
```

### Create Reminder Sender Action

**File**: `packages/backend/convex/payments/actions.ts` (add to existing)

```typescript
"use node";

import { internalAction } from "@repo/backend/convex/_generated/server";
import { internal } from "@repo/backend/convex/_generated/api";
import { render } from "@react-email/render";
import { RenewalReminder } from "@repo/email/templates/renewal-reminder";
import { resend } from "@repo/email";

const CONFIG = {
  BATCH_SIZE: 10,
};

export const sendQrisRenewalReminders = internalAction({
  args: {},
  handler: async (ctx) => {
    const now = Date.now();
    
    // Get pending reminders that are due
    const reminders = await ctx.runQuery(
      internal.qrisRenewalReminders.queries.getPendingReminders,
      {
        limit: CONFIG.BATCH_SIZE,
        beforeTimestamp: now,
      }
    );

    for (const reminder of reminders) {
      try {
        // Get user details
        const user = await ctx.runQuery(
          internal.users.queries.getUserById,
          { userId: reminder.userId }
        );

        if (!user?.email) {
          await ctx.runMutation(
            internal.qrisRenewalReminders.mutations.markReminderFailed,
            {
              reminderId: reminder._id,
              errorMessage: "User email not found",
            }
          );
          continue;
        }

        // Render React Email to HTML
        const html = await render(
          RenewalReminder({
            name: user.name || "Pengguna Nakafa",
            reminderType: reminder.reminderType,  // Kebab-case
            expiresAt: reminder.expiresAt,
            renewalLink: reminder.renewalLink,
          })
        );

        // Send via Resend
        await resend.emails.send({
          from: "Nakafa <noreply@nakafa.com>",
          to: user.email,
          subject: getSubject(reminder.reminderType),
          html,
        });

        // Mark as sent
        await ctx.runMutation(
          internal.qrisRenewalReminders.mutations.markReminderSent,
          { reminderId: reminder._id }
        );

      } catch (error) {
        console.error(`Failed to send reminder ${reminder._id}:`, error);
        await ctx.runMutation(
          internal.qrisRenewalReminders.mutations.markReminderFailed,
          {
            reminderId: reminder._id,
            errorMessage: error instanceof Error ? error.message : "Unknown error",
          }
        );
      }
    }
  },
});

function getSubject(reminderType: string): string {
  switch (reminderType) {
    case "renewal-25-days":
      return "Nakafa Pro akan berakhir dalam 5 hari";
    case "renewal-29-days":
      return "‚è∞ Nakafa Pro berakhir besok!";
    case "renewal-30-days":
      return "‚ö†Ô∏è Nakafa Pro telah berakhir - Grace period 3 hari";
    default:
      return "Nakafa Pro Subscription";
  }
}
```

## üöÄ Next Steps

After completing this task:

1. **Next task**: Task 1.10 - QRIS Reminder Email Templates
2. **Test**: Verify reminders are scheduled and sent correctly

## üîó Related Tasks

- Task 1.3: QRIS Backend Integration (prerequisite)
- Task 1.8: QRIS Reminders Schema (prerequisite)
- Task 1.10: QRIS Reminder Email Templates (next)

## ‚ö†Ô∏è Important Notes

### Reminder Schedule Logic

```
Payment made on Day 0
‚îú‚îÄ‚îÄ Day 25 (5 days before expiry): Friendly reminder
‚îú‚îÄ‚îÄ Day 29 (1 day before expiry): Urgent reminder
‚îî‚îÄ‚îÄ Day 30 (on expiry): Grace period warning
```

### Kebab-Case Convention

Per Convex best practices, use hyphens (`-`) not underscores (`_`):

```typescript
// Good (kebab-case)
{ type: "renewal-25-days", daysBeforeExpiry: 5 }

// Bad (snake_case)
{ type: "renewal_25_days", daysBeforeExpiry: 5 }
```

### Adding New Reminder Types

To add a Day 27 reminder:

1. Add to REMINDER_SCHEDULE array:
```typescript
{ type: "renewal-27-days", daysBeforeExpiry: 3 }
```

2. Add email template for new type

3. No schema migration needed!

### Progress Tracking

After completing this task, update `plans/gtm-pricing-strategy/progress.txt`.
