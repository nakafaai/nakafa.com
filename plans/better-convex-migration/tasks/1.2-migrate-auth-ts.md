# Task 1.2: Migrate auth.ts to better-convex Pattern

## Goal

Rewrite auth.ts using better-convex patterns.

## Implementation

Update `packages/backend/convex/auth.ts`:

```typescript
import { convex } from "@convex-dev/better-auth/plugins";
import { betterAuth, type BetterAuthOptions } from "better-auth";
import {
  anonymous,
  apiKey,
  openAPI,
  organization,
  username,
} from "better-auth/plugins";
import {
  createApi,
  createClient,
  type AuthFunctions,
  getAuthUserIdentity,
} from "better-convex/auth";
import { internal } from "./_generated/api";
import type { DataModel, Id } from "./_generated/dataModel";
import type { ActionCtx, MutationCtx, QueryCtx } from "./_generated/server";
import { query } from "./_generated/server";
import authConfig from "./auth.config";
import schema from "./schema";
import { vv } from "./lib/validators";

type GenericCtx = QueryCtx | MutationCtx | ActionCtx;
const siteUrl = process.env.SITE_URL ?? "http://localhost:3000";

// Auth functions reference
const authFunctions: AuthFunctions = internal.auth;

// Auth client with triggers
export const authClient = createClient<DataModel, typeof schema>({
  authFunctions,
  schema,
  triggers: {
    user: {
      onCreate: async (ctx, authUser) => {
        const userId = await ctx.db.insert("users", {
          email: authUser.email,
          authId: authUser._id,
          name: authUser.name,
          image: authUser.image ?? undefined,
        });

        await ctx.db.insert("notificationPreferences", {
          userId,
          emailEnabled: true,
          emailDigest: "weekly",
          disabledTypes: [],
          mutedEntities: [],
          updatedAt: Date.now(),
        });

        await ctx.scheduler.runAfter(0, internal.customers.actions.syncCustomer, { userId });
        await ctx.scheduler.runAfter(0, internal.emails.mutations.sendWelcomeEmail, {
          name: authUser.name,
          email: authUser.email,
        });
      },
      onUpdate: async (ctx, newDoc, oldDoc) => {
        if (newDoc.name !== oldDoc.name || newDoc.image !== oldDoc.image) {
          const appUser = await ctx.db.query("users").withIndex("authId", (q) => q.eq("authId", newDoc._id)).unique();
          if (appUser) {
            await ctx.db.patch("users", appUser._id, {
              name: newDoc.name,
              image: newDoc.image ?? undefined,
            });
          }
        }
      },
      onDelete: async (ctx, authUser) => {
        const userApp = await ctx.db.query("users").withIndex("authId", (q) => q.eq("authId", authUser._id)).unique();
        if (userApp) {
          await ctx.scheduler.runAfter(0, internal.customers.actions.cleanupUserData, { userId: userApp._id });
          await ctx.db.delete("users", userApp._id);
        }
      },
    },
  },
});

// Auth options factory
const createAuthOptions = (ctx: GenericCtx) => ({
  baseURL: siteUrl,
  emailAndPassword: { enabled: true },
  account: { accountLinking: { enabled: true, allowDifferentEmails: true } },
  socialProviders: {
    google: {
      clientId: process.env.AUTH_GOOGLE_ID || "",
      clientSecret: process.env.AUTH_GOOGLE_SECRET || "",
      accessType: "offline",
      prompt: "select_account consent",
      mapProfileToUser: (profile) => ({
        username: profile.email,
        displayUsername: profile.email.split("@")[0],
      }),
    },
  },
  user: { deleteUser: { enabled: true } },
  plugins: [
    anonymous(),
    username(),
    organization(),
    apiKey(),
    openAPI(),
    convex({ authConfig, jwks: process.env.JWKS, jwksRotateOnTokenGenerationError: true }),
  ],
  database: authClient.httpAdapter(ctx),
}) satisfies BetterAuthOptions;

// For queries/mutations
export const getAuth = <Ctx extends QueryCtx | MutationCtx>(ctx: Ctx) =>
  betterAuth({ ...createAuthOptions(ctx), database: authClient.adapter(ctx, createAuthOptions) });

// For actions/HTTP
export const createAuth = (ctx: ActionCtx) => betterAuth(createAuthOptions(ctx));

// Internal CRUD functions
export const { create, deleteMany, deleteOne, findMany, findOne, updateMany, updateOne, getLatestJwks, rotateKeys } = 
  createApi(schema, createAuth);

// Trigger handlers
export const { beforeCreate, beforeDelete, beforeUpdate, onCreate, onDelete, onUpdate } = authClient.triggersApi();

// Export for CLI
export const auth = betterAuth(createAuthOptions({} as GenericCtx));

// Helper functions
export const safeGetUser = (ctx: QueryCtx) => getAuthUserIdentity(ctx);

export const safeGetAppUser = async (ctx: QueryCtx) => {
  const identity = await getAuthUserIdentity(ctx);
  if (!identity) return null;
  const user = await ctx.db.query("users").withIndex("authId", (q) => q.eq("authId", identity.userId)).unique();
  if (!user) return null;
  return { appUser: user, authUser: identity };
};

export const getAnyAppUserById = async (ctx: QueryCtx, userId: Id<"users">) => {
  const user = await ctx.db.get("users", userId);
  if (!user) return null;
  const identity = await getAuthUserIdentity(ctx);
  if (!identity || identity.userId !== user.authId) return null;
  return { appUser: user, authUser: identity };
};

export const getCurrentUser = query({ args: {}, handler: (ctx) => safeGetAppUser(ctx) });
export const getUserById = query({ args: { userId: vv.id("users") }, handler: (ctx, args) => getAnyAppUserById(ctx, args.userId) });

export type AppUser = NonNullable<Awaited<ReturnType<typeof safeGetAppUser>>>;
export type AnyAppUser = NonNullable<Awaited<ReturnType<typeof getAnyAppUserById>>>;
```

## Verification

- [ ] TypeScript compiles
- [ ] Triggers configured
- [ ] Both adapters exported
- [ ] Helper functions work

## Next

Task 1.3: Update HTTP Router
