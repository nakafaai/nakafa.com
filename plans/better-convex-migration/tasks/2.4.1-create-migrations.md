# Task 2.4.1: Create Migration Using Migrations Component

## Goal

Create a migration using the existing @convex-dev/migrations component to copy auth data from component tables to main app tables.

## Context

Since the author's script has missing dependencies, we'll use the Convex migrations component that you already have installed. This is a robust, production-tested approach.

## How It Works

The migrations component will:
1. Read from component tables using `components.betterAuth.adapter`
2. Write to main app tables using `ctx.db`
3. Track migration progress (can resume if interrupted)
4. Run in batches (safe for production)

## Implementation

Create `packages/backend/convex/migrations/betterAuthDataMigration.ts`:

```typescript
import { components } from "@repo/backend/convex/_generated/api";
import { internalMutation } from "@repo/backend/convex/_generated/server";
import { Migrations } from "@convex-dev/migrations";
import type { DataModel } from "@repo/backend/convex/_generated/dataModel";

const migrations = new Migrations<DataModel>(components.migrations);

/**
 * Migration: Copy users from Better Auth component to main schema
 */
export const migrateUsers = migrations.define({
  table: "user",
  migrateOne: async (ctx, authUser) => {
    // Check if already migrated
    const existing = await ctx.db
      .query("user")
      .withIndex("email_name", (q) => q.eq("email", authUser.email))
      .unique();
    
    if (existing) {
      return; // Already migrated, skip
    }

    // Insert into main schema
    await ctx.db.insert("user", {
      name: authUser.name,
      email: authUser.email,
      emailVerified: authUser.emailVerified,
      image: authUser.image,
      createdAt: authUser.createdAt,
      updatedAt: authUser.updatedAt,
      isAnonymous: authUser.isAnonymous,
      username: authUser.username,
      displayUsername: authUser.displayUsername,
      userId: authUser.userId,
    });
  },
});

/**
 * Migration: Copy API keys from Better Auth component to main schema
 */
export const migrateApiKeys = migrations.define({
  table: "apikey",
  migrateOne: async (ctx, apiKey) => {
    // Check if already migrated
    const existing = await ctx.db
      .query("apikey")
      .withIndex("key", (q) => q.eq("key", apiKey.key))
      .unique();
    
    if (existing) {
      return; // Already migrated, skip
    }

    // Insert into main schema (preserve exactly)
    await ctx.db.insert("apikey", {
      name: apiKey.name,
      start: apiKey.start,
      prefix: apiKey.prefix,
      key: apiKey.key,
      userId: apiKey.userId,
      refillInterval: apiKey.refillInterval,
      refillAmount: apiKey.refillAmount,
      lastRefillAt: apiKey.lastRefillAt,
      enabled: apiKey.enabled,
      rateLimitEnabled: apiKey.rateLimitEnabled,
      rateLimitTimeWindow: apiKey.rateLimitTimeWindow,
      rateLimitMax: apiKey.rateLimitMax,
      requestCount: apiKey.requestCount,
      remaining: apiKey.remaining,
      lastRequest: apiKey.lastRequest,
      expiresAt: apiKey.expiresAt,
      createdAt: apiKey.createdAt,
      updatedAt: apiKey.updatedAt,
      permissions: apiKey.permissions,
      metadata: apiKey.metadata,
    });
  },
});

/**
 * Migration: Copy organizations from Better Auth component to main schema
 */
export const migrateOrganizations = migrations.define({
  table: "organization",
  migrateOne: async (ctx, org) => {
    // Check if already exists
    const existing = await ctx.db
      .query("organization")
      .withIndex("slug", (q) => q.eq("slug", org.slug))
      .unique();
    
    if (existing) {
      return; // Already exists, skip
    }

    await ctx.db.insert("organization", {
      name: org.name,
      slug: org.slug,
      logo: org.logo,
      createdAt: org.createdAt,
      metadata: org.metadata,
    });
  },
});

/**
 * Migration: Copy members from Better Auth component to main schema
 */
export const migrateMembers = migrations.define({
  table: "member",
  migrateOne: async (ctx, member) => {
    // Check if already exists
    const existing = await ctx.db
      .query("member")
      .withIndex("organizationId", (q) => 
        q.eq("organizationId", member.organizationId).eq("userId", member.userId))
      .unique();
    
    if (existing) {
      return; // Already exists, skip
    }

    await ctx.db.insert("member", {
      organizationId: member.organizationId,
      userId: member.userId,
      role: member.role,
      createdAt: member.createdAt,
    });
  },
});

/**
 * Migration: Copy invitations from Better Auth component to main schema
 */
export const migrateInvitations = migrations.define({
  table: "invitation",
  migrateOne: async (ctx, invite) => {
    // Check if already exists
    const existing = await ctx.db
      .query("invitation")
      .withIndex("email", (q) => 
        q.eq("email", invite.email).eq("organizationId", invite.organizationId))
      .unique();
    
    if (existing) {
      return; // Already exists, skip
    }

    await ctx.db.insert("invitation", {
      organizationId: invite.organizationId,
      email: invite.email,
      role: invite.role,
      status: invite.status,
      expiresAt: invite.expiresAt,
      createdAt: invite.createdAt,
      inviterId: invite.inviterId,
    });
  },
});

// Export runner
export const runMigrations = migrations.runner([
  internal.migrations.betterAuthDataMigration.migrateUsers,
  internal.migrations.betterAuthDataMigration.migrateApiKeys,
  internal.migrations.betterAuthDataMigration.migrateOrganizations,
  internal.migrations.betterAuthDataMigration.migrateMembers,
  internal.migrations.betterAuthDataMigration.migrateInvitations,
]);
```

## Verification

- [ ] Migration file created
- [ ] TypeScript compiles
- [ ] Migrations are defined for all auth tables

## Next

Task 2.4.2: Run Migrations
